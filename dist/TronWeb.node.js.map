{"version":3,"file":"TronWeb.node.js","mappings":"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","sources":["webpack://@sterliakov/tstron/webpack/bootstrap","webpack://@sterliakov/tstron/webpack/runtime/compat get default export","webpack://@sterliakov/tstron/webpack/runtime/define property getters","webpack://@sterliakov/tstron/webpack/runtime/hasOwnProperty shorthand","webpack://@sterliakov/tstron/webpack/runtime/make namespace object","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/asyncToGenerator\"","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/typeof\"","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/classCallCheck\"","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/createClass\"","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/assertThisInitialized\"","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/inherits\"","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/getPrototypeOf\"","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/defineProperty\"","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/regenerator\"","webpack://@sterliakov/tstron/external commonjs \"bignumber.js\"","webpack://@sterliakov/tstron/external commonjs \"eventemitter3\"","webpack://@sterliakov/tstron/external commonjs \"injectpromise\"","webpack://@sterliakov/tstron/external commonjs \"semver\"","webpack://@sterliakov/tstron/./version.js","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/slicedToArray\"","webpack://@sterliakov/tstron/./src/utils/_base.ts","webpack://@sterliakov/tstron/external commonjs \"validator\"","webpack://@sterliakov/tstron/./src/utils/address.ts","webpack://@sterliakov/tstron/external commonjs \"ethers\"","webpack://@sterliakov/tstron/./src/utils/ethersUtils.ts","webpack://@sterliakov/tstron/./src/utils/abi.ts","webpack://@sterliakov/tstron/./src/utils/base64.ts","webpack://@sterliakov/tstron/./src/utils/bytes.ts","webpack://@sterliakov/tstron/external commonjs \"@babel/runtime/helpers/toConsumableArray\"","webpack://@sterliakov/tstron/external commonjs \"elliptic\"","webpack://@sterliakov/tstron/./src/utils/base58.ts","webpack://@sterliakov/tstron/./src/utils/code.ts","webpack://@sterliakov/tstron/external commonjs \"@ethersproject/bignumber\"","webpack://@sterliakov/tstron/external commonjs \"@ethersproject/bytes\"","webpack://@sterliakov/tstron/external commonjs \"@ethersproject/keccak256\"","webpack://@sterliakov/tstron/external commonjs \"@ethersproject/logger\"","webpack://@sterliakov/tstron/external commonjs \"@ethersproject/properties\"","webpack://@sterliakov/tstron/external commonjs \"@ethersproject/strings\"","webpack://@sterliakov/tstron/./src/utils/typedData.ts","webpack://@sterliakov/tstron/./src/utils/crypto.ts","webpack://@sterliakov/tstron/./src/utils/accounts.ts","webpack://@sterliakov/tstron/./src/utils/message.ts","webpack://@sterliakov/tstron/./src/utils/index.ts","webpack://@sterliakov/tstron/./src/lib/contract/method.ts","webpack://@sterliakov/tstron/./src/lib/contract/index.ts","webpack://@sterliakov/tstron/external node-commonjs \"querystring\"","webpack://@sterliakov/tstron/external commonjs \"axios\"","webpack://@sterliakov/tstron/./src/lib/providers/HttpProvider.ts","webpack://@sterliakov/tstron/./src/lib/providers/index.ts","webpack://@sterliakov/tstron/./src/lib/event.ts","webpack://@sterliakov/tstron/./src/lib/plugin.ts","webpack://@sterliakov/tstron/./src/paramValidator/index.ts","webpack://@sterliakov/tstron/./src/lib/sidechain.ts","webpack://@sterliakov/tstron/./src/proto/core/contract/common.ts","webpack://@sterliakov/tstron/./src/lib/trx.ts","webpack://@sterliakov/tstron/./src/lib/transactionBuilder.ts","webpack://@sterliakov/tstron/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/asyncToGenerator\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/typeof\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/classCallCheck\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/createClass\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/assertThisInitialized\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/inherits\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/getPrototypeOf\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/defineProperty\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/regenerator\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"bignumber.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"eventemitter3\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"injectpromise\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"semver\");","// Generated by genversion.\nexport const version = '0.1.0-alpha.2';\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/slicedToArray\");","import injectpromise from 'injectpromise';\n\nimport TronWeb from '../../src';\n\nexport class WithTronwebAndInjectpromise {\n    tronWeb: TronWeb;\n    injectPromise: injectpromise;\n\n    constructor(tronWeb: TronWeb) {\n        if (!tronWeb)\n            throw new Error('Expected instances of TronWeb and utils');\n        this.tronWeb = tronWeb;\n        this.injectPromise = injectpromise(this);\n    }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"validator\");","export const ADDRESS_SIZE = 34;\nexport const ADDRESS_PREFIX = '41';\nexport const ADDRESS_PREFIX_BYTE = 0x41;\nexport const ADDRESS_PREFIX_REGEX = /^(41)/;\n\nexport const TRON_BIP39_PATH_PREFIX = \"m/44'/195'\";\nexport const TRON_BIP39_PATH_INDEX_0 = TRON_BIP39_PATH_PREFIX + \"/0'/0/0\";\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"ethers\");","import type {BytesLike} from '@ethersproject/bytes';\nimport {utils} from 'ethers';\n\nexport {Wallet as ethersWallet} from 'ethers';\nexport type {Wordlist} from 'ethers';\nexport type {Bytes, BytesLike} from '@ethersproject/bytes';\nexport type {Mnemonic} from '@ethersproject/hdnode';\n\nconst {\n    keccak256,\n    sha256,\n    toUtf8Bytes,\n    toUtf8String,\n    recoverAddress,\n    SigningKey: SigningKey_,\n    AbiCoder,\n    Interface,\n    FormatTypes,\n    arrayify,\n    splitSignature,\n    joinSignature,\n    concat,\n    id,\n    isValidMnemonic,\n} = utils;\n\n/**\n * Allow passing less precise values to constructor, because they work\n */\nexport class SigningKey extends SigningKey_ {\n    constructor(\n        privateKey: BytesLike | {value: string; toHexString: () => string},\n    ) {\n        super(privateKey as BytesLike);\n    }\n}\n\nexport {\n    keccak256,\n    sha256,\n    toUtf8Bytes,\n    toUtf8String,\n    recoverAddress,\n    AbiCoder,\n    Interface,\n    FormatTypes,\n    splitSignature,\n    joinSignature,\n    arrayify,\n    concat,\n    id,\n    isValidMnemonic,\n};\n","import TronWeb from '..';\nimport {ADDRESS_PREFIX, ADDRESS_PREFIX_REGEX} from './address';\nimport {AbiCoder} from './ethersUtils';\n\nconst abiCoder = new AbiCoder();\n\nfunction _addressToHex(value: string): string {\n    return TronWeb.address.toHex(value).replace(ADDRESS_PREFIX_REGEX, '0x');\n}\n\nfunction deepCopy<T>(target: T): T {\n    if (\n        Object.prototype.toString.call(target) !== '[object Object]' &&\n        Object.prototype.toString.call(target) !== '[object Array]'\n    )\n        return target;\n\n    const newTarget = (Array.isArray(target) ? [] : {}) as typeof target;\n\n    for (const key in target)\n        newTarget[key] =\n            target[key] instanceof Object && !target[key]['_isBigNumber']\n                ? deepCopy(target[key])\n                : target[key];\n\n    return newTarget;\n}\n\nexport function decodeParams(\n    names_: string[],\n    types_: string,\n    output_?: boolean,\n): any;\nexport function decodeParams(\n    names_: string[],\n    types_: string[],\n    output_?: string,\n    ignoreMethodHash_?: boolean,\n): any[];\nexport function decodeParams(\n    names_: string[],\n    types_: string[] | string,\n    output_?: string | boolean,\n    ignoreMethodHash_?: boolean,\n): any[] {\n    let ignoreMethodHash: boolean;\n    let output: string;\n    let types: string[];\n    let names: string[];\n    if (!output_ || typeof output_ === 'boolean') {\n        // @ts-ignore\n        ignoreMethodHash = output_;\n        // @ts-ignore\n        output = types_;\n        types = names_;\n        names = [];\n    } else {\n        // @ts-ignore\n        ignoreMethodHash = ignoreMethodHash_;\n        output = output_;\n        // @ts-ignore\n        types = types_;\n        names = names_;\n    }\n\n    if (ignoreMethodHash && output.replace(/^0x/, '').length % 64 === 8)\n        output = '0x' + output.replace(/^0x/, '').substring(8);\n\n    if (output.replace(/^0x/, '').length % 64)\n        throw new Error(\n            'The encoded string is not valid. Its length must be a multiple of 64.',\n        );\n\n    // workaround for unsupported trcToken type\n    types = types.map((type) => {\n        if (/trcToken/.test(type)) type = type.replace(/trcToken/, 'uint256');\n\n        return type;\n    });\n\n    return abiCoder.decode(types, output).reduce(\n        (obj, arg, index) => {\n            if (types[index] === 'address')\n                arg = ADDRESS_PREFIX + arg.substr(2).toLowerCase();\n\n            if (names.length) obj[names[index]] = arg;\n            else obj.push(arg);\n\n            return obj;\n        },\n        names.length ? {} : [],\n    );\n}\n\nexport function encodeParams(types: string[], values: any[]): string {\n    for (let i = 0; i < types.length; i++)\n        if (types[i] === 'address')\n            values[i] = TronWeb.address\n                .toHex(values[i])\n                .replace(ADDRESS_PREFIX_REGEX, '0x');\n\n    return abiCoder.encode(types, values);\n}\n\nfunction extractSize(type: string): string {\n    const size = type.match(/([a-zA-Z0-9])(\\[.*\\])/);\n    return size ? size[2] : '';\n}\n\nfunction extractArrayDim(type: string): number {\n    const size = extractSize(type);\n    return (size.match(/\\]\\[/g) || []).length + 1;\n}\n\nexport interface IFieldABI {\n    name: string;\n    type: string;\n    components?: IFieldABI[];\n}\nexport interface IFunABI {\n    inputs?: IFieldABI[];\n    outputs?: IFieldABI[];\n}\n\nexport function encodeParamsV2ByABI(funABI: IFunABI, args: unknown[]) {\n    const types: string[] = [];\n\n    const buildFullTypeDefinition = (typeDef) => {\n        if (\n            typeDef &&\n            typeDef.type.indexOf('tuple') === 0 &&\n            typeDef.components\n        ) {\n            const innerTypes = typeDef.components.map((innerType) => {\n                return buildFullTypeDefinition(innerType);\n            });\n            return `tuple(${innerTypes.join(',')})${extractSize(typeDef.type)}`;\n        }\n\n        if (/trcToken/.test(typeDef.type))\n            return typeDef.type.replace(/trcToken/, 'uint256');\n\n        return typeDef.type;\n    };\n\n    const convertTypes = (types) => {\n        for (let i = 0; i < types.length; i++) {\n            const type = types[i];\n            if (/trcToken/.test(type))\n                types[i] = type.replace(/trcToken/, 'uint256');\n        }\n    };\n\n    const convertAddresses = (addrArr) => {\n        if (Array.isArray(addrArr)) {\n            addrArr.forEach((addrs, i) => {\n                addrArr[i] = convertAddresses(addrs);\n            });\n            return addrArr;\n        } else {\n            return _addressToHex(addrArr);\n        }\n    };\n\n    const mapTuple = (components, args, dimension) => {\n        if (dimension > 1) {\n            if (args.length)\n                args.forEach((arg) => {\n                    mapTuple(components, arg, dimension - 1);\n                });\n        } else {\n            if (args.length && dimension)\n                args.forEach((arg) => {\n                    encodeArgs(components, arg);\n                });\n        }\n    };\n\n    const encodeArgs = (inputs: IFieldABI[] = [], args: any[]) => {\n        if (inputs.length)\n            inputs.forEach((input, i) => {\n                const type = input.type;\n\n                if (args[i])\n                    if (type === 'address') args[i] = _addressToHex(args[i]);\n                    else if (\n                        type.match(/^([^\\x5b]*)(\\x5b|$)/)![0] === 'address['\n                    )\n                        convertAddresses(args[i]);\n                    else if (type.indexOf('tuple') === 0)\n                        if (extractSize(type)) {\n                            const dimension = extractArrayDim(type);\n                            mapTuple(input.components, args[i], dimension);\n                        } else {\n                            encodeArgs(input.components, args[i]);\n                        }\n            });\n    };\n\n    if (funABI.inputs && funABI.inputs.length)\n        for (let i = 0; i < funABI.inputs.length; i++) {\n            const type = funABI.inputs[i].type;\n            // \"false\" will be converting to `false` and \"true\" will be working\n            // fine as abiCoder assume anything in quotes as `true`\n            if (type === 'bool' && args[i] === 'false') args[i] = false;\n\n            types.push(\n                type.indexOf('tuple') === 0\n                    ? buildFullTypeDefinition(funABI.inputs[i])\n                    : type,\n            );\n            if (args.length < types.length) args.push('');\n        }\n\n    encodeArgs(funABI.inputs, args);\n    convertTypes(types);\n\n    return abiCoder.encode(types, args);\n}\n\nexport function decodeParamsV2ByABI(funABI: IFunABI, data) {\n    const convertTypeNames = (types) => {\n        for (let i = 0; i < types.length; i++) {\n            const type = types[i];\n            if (/^trcToken/.test(type))\n                types[i] = type.replace(/^trcToken/, 'uint256');\n        }\n    };\n\n    const convertAddresses = (addrArr) => {\n        if (Array.isArray(addrArr)) {\n            addrArr.forEach((addrs, i) => {\n                addrArr[i] = convertAddresses(addrs);\n            });\n            return addrArr;\n        } else {\n            return TronWeb.address.toHex(addrArr);\n        }\n    };\n\n    const mapTuple = (components, args, dimension) => {\n        if (dimension > 1) {\n            if (args.length)\n                args.forEach((arg) => {\n                    mapTuple(components, arg, dimension - 1);\n                });\n        } else {\n            if (args.length && dimension)\n                args.forEach((arg) => {\n                    decodeResult(components, arg);\n                });\n        }\n    };\n\n    const buildFullTypeNameDefinition = (typeDef) => {\n        const name = typeDef.name ? ` ${typeDef.name}` : '';\n        if (\n            typeDef &&\n            typeDef.type.indexOf('tuple') === 0 &&\n            typeDef.components\n        ) {\n            const innerTypes = typeDef.components.map((innerType) => {\n                return buildFullTypeNameDefinition(innerType);\n            });\n            return `tuple(${innerTypes.join(',')})${extractSize(\n                typeDef.type,\n            )}${name}`;\n        }\n        if (/trcToken/.test(typeDef.type))\n            return typeDef.type.replace(/trcToken/, 'uint256') + name;\n\n        return typeDef.type + name;\n    };\n\n    const decodeResult = (\n        outputs: IFieldABI[] = [],\n        result: {[key: number | string]: any},\n    ) => {\n        if (outputs.length)\n            outputs.forEach((output, i) => {\n                const {type, name} = output;\n\n                if (result[i])\n                    if (type === 'address') {\n                        result[i] = TronWeb.address.toHex(result[i]);\n                        if (name)\n                            result[name] = TronWeb.address.toHex(result[name]);\n                    } else if (\n                        type.match(/^([^\\x5b]*)(\\x5b|$)/)![0] === 'address['\n                    ) {\n                        convertAddresses(result[i]);\n                        if (name) convertAddresses(result[name]);\n                    } else if (type.indexOf('tuple') === 0) {\n                        if (extractSize(type)) {\n                            const dimension = extractArrayDim(type);\n                            mapTuple(output.components, result[i], dimension);\n                        } else {\n                            decodeResult(output.components, result[i]);\n                        }\n\n                        if (name) result[name] = result[i];\n                    }\n            });\n    };\n\n    // Only decode if there supposed to be fields\n    if (funABI.outputs && funABI.outputs.length > 0) {\n        const outputTypes: string[] = [];\n        for (let i = 0; i < funABI.outputs.length; i++) {\n            const type = funABI.outputs[i].type;\n            const name = funABI.outputs[i].name\n                ? ` ${funABI.outputs[i].name}`\n                : '';\n            outputTypes.push(\n                type.indexOf('tuple') === 0\n                    ? buildFullTypeNameDefinition(funABI.outputs[i])\n                    : type + name,\n            );\n        }\n        convertTypeNames(outputTypes);\n\n        // ensure the data is at least filled by 0\n        // cause `AbiCoder` throws if there's not enough data\n        if (!data || !data.length)\n            data = new Uint8Array(32 * funABI.outputs.length);\n        // decode data\n        const decodeRes = abiCoder.decode(outputTypes, data);\n        const decodeResCopy = deepCopy(decodeRes);\n        decodeResult(funABI.outputs, decodeResCopy);\n\n        return decodeResCopy;\n    }\n    return [];\n}\n","import type {SomeBytes} from './bytes';\n\n// FIXME: verify that it works after conversion\n// May need static modifiers\n\nexport class Base64 {\n    private _keyStr =\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n    encode(input: string): string {\n        let output = '';\n        let chr1;\n        let chr2;\n        let chr3;\n        let enc1;\n        let enc2;\n        let enc3;\n        let enc4;\n        let i = 0;\n\n        while (i < input.length) {\n            chr1 = input.charCodeAt(i++);\n            chr2 = input.charCodeAt(i++);\n            chr3 = input.charCodeAt(i++);\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) enc3 = enc4 = 64;\n            else if (isNaN(chr3)) enc4 = 64;\n\n            output +=\n                this._keyStr.charAt(enc1) +\n                this._keyStr.charAt(enc2) +\n                this._keyStr.charAt(enc3) +\n                this._keyStr.charAt(enc4);\n        }\n\n        return output;\n    }\n\n    encodeIgnoreUtf8(inputBytes: SomeBytes): string {\n        let output = '';\n        let chr1;\n        let chr2;\n        let chr3;\n        let enc1;\n        let enc2;\n        let enc3;\n        let enc4;\n        let i = 0;\n\n        while (i < inputBytes.length) {\n            chr1 = inputBytes[i++];\n            chr2 = inputBytes[i++];\n            chr3 = inputBytes[i++];\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) enc3 = enc4 = 64;\n            else if (isNaN(chr3)) enc4 = 64;\n\n            output =\n                output +\n                this._keyStr.charAt(enc1) +\n                this._keyStr.charAt(enc2) +\n                this._keyStr.charAt(enc3) +\n                this._keyStr.charAt(enc4);\n        }\n\n        return output;\n    }\n\n    decode(input: string): string {\n        let output = '';\n        let chr1;\n        let chr2;\n        let chr3;\n        let enc1;\n        let enc2;\n        let enc3;\n        let enc4;\n        let i = 0;\n\n        input = input.replace(/[^A-Za-z0-9+/=]/g, '');\n\n        while (i < input.length) {\n            enc1 = this._keyStr.indexOf(input.charAt(i++));\n            enc2 = this._keyStr.indexOf(input.charAt(i++));\n            enc3 = this._keyStr.indexOf(input.charAt(i++));\n            enc4 = this._keyStr.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            output = output + String.fromCharCode(chr1);\n\n            if (enc3 !== 64) output = output + String.fromCharCode(chr2);\n\n            if (enc4 !== 64) output = output + String.fromCharCode(chr3);\n        }\n\n        return this._utf8_decode(output);\n    }\n\n    decodeToByteArray(input: string): Uint8Array {\n        let output = '';\n        let chr1;\n        let chr2;\n        let chr3;\n        let enc1;\n        let enc2;\n        let enc3;\n        let enc4;\n        let i = 0;\n\n        input = input.replace(/[^A-Za-z0-9+/=]/g, '');\n\n        while (i < input.length) {\n            enc1 = this._keyStr.indexOf(input.charAt(i++));\n            enc2 = this._keyStr.indexOf(input.charAt(i++));\n            enc3 = this._keyStr.indexOf(input.charAt(i++));\n            enc4 = this._keyStr.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            output = output + String.fromCharCode(chr1);\n\n            if (enc3 !== 64) output = output + String.fromCharCode(chr2);\n\n            if (enc4 !== 64) output = output + String.fromCharCode(chr3);\n        }\n\n        return this._out2ByteArray(output);\n    }\n\n    private _out2ByteArray(utftext: string): Uint8Array {\n        const byteArray = new Uint8Array(utftext.length);\n        for (let i = 0; i < utftext.length; i++)\n            byteArray[i] = utftext.charCodeAt(i);\n\n        return byteArray;\n    }\n\n    private _utf8_encode(string: string): string {\n        string = string.replace(/\\r\\n/g, '\\n');\n        let utftext = '';\n\n        for (let n = 0; n < string.length; n++) {\n            const c = string.charCodeAt(n);\n\n            if (c < 128) {\n                utftext += String.fromCharCode(c);\n            } else if (c > 127 && c < 2048) {\n                utftext += String.fromCharCode((c >> 6) | 192);\n                utftext += String.fromCharCode((c & 63) | 128);\n            } else {\n                utftext += String.fromCharCode((c >> 12) | 224);\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n        }\n\n        return utftext;\n    }\n\n    private _utf8_decode(utftext: string): string {\n        let string = '';\n        let i = 0;\n        let c = 0;\n        let c2 = 0;\n        let c3 = 0;\n\n        while (i < utftext.length) {\n            c = utftext.charCodeAt(i);\n\n            if (c < 128) {\n                string += String.fromCharCode(c);\n                i++;\n            } else if (c > 191 && c < 224) {\n                c2 = utftext.charCodeAt(i + 1);\n                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n                i += 2;\n            } else {\n                c2 = utftext.charCodeAt(i + 1);\n                c3 = utftext.charCodeAt(i + 2);\n\n                string += String.fromCharCode(\n                    ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63),\n                );\n\n                i += 3;\n            }\n        }\n\n        return string;\n    }\n}\n","import {Base64} from './base64';\n\nexport type SomeBytes = Uint8Array | Buffer | number[];\n\nexport function byte2hexStr(byte: number) {\n    if (typeof byte !== 'number') throw new Error('Input must be a number');\n    if (byte < 0 || byte > 255) throw new Error('Input must be a byte');\n\n    const hexByteMap = '0123456789ABCDEF';\n    return hexByteMap.charAt(byte >> 4) + hexByteMap.charAt(byte & 0x0f);\n}\n\nexport function bytesToString(arr: SomeBytes | string) {\n    if (typeof arr === 'string') return arr;\n\n    let str = '';\n\n    for (let i = 0; i < arr.length; i++) {\n        const one = arr[i].toString(2);\n        const v = one.match(/^1+?(?=0)/);\n\n        if (v && one.length === 8) {\n            const bytesLength = v[0].length;\n            let store = arr[i].toString(2).slice(7 - bytesLength);\n\n            for (let st = 1; st < bytesLength; st++)\n                store += arr[st + i].toString(2).slice(2);\n\n            str += String.fromCharCode(parseInt(store, 2));\n            i += bytesLength - 1;\n        } else {\n            str += String.fromCharCode(arr[i]);\n        }\n    }\n\n    return str;\n}\n\nexport function hextoString(hex: string) {\n    const arr = hex.replace(/^0x/, '').split('');\n    let out = '';\n\n    for (let i = 0; i < arr.length / 2; i++) {\n        const tmp = `0x${arr[i * 2]}${arr[i * 2 + 1]}`;\n        out += String.fromCharCode(parseInt(tmp, 16));\n    }\n\n    return out;\n}\n\nexport function byteArray2hexStr(byteArray: SomeBytes) {\n    let str = '';\n\n    for (const b of byteArray) str += byte2hexStr(b);\n\n    return str;\n}\n\nexport function base64DecodeFromString(string64: string) {\n    return new Base64().decodeToByteArray(string64);\n}\n\nexport function base64EncodeToString(bytes: SomeBytes) {\n    const b = new Base64();\n    return b.encodeIgnoreUtf8(bytes);\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/toConsumableArray\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"elliptic\");","const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nconst ALPHABET_MAP = {};\n\nfor (let i = 0; i < ALPHABET.length; i++) ALPHABET_MAP[ALPHABET.charAt(i)] = i;\n\nconst BASE = 58;\n\nexport function encode58(buffer: Buffer | Uint8Array | string) {\n    if (buffer.length === 0) return '';\n\n    let i, j;\n    // Lines below [ab]use implicit string/number conversion\n    // In fact it is `(string | number)[]`\n    const digits: any[] = [0];\n\n    for (i = 0; i < buffer.length; i++) {\n        for (j = 0; j < digits.length; j++) digits[j] <<= 8;\n\n        digits[0] += buffer[i];\n        let carry = 0;\n\n        for (j = 0; j < digits.length; ++j) {\n            digits[j] += carry;\n            carry = (digits[j] / BASE) | 0;\n            digits[j] %= BASE;\n        }\n        // Now digits is number[] strictly\n\n        while (carry) {\n            digits.push(carry % BASE);\n            carry = (carry / BASE) | 0;\n        }\n    }\n\n    for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) digits.push(0);\n\n    return digits\n        .reverse()\n        .map((digit) => ALPHABET[digit])\n        .join('');\n}\n\nexport function decode58(string: string): Uint8Array {\n    if (string.length === 0) return new Uint8Array();\n\n    let i, j;\n    const bytes = [0];\n\n    for (i = 0; i < string.length; i++) {\n        const c = string[i];\n\n        if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character');\n\n        for (j = 0; j < bytes.length; j++) bytes[j] *= BASE;\n\n        bytes[0] += ALPHABET_MAP[c];\n        let carry = 0;\n\n        for (j = 0; j < bytes.length; ++j) {\n            bytes[j] += carry;\n            carry = bytes[j] >> 8;\n            bytes[j] &= 0xff;\n        }\n\n        while (carry) {\n            bytes.push(carry & 0xff);\n            carry >>= 8;\n        }\n    }\n\n    for (i = 0; string[i] === '1' && i < string.length - 1; i++) bytes.push(0);\n\n    return new Uint8Array(bytes.reverse());\n}\n","import {\n    base64DecodeFromString,\n    base64EncodeToString,\n    byte2hexStr,\n    byteArray2hexStr,\n    bytesToString,\n    hextoString,\n} from './bytes';\n\nexport const bin2String = bytesToString;\n\nexport function arrayEquals(\n    array1: {length: number; [key: number]: unknown},\n    array2: {length: number; [key: number]: unknown},\n    strict = false,\n): boolean {\n    if (array1.length !== array2.length) return false;\n\n    let i;\n\n    for (i = 0; i < array1.length; i++)\n        if (strict) {\n            if (array1[i] !== array2[i]) return false;\n        } else if (JSON.stringify(array1[i]) !== JSON.stringify(array2[i])) {\n            return false;\n        }\n\n    return true;\n}\n\nexport function stringToBytes(str: string): Uint8Array {\n    if (typeof str !== 'string')\n        throw new Error('The passed string is not a string');\n\n    const bytes: number[] = [];\n    const len = str.length;\n    let c;\n\n    for (let i = 0; i < len; i++) {\n        c = str.charCodeAt(i);\n\n        if (c >= 0x010000 && c <= 0x10ffff) {\n            bytes.push(((c >> 18) & 0x07) | 0xf0);\n            bytes.push(((c >> 12) & 0x3f) | 0x80);\n            bytes.push(((c >> 6) & 0x3f) | 0x80);\n            bytes.push((c & 0x3f) | 0x80);\n        } else if (c >= 0x000800 && c <= 0x00ffff) {\n            bytes.push(((c >> 12) & 0x0f) | 0xe0);\n            bytes.push(((c >> 6) & 0x3f) | 0x80);\n            bytes.push((c & 0x3f) | 0x80);\n        } else if (c >= 0x000080 && c <= 0x0007ff) {\n            bytes.push(((c >> 6) & 0x1f) | 0xc0);\n            bytes.push((c & 0x3f) | 0x80);\n        } else {\n            bytes.push(c & 0xff);\n        }\n    }\n\n    return new Uint8Array(bytes);\n}\n\nexport {\n    byte2hexStr,\n    bytesToString,\n    hextoString,\n    byteArray2hexStr,\n    base64DecodeFromString,\n    base64EncodeToString,\n};\n\nexport function hexChar2byte(c: string): number {\n    let d;\n\n    if (c >= 'A' && c <= 'F') d = c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;\n    else if (c >= 'a' && c <= 'f') d = c.charCodeAt(0) - 'a'.charCodeAt(0) + 10;\n    else if (c >= '0' && c <= '9') d = c.charCodeAt(0) - '0'.charCodeAt(0);\n\n    if (typeof d === 'number') return d;\n    else throw new Error('The passed hex char is not a valid hex char');\n}\n\nexport function isHexChar(c: string) {\n    return (\n        (c >= 'A' && c <= 'F') ||\n        (c >= 'a' && c <= 'f') ||\n        (c >= '0' && c <= '9')\n    );\n}\n\n/**\n * Convert a hex string to a byte array.\n * @param strict: if strict and the length of str is odd, pad it left with one zero\n */\nexport function hexStr2byteArray(str: string, strict = false) {\n    if (typeof str !== 'string')\n        throw new Error('The passed string is not a string');\n\n    if (strict && str.length % 2) str = `0${str}`;\n\n    const byteArray = new Uint8Array(str.length / 2);\n    let d = 0;\n    let j = 0;\n    let k = 0;\n\n    for (const c of str)\n        if (isHexChar(c)) {\n            d <<= 4;\n            d += hexChar2byte(c);\n            j++;\n\n            if (j % 2 === 0) {\n                byteArray[k++] = d;\n                d = 0;\n            }\n        } else {\n            throw new Error('The passed hex char is not a valid hex string');\n        }\n\n    return byteArray;\n}\n\n/**\n * Convert string of form `yyyy-MM-DD HH-mm-ss` to `Date`\n */\nexport function strToDate(str: string) {\n    if (!/^\\d{4}-\\d{2}-\\d{2}( \\d{2}-\\d{2}-\\d{2}|)/.test(str))\n        throw new Error('The passed date string is not valid');\n\n    const tempStrs = str.split(' ');\n    const dateStrs = tempStrs[0].split('-');\n    const year = parseInt(dateStrs[0], 10);\n    const month = parseInt(dateStrs[1], 10) - 1;\n    const day = parseInt(dateStrs[2], 10);\n\n    if (tempStrs.length > 1) {\n        const timeStrs = tempStrs[1].split('-');\n        const hour = parseInt(timeStrs[0], 10);\n        const minute = parseInt(timeStrs[1], 10);\n        const second = parseInt(timeStrs[2], 10);\n\n        return new Date(year, month, day, hour, minute, second);\n    }\n\n    return new Date(year, month, day);\n}\n\nexport function isNumber(c: string | number): boolean {\n    return c >= '0' && c <= '9';\n}\n\n/**\n * return 1: address  --- 20Bytes HexString\n * return 2: blockNumber ------ Decimal number\n * return 3: assetName ------ String\n * return other: error\n */\nexport function getStringType(str: string): 1 | 2 | 3 | -1 {\n    if (null == str) return -1;\n\n    if (typeof str != 'string') return -1;\n\n    if (!str || str.length === 0 || str === '') return -1;\n\n    let i = 0;\n\n    // TODO Should we return 1 if someone passes a full, 42-chars long address?\n    // if (str.length == 42 && /^41/.test(str)) {\n    //     for (; i < 40; i++) {\n    //         var c = str.charAt(i+2);\n    //\n    //         if (!isHexChar(c))\n    //             break;\n    //     }\n    // } else\n    if (str.length === 40)\n        for (; i < 40; i++) if (!isHexChar(str.charAt(i))) break;\n\n    if (i === 40) return 1; //40 Hex, Address\n\n    for (i = 0; i < str.length; i++) if (!isNumber(str.charAt(i))) break;\n\n    if (i === str.length) return 2; // All Decimal number, BlockNumber\n\n    // At least one visible character\n    for (i = 0; i < str.length; i++) if (str.charAt(i) > ' ') return 3;\n\n    return -1;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/bignumber\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/bytes\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/keccak256\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/logger\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/properties\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/strings\");","import {BigNumber} from '@ethersproject/bignumber';\nimport {arrayify, hexConcat, hexZeroPad, hexlify} from '@ethersproject/bytes';\nimport {keccak256} from '@ethersproject/keccak256';\nimport {Logger} from '@ethersproject/logger';\nimport {deepCopy, defineReadOnly, shallowCopy} from '@ethersproject/properties';\nimport {toUtf8Bytes} from '@ethersproject/strings';\n\nimport TronWeb from '..';\nimport {ADDRESS_PREFIX_REGEX} from './address';\nimport type {SomeBytes} from './bytes';\n\nconst version = 'tronweb/hash/5.4.0';\nconst logger = new Logger(version);\n\nfunction getAddress(address: string) {\n    return TronWeb.address.toHex(address).replace(ADDRESS_PREFIX_REGEX, '0x');\n}\n\nfunction getTronAddress(address: string) {\n    return TronWeb.address.toHex(address);\n}\n\nfunction id(text: string) {\n    return keccak256(toUtf8Bytes(text));\n}\n\nexport interface IField {\n    name: string;\n    type: string;\n}\nexport interface IDomain {\n    name: string;\n    version: string;\n    chainId: string;\n    verifyingContract: string;\n}\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\n    '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n);\n\nfunction hexPadRight(value: string) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) return hexConcat([bytes, padding.slice(padOffset)]);\n\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: 'string',\n    version: 'string',\n    chainId: 'uint256',\n    verifyingContract: 'address',\n    salt: 'bytes32',\n};\nconst domainFieldNames = [\n    'name',\n    'version',\n    'chainId',\n    'verifyingContract',\n    'salt',\n];\n\nfunction checkString(key: string) {\n    return function <T>(value: T): T extends string ? T : never {\n        if (typeof value !== 'string')\n            logger.throwArgumentError(\n                `invalid domain value for ${JSON.stringify(key)}`,\n                `domain.${key}`,\n                value,\n            );\n\n        return value as any;\n    };\n}\n\nconst domainChecks = {\n    name: checkString('name'),\n    version: checkString('version'),\n    chainId: function (value: unknown) {\n        try {\n            return BigNumber.from(value).toString();\n        } catch (error) {}\n        return logger.throwArgumentError(\n            'invalid domain value for \"chainId\"',\n            'domain.chainId',\n            value,\n        );\n    },\n    verifyingContract: function (value: string) {\n        try {\n            return getTronAddress(value).toLowerCase();\n        } catch (error) {}\n        return logger.throwArgumentError(\n            'invalid domain value \"verifyingContract\"',\n            'domain.verifyingContract',\n            value,\n        );\n    },\n    salt: function (value: string | number | SomeBytes) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) throw new Error('bad length');\n\n            return hexlify(bytes);\n        } catch (error) {}\n        return logger.throwArgumentError(\n            'invalid domain value \"salt\"',\n            'domain.salt',\n            value,\n        );\n    },\n};\n\nfunction getBaseEncoder(type: string): ((value: any) => string) | null {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = match[1] === '';\n            const width = parseInt(match[2] || '256');\n            if (\n                width % 8 !== 0 ||\n                width > 256 ||\n                (match[2] && match[2] !== String(width))\n            )\n                logger.throwArgumentError(\n                    'invalid numeric width',\n                    'type',\n                    type,\n                );\n\n            const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n            const boundsLower = signed\n                ? boundsUpper.add(One).mul(NegativeOne)\n                : Zero;\n            return function (value) {\n                const v = BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper))\n                    logger.throwArgumentError(\n                        `value out-of-bounds for ${type}`,\n                        'value',\n                        value,\n                    );\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width))\n                logger.throwArgumentError('invalid bytes width', 'type', type);\n\n            return function (value) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width)\n                    logger.throwArgumentError(\n                        `invalid length for ${type}`,\n                        'value',\n                        value,\n                    );\n\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case 'trcToken':\n            return getBaseEncoder('uint256');\n        case 'address':\n            return function (value) {\n                return hexZeroPad(getAddress(value), 32);\n            };\n        case 'bool':\n            return function (value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case 'bytes':\n            return function (value) {\n                return keccak256(value);\n            };\n        case 'string':\n            return function (value) {\n                return id(value);\n            };\n    }\n    return null;\n}\n\nfunction encodeType(name: string, fields: IField[]) {\n    return `${name}(${fields\n        .map(({name, type}) => type + ' ' + name)\n        .join(',')})`;\n}\n\nexport class TypedDataEncoder {\n    readonly types!: Record<string, IField[]>;\n    readonly primaryType!: string;\n    readonly _types!: Record<string, string>;\n    readonly _encoderCache!: Record<string, (__v: unknown) => string>;\n\n    constructor(types: Record<string, IField[]>) {\n        defineReadOnly(this, 'types', Object.freeze(deepCopy(types)));\n        defineReadOnly(this, '_encoderCache', {});\n        defineReadOnly(this, '_types', {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name])\n                    logger.throwArgumentError(\n                        `duplicate variable name ${JSON.stringify(\n                            field.name,\n                        )} in ${JSON.stringify(name)}`,\n                        'types',\n                        types,\n                    );\n\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)![1];\n                if (baseType === name)\n                    logger.throwArgumentError(\n                        `circular type reference to ${JSON.stringify(\n                            baseType,\n                        )}`,\n                        'types',\n                        types,\n                    );\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) return;\n\n                if (!parents[baseType])\n                    logger.throwArgumentError(\n                        `unknown type ${JSON.stringify(baseType)}`,\n                        'types',\n                        types,\n                    );\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter(\n            (n) => parents[n].length === 0,\n        );\n        if (primaryTypes.length === 0)\n            logger.throwArgumentError('missing primary type', 'types', types);\n        else if (primaryTypes.length > 1)\n            logger.throwArgumentError(\n                `ambiguous primary types or unused types: ${primaryTypes\n                    .map((t) => JSON.stringify(t))\n                    .join(', ')}`,\n                'types',\n                types,\n            );\n\n        defineReadOnly(this, 'primaryType', primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type])\n                logger.throwArgumentError(\n                    `circular type reference to ${JSON.stringify(type)}`,\n                    'types',\n                    types,\n                );\n\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) return;\n\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] =\n                encodeType(name, types[name]) +\n                st.map((t) => encodeType(t, types[t])).join('');\n        }\n    }\n    getEncoder(type: string) {\n        let encoder = this._encoderCache[type];\n        if (!encoder)\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n\n        return encoder;\n    }\n    private _getEncoder(type: string) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) return encoder;\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length)\n                    logger.throwArgumentError(\n                        'array length mismatch; expected length ${ arrayLength }',\n                        'value',\n                        value,\n                    );\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) result = result.map(keccak256);\n\n                return keccak256(hexConcat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value) => {\n                const values = fields.map(({name, type}) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) return keccak256(result);\n\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, 'type', type);\n    }\n    encodeType(name: string) {\n        const result = this._types[name];\n        if (!result)\n            logger.throwArgumentError(\n                `unknown type: ${JSON.stringify(name)}`,\n                'name',\n                name,\n            );\n\n        return result;\n    }\n    encodeData(type: string, value: unknown) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name: string, value: unknown) {\n        return keccak256(this.encodeData(name, value));\n    }\n    encode(value: unknown) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value: unknown) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    private _visit(\n        type: string,\n        value: unknown,\n        callback: (type: string, value: unknown) => any,\n    ): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) return callback(type, value);\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (\n                !Array.isArray(value) ||\n                (length >= 0 && value.length !== length)\n            )\n                logger.throwArgumentError(\n                    'array length mismatch; expected length ${ arrayLength }',\n                    'value',\n                    value,\n                );\n\n            if (Array.isArray(value))\n                return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields)\n            return fields.reduce((accum, {name, type}) => {\n                accum[name] = this._visit(type, value![name], callback);\n                return accum;\n            }, {});\n\n        return logger.throwArgumentError(`unknown type: ${type}`, 'type', type);\n    }\n    visit(value: unknown, callback: (type: string, value: unknown) => any) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types: Record<string, IField[]>) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types: Record<string, IField[]>) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(\n        name: string,\n        types: Record<string, IField[]>,\n        value: unknown,\n    ) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain: IDomain) {\n        const domainFields: IField[] = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type)\n                logger.throwArgumentError(\n                    `invalid typed-data domain key: ${JSON.stringify(name)}`,\n                    'domain',\n                    domain,\n                );\n\n            domainFields.push({name, type});\n        }\n        domainFields.sort((a, b) => {\n            return (\n                domainFieldNames.indexOf(a.name) -\n                domainFieldNames.indexOf(b.name)\n            );\n        });\n        return TypedDataEncoder.hashStruct(\n            'EIP712Domain',\n            {EIP712Domain: domainFields},\n            domain,\n        );\n    }\n    static encode(\n        domain: IDomain,\n        types: Record<string, IField[]>,\n        value: unknown,\n    ) {\n        return hexConcat([\n            '0x1901',\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value),\n        ]);\n    }\n    static hash(\n        domain: IDomain,\n        types: Record<string, IField[]>,\n        value: unknown,\n    ) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    static getPayload(\n        domain: IDomain,\n        types: Record<string, IField[]>,\n        value: unknown,\n    ) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: {[key: string]: any} = {};\n        const domainTypes: IField[] = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) return;\n\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({name, type: domainFieldTypes[name]});\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain)\n            logger.throwArgumentError(\n                'types must not contain EIP712Domain type',\n                'types.EIP712Domain',\n                types,\n            );\n        else typesWithDomain.EIP712Domain = domainTypes;\n\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/))\n                    return hexlify(arrayify(value as string));\n\n                // uint or int\n                if (type.match(/^u?int/))\n                    return BigNumber.from(value).toString();\n\n                switch (type) {\n                    case 'trcToken':\n                        return BigNumber.from(value).toString();\n                    case 'address':\n                        return getTronAddress(value as string).toLowerCase();\n                    case 'bool':\n                        return !!value;\n                    case 'string':\n                        if (typeof value !== 'string')\n                            logger.throwArgumentError(\n                                'invalid string',\n                                'value',\n                                value,\n                            );\n\n                        return value;\n                }\n                return logger.throwArgumentError(\n                    'unsupported type',\n                    'type',\n                    type,\n                );\n            }),\n        };\n    }\n}\n","import el from 'elliptic';\n\nimport type {ISignedTransaction, ITransaction} from '../lib/transactionBuilder';\nimport {ADDRESS_PREFIX, ADDRESS_PREFIX_BYTE, ADDRESS_SIZE} from './address';\nimport {decode58, encode58} from './base58';\nimport {byte2hexStr, byteArray2hexStr} from './bytes';\nimport type {SomeBytes} from './bytes';\nimport {\n    base64DecodeFromString,\n    base64EncodeToString,\n    hexStr2byteArray,\n} from './code';\nimport {SigningKey, sha256 as ethSha256, keccak256} from './ethersUtils';\nimport {TypedDataEncoder} from './typedData';\nimport type {IDomain} from './typedData';\n\nconst {ec: EC} = el;\n\n// import {TransactionExtention as ITransactionExtention} from '../proto/api/api'\n\nexport {byteArray2hexStr} from './bytes';\n\nexport type TypedDataTypes = Record<string, {name: string; type: string}[]>;\n\nexport function getBase58CheckAddress(\n    addressBytes: SomeBytes | Buffer | number[],\n) {\n    const hash = sha256(sha256(addressBytes));\n    let checkSum = hash.slice(0, 4);\n    checkSum = new Uint8Array([...addressBytes, ...checkSum]);\n\n    return encode58(checkSum);\n}\n\nexport function decodeBase58Address(base58String: string) {\n    const error_msg = 'Invalid address provided';\n\n    if (typeof base58String !== 'string' || base58String.length <= 4)\n        throw new Error(error_msg);\n\n    let address = decode58(base58String);\n\n    if (base58String.length <= 4) throw new Error(error_msg);\n\n    const checkSum = address.slice(-4);\n\n    address = address.slice(0, -4);\n\n    const hash = sha256(sha256(address));\n    const checkSum1 = hash.slice(0, 4);\n\n    if (checkSum.join() === checkSum1.join()) return address;\n\n    throw new Error(error_msg);\n}\n\nexport function signTransaction(\n    priKeyBytes: string | SomeBytes,\n    transaction: ITransaction,\n): ISignedTransaction {\n    if (typeof priKeyBytes === 'string')\n        priKeyBytes = hexStr2byteArray(priKeyBytes);\n\n    const txID = transaction.txID;\n    const signature = getECKeySig(hexStr2byteArray(txID), priKeyBytes);\n\n    if (Array.isArray(transaction.signature)) {\n        if (!transaction.signature.includes(signature))\n            transaction.signature.push(signature);\n    } else {\n        transaction.signature = [signature];\n    }\n    return transaction as ISignedTransaction;\n}\n\nexport function arrayToBase64String(a: SomeBytes) {\n    return btoa(String.fromCharCode(...a));\n}\n\nexport function signBytes(privateKey: string | SomeBytes, contents: SomeBytes) {\n    if (typeof privateKey === 'string')\n        privateKey = hexStr2byteArray(privateKey);\n\n    const hashBytes = sha256(contents);\n    return getECKeySig(hashBytes, privateKey);\n}\n\nexport function _signTypedData(\n    domain: IDomain,\n    types: TypedDataTypes,\n    value: Record<string, unknown>,\n    privateKey: string,\n) {\n    const key = {\n        toHexString: function () {\n            return '0x' + privateKey;\n        },\n        value: privateKey,\n    };\n    const signingKey = new SigningKey(key);\n\n    const messageDigest = TypedDataEncoder.hash(domain, types, value);\n    const signature = signingKey.signDigest(messageDigest);\n    return [\n        '0x',\n        signature.r.substring(2),\n        signature.s.substring(2),\n        Number(signature.v).toString(16),\n    ].join('');\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function getRowBytesFromTransactionBase64(base64Data: string) {\n    throw new Error('Sorry, this function is not supported.');\n    // TODO: what the hell is it? Is it needed? Current impl does not work.\n    // const bytesDecode = base64DecodeFromString(base64Data);\n    // const transaction =\n    //     proto.protocol.Transaction.deserializeBinary(bytesDecode);\n    // const raw = transaction.getRawData();\n\n    // return raw.serializeBinary();\n}\n\nexport function genPriKey() {\n    const ec = new EC('secp256k1');\n    const key = ec.genKeyPair();\n    const priKey = key.getPrivate();\n\n    let priKeyHex = priKey.toString('hex');\n\n    while (priKeyHex.length < 64) priKeyHex = `0${priKeyHex}`;\n\n    return hexStr2byteArray(priKeyHex);\n}\n\nexport function computeAddress(pubBytes: SomeBytes) {\n    if (pubBytes.length === 65) pubBytes = pubBytes.slice(1);\n\n    const hash = keccak256(pubBytes).toString().substring(2);\n    const addressHex = ADDRESS_PREFIX + hash.substring(24);\n\n    return hexStr2byteArray(addressHex);\n}\n\nexport function getAddressFromPriKey(priKeyBytes: SomeBytes) {\n    const pubBytes = getPubKeyFromPriKey(priKeyBytes);\n    return computeAddress(pubBytes);\n}\n\nexport function decode58Check(addressStr: string) {\n    const decodeCheck = decode58(addressStr);\n\n    if (decodeCheck.length <= 4) return null;\n    const checkSum = decodeCheck.slice(-4);\n\n    const decodeData = decodeCheck.slice(0, decodeCheck.length - 4);\n    const hash = sha256(sha256(decodeData));\n\n    if (hash.slice(0, 4).join() === checkSum.join()) return decodeData;\n\n    return null;\n}\n\nexport function isAddressValid(base58Str: string) {\n    if (typeof base58Str !== 'string') return false;\n\n    if (base58Str.length !== ADDRESS_SIZE) return false;\n\n    let address = decode58(base58Str);\n\n    if (address.length !== 25) return false;\n\n    if (address[0] !== ADDRESS_PREFIX_BYTE) return false;\n\n    const checkSum = address.slice(21);\n    address = address.slice(0, 21);\n\n    const checkSum1 = sha256(sha256(address)).slice(0, 4);\n    return checkSum.join() === checkSum1.join();\n}\n\nexport function getBase58CheckAddressFromPriKeyBase64String(\n    priKeyBase64String: string,\n) {\n    const priKeyBytes = base64DecodeFromString(priKeyBase64String);\n    const pubBytes = getPubKeyFromPriKey(priKeyBytes);\n    const addressBytes = computeAddress(pubBytes);\n\n    return getBase58CheckAddress(addressBytes);\n}\n\nexport function getHexStrAddressFromPriKeyBase64String(\n    priKeyBase64String: string,\n) {\n    const priKeyBytes = base64DecodeFromString(priKeyBase64String);\n    const pubBytes = getPubKeyFromPriKey(priKeyBytes);\n    const addressBytes = computeAddress(pubBytes);\n    return byteArray2hexStr(addressBytes);\n}\n\nexport function getAddressFromPriKeyBase64String(priKeyBase64String: string) {\n    const priKeyBytes = base64DecodeFromString(priKeyBase64String);\n    const pubBytes = getPubKeyFromPriKey(priKeyBytes);\n    const addressBytes = computeAddress(pubBytes);\n    return base64EncodeToString(addressBytes);\n}\n\nexport function getPubKeyFromPriKey(priKeyBytes: SomeBytes) {\n    const ec = new EC('secp256k1');\n    const key = ec.keyFromPrivate(priKeyBytes, 'bytes');\n    const pubkey = key.getPublic();\n\n    const xHex = pubkey.x.toString('hex').padStart(64, '0');\n    const yHex = pubkey.y.toString('hex').padStart(64, '0');\n\n    const pubkeyHex = `04${xHex}${yHex}`;\n    return hexStr2byteArray(pubkeyHex);\n}\n\nexport function getECKeySig(hashBytes: SomeBytes, priKeyBytes: SomeBytes) {\n    const ec = new EC('secp256k1');\n    const key = ec.keyFromPrivate(priKeyBytes, 'bytes');\n    const signature = key.sign(hashBytes);\n\n    const rHex = signature.r.toString('hex').padStart(64, '0');\n    const sHex = signature.s.toString('hex').padStart(64, '0');\n    const idHex = byte2hexStr(signature.recoveryParam);\n    return rHex + sHex + idHex;\n}\nexport const ECKeySign = getECKeySig; // backwards-compatible alias\n\nexport function sha256(msgBytes: SomeBytes) {\n    const msgHex = byteArray2hexStr(msgBytes);\n    const hashHex = ethSha256('0x' + msgHex).replace(/^0x/, '');\n    return hexStr2byteArray(hashHex);\n}\n\nexport const SHA256 = sha256; // backwards-compatible alias\n\nexport function passwordToAddress(password: string) {\n    const com_priKeyBytes = base64DecodeFromString(password);\n    const com_addressBytes = getAddressFromPriKey(com_priKeyBytes);\n\n    return getBase58CheckAddress(com_addressBytes);\n}\n\nexport function pkToAddress(privateKey: string, strict = false) {\n    const com_priKeyBytes = hexStr2byteArray(privateKey, strict);\n    const com_addressBytes = getAddressFromPriKey(com_priKeyBytes);\n\n    return getBase58CheckAddress(com_addressBytes);\n}\n","import {TRON_BIP39_PATH_INDEX_0} from './address';\nimport {byteArray2hexStr} from './bytes';\nimport {\n    genPriKey,\n    getAddressFromPriKey,\n    getBase58CheckAddress,\n    getPubKeyFromPriKey,\n    pkToAddress,\n} from './crypto';\nimport type {Mnemonic, Wordlist} from './ethersUtils';\nimport {ethersWallet} from './ethersUtils';\nimport utils from './index';\n\nconst INVALID_TRON_PATH_ERROR_MSG = 'Invalid tron path provided';\n\nexport interface IAccountBase {\n    privateKey: string;\n    publicKey: string;\n}\nexport interface IAccountWithMnemonic extends IAccountBase {\n    mnemonic: Mnemonic;\n    address: string;\n}\nexport interface IAccount extends IAccountBase {\n    address: {base58: string; hex: string};\n}\n\nexport function generateAccount(): IAccount {\n    const priKeyBytes = genPriKey();\n    const pubKeyBytes = getPubKeyFromPriKey(priKeyBytes);\n    const addressBytes = getAddressFromPriKey(priKeyBytes);\n\n    const privateKey = byteArray2hexStr(priKeyBytes);\n    const publicKey = byteArray2hexStr(pubKeyBytes);\n\n    return {\n        privateKey,\n        publicKey,\n        address: {\n            base58: getBase58CheckAddress(addressBytes),\n            hex: byteArray2hexStr(addressBytes),\n        },\n    };\n}\n\nexport function generateRandom(options?: {\n    path?: string;\n}): IAccountWithMnemonic {\n    if (!utils.isObject(options)) options = {};\n    if (!options.path) options.path = TRON_BIP39_PATH_INDEX_0;\n\n    if (!String(options.path).match(/^m\\/44'\\/195'/))\n        throw new Error(INVALID_TRON_PATH_ERROR_MSG);\n\n    const account = ethersWallet.createRandom(options);\n\n    return {\n        mnemonic: account.mnemonic,\n        privateKey: account.privateKey,\n        publicKey: account.publicKey,\n        address: pkToAddress(account.privateKey.replace(/^0x/, '')),\n    };\n}\n\nexport function generateAccountWithMnemonic(\n    mnemonic: string,\n    path?: string | null,\n    wordlist: string | Wordlist = 'en',\n): IAccountWithMnemonic {\n    if (!path) path = TRON_BIP39_PATH_INDEX_0;\n\n    if (!String(path).match(/^m\\/44'\\/195'/))\n        throw new Error(INVALID_TRON_PATH_ERROR_MSG);\n\n    // FIXME: remove, if merged https://github.com/ethers-io/ethers.js/pull/3440\n    // @ts-ignore\n    const account = ethersWallet.fromMnemonic(mnemonic, path, wordlist);\n\n    return {\n        mnemonic: account.mnemonic,\n        privateKey: account.privateKey,\n        publicKey: account.publicKey,\n        address: pkToAddress(account.privateKey.replace(/^0x/, '')),\n    };\n}\n","import {ADDRESS_PREFIX} from './address';\nimport type {SomeBytes} from './bytes';\nimport {hexStr2byteArray} from './code';\nimport {getBase58CheckAddress} from './crypto';\nimport {\n    SigningKey,\n    concat,\n    joinSignature,\n    keccak256,\n    recoverAddress,\n    toUtf8Bytes,\n} from './ethersUtils';\n\nexport const TRON_MESSAGE_PREFIX = '\\x19TRON Signed Message:\\n';\n\nexport function hashMessage(message: string | SomeBytes): string {\n    if (typeof message === 'string') message = toUtf8Bytes(message);\n\n    return keccak256(\n        concat([\n            toUtf8Bytes(TRON_MESSAGE_PREFIX),\n            toUtf8Bytes(String(message.length)),\n            message,\n        ]),\n    );\n}\n\nexport function signMessage(\n    message: string | SomeBytes,\n    privateKey: string,\n): string {\n    if (!privateKey.match(/^0x/)) privateKey = '0x' + privateKey;\n\n    const signingKey = new SigningKey(privateKey);\n    const messageDigest = hashMessage(message);\n    const signature = signingKey.signDigest(messageDigest);\n\n    return joinSignature(signature);\n}\n\nexport function verifyMessage(\n    message: string | SomeBytes,\n    signature: string,\n): string {\n    if (!signature.match(/^0x/)) signature = '0x' + signature;\n\n    const recovered = recoverAddress(hashMessage(message), signature);\n    return getBase58CheckAddress(\n        hexStr2byteArray(recovered.replace(/^0x/, ADDRESS_PREFIX)),\n    );\n}\n","import BigNumber from 'bignumber.js';\nimport validator from 'validator';\n\nimport type {IAbiItem} from '../lib/contract/index';\nimport type {IEvent, IEventResponse} from '../lib/event';\nimport * as abi from './abi';\nimport * as accounts from './accounts';\nimport {ADDRESS_PREFIX} from './address';\nimport * as base58 from './base58';\nimport * as bytes from './bytes';\nimport * as code from './code';\nimport * as crypto from './crypto';\nimport * as ethersUtils from './ethersUtils';\nimport * as message from './message';\nimport {TypedDataEncoder as _TypedDataEncoder} from './typedData';\n\nconst utils = {\n    isValidURL(url: any): url is string {\n        if (typeof url !== 'string') return false;\n        return validator.isURL(url.toString(), {\n            protocols: ['http', 'https'],\n            require_tld: false,\n        });\n    },\n\n    isObject<T extends object>(obj: unknown): obj is T {\n        return (\n            obj === Object(obj) &&\n            Object.prototype.toString.call(obj) !== '[object Array]'\n        );\n    },\n\n    isArray(array: any): array is unknown[] {\n        return Array.isArray(array);\n    },\n\n    isJson(string: any): boolean {\n        try {\n            return !!JSON.parse(string);\n        } catch (ex) {\n            return false;\n        }\n    },\n\n    isBoolean(bool: any): bool is boolean {\n        return typeof bool === 'boolean';\n    },\n\n    isBigNumber(number: any): number is BigNumber {\n        return (\n            number &&\n            (number instanceof BigNumber ||\n                (number.constructor && number.constructor.name === 'BigNumber'))\n        );\n    },\n\n    isString(string: any): string is string {\n        return (\n            typeof string === 'string' ||\n            (string &&\n                string.constructor &&\n                string.constructor.name === 'String')\n        );\n    },\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    isFunction(obj: any): obj is Function {\n        return typeof obj === 'function';\n    },\n\n    isHex(string: any): string is string {\n        return (\n            typeof string === 'string' &&\n            !isNaN(parseInt(string, 16)) &&\n            /^(0x|)[a-fA-F0-9]+$/.test(string)\n        );\n    },\n\n    isInteger(number: any): number is number {\n        if (number === null) return false;\n        return Number.isInteger(Number(number));\n    },\n\n    hasProperty(obj: any, property: string): boolean {\n        return Object.prototype.hasOwnProperty.call(obj, property);\n    },\n\n    hasProperties(obj: any, ...properties: string[]): boolean {\n        return (\n            !!properties.length &&\n            !properties\n                .map((property) => {\n                    return this.hasProperty(obj, property);\n                })\n                .includes(false)\n        );\n    },\n\n    mapEvent(event: IEventResponse): IEvent {\n        const data = {\n            block: event.block_number,\n            timestamp: event.block_timestamp,\n            contract: event.contract_address,\n            name: event.event_name,\n            transaction: event.transaction_id,\n            result: event.result,\n            resourceNode:\n                event.resource_Node ||\n                (event._unconfirmed ? 'fullNode' : 'solidityNode'),\n        } as any;\n        if (event._unconfirmed) data.unconfirmed = event._unconfirmed;\n        if (event._fingerprint) data.fingerprint = event._fingerprint;\n        return data;\n    },\n\n    parseEvent(event: IEvent, {inputs: abi}: {inputs: IAbiItem[]}): IEvent {\n        if (!event.result) return event;\n\n        if (this.isArray(event.result))\n            event.result = event.result.reduce(\n                (obj: Record<string, unknown>, result, index) => {\n                    const {name, type} = abi[index];\n\n                    if (type === 'address')\n                        result =\n                            ADDRESS_PREFIX +\n                            (result as string).substr(2).toLowerCase();\n\n                    obj[name] = result;\n\n                    return obj;\n                },\n                {},\n            );\n        else if (this.isObject(event.result))\n            for (let i = 0; i < abi.length; i++) {\n                const obj = abi[i];\n                if (obj.type === 'address' && obj.name in event.result)\n                    event.result[obj.name] =\n                        ADDRESS_PREFIX +\n                        (event.result[obj.name] as string)\n                            .substr(2)\n                            .toLowerCase();\n            }\n\n        return event;\n    },\n\n    padLeft(input: any, padding: string, amount: number): string {\n        let res = input.toString();\n        while (res.length < amount) res = padding + res;\n        return res;\n    },\n\n    isNotNullOrUndefined<T>(\n        val: T,\n    ): val is Exclude<Exclude<T, null>, undefined> {\n        return val !== null && typeof val !== 'undefined';\n    },\n\n    async sleep(millis = 1000): Promise<never> {\n        return new Promise((resolve) => setTimeout(resolve, millis));\n    },\n};\n\nexport default {\n    ...utils,\n    code,\n    accounts,\n    base58,\n    bytes,\n    crypto,\n    abi,\n    message,\n    _TypedDataEncoder,\n    ethersUtils,\n};\n","import Contract from '.';\nimport type {IAbiItem, IFuncAbi} from '.';\nimport type {ContractEventOptions} from '.';\nimport utils from '../../utils';\nimport {WithTronwebAndInjectpromise} from '../../utils/_base';\nimport {decodeParamsV2ByABI, encodeParamsV2ByABI} from '../../utils/abi';\nimport type _CallbackT from '../../utils/typing';\nimport type {\n    ContractOptions,\n    ITriggerConstantContract,\n    ITriggerContractOptions,\n} from '../transactionBuilder';\nimport type {ITransactionInfo} from '../trx';\n\nexport interface IMethodSendOptions extends Partial<ContractOptions> {\n    from?: string;\n    shouldPollResponse?: boolean;\n    maxRetries?: number; // Default: 20\n    pollingInterval?: number; // Default: 3000 [ms]\n    rawResponse?: boolean;\n    keepTxID?: boolean;\n}\n\nconst MISSING_ADDRESS_MSG = 'Smart contract is missing address';\n\nconst getFunctionSelector = (abi) => {\n    abi.stateMutability = abi.stateMutability\n        ? abi.stateMutability.toLowerCase()\n        : 'nonpayable';\n    abi.type = abi.type ? abi.type.toLowerCase() : '';\n    if (abi.type === 'fallback' || abi.type === 'receive') return '0x';\n    const iface = new utils.ethersUtils.Interface([abi]);\n    if (abi.type === 'event')\n        return iface\n            .getEvent(abi.name)\n            .format(utils.ethersUtils.FormatTypes.sighash);\n\n    return iface\n        .getFunction(abi.name)\n        .format(utils.ethersUtils.FormatTypes.sighash);\n};\n\nconst decodeOutput = (abi, output) => {\n    return decodeParamsV2ByABI(abi, output);\n};\n\nexport interface IOnMethod {\n    call(options?: ITriggerContractOptions, callback?: undefined): Promise<any>;\n    call(\n        options: ITriggerContractOptions | undefined,\n        callback: _CallbackT<any>,\n    ): Promise<void>;\n\n    send(\n        options: IMethodSendOptions & {shouldPollResponse: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    send(\n        options: IMethodSendOptions & {shouldPollResponse: false},\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, any]>;\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, any]>,\n    ): Promise<void>;\n\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: false;\n            keepTxID: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<any>;\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: false;\n            keepTxID: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<any>,\n    ): Promise<void>;\n\n    send(\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<any>,\n    ): Promise<any>;\n\n    watch(\n        options: ContractEventOptions,\n        callback: _CallbackT<any>,\n    ): Promise<{\n        start: () => void;\n        stop: () => void;\n    }>;\n}\n\nexport default class Method extends WithTronwebAndInjectpromise {\n    contract: Contract;\n    abi: IFuncAbi;\n    name: string;\n    inputs: IAbiItem[];\n    outputs: IAbiItem[];\n    functionSelector: string;\n    signature: string;\n    defaultOptions: {\n        feeLimit: number;\n        callValue: number;\n        userFeePercentage: number;\n        shouldPollResponse: boolean;\n    };\n\n    constructor(contract: Contract, abi: IFuncAbi) {\n        super(contract.tronWeb);\n\n        this.contract = contract;\n\n        this.abi = abi;\n        this.name = abi.name || (abi.name = abi.type);\n\n        this.inputs = abi.inputs || [];\n        this.outputs = abi.outputs || [];\n\n        this.functionSelector = getFunctionSelector(abi);\n        this.signature = this.tronWeb\n            .sha3(this.functionSelector, false)\n            .slice(0, 8);\n\n        this.defaultOptions = {\n            feeLimit: this.tronWeb.feeLimit,\n            callValue: 0,\n            userFeePercentage: 100,\n            shouldPollResponse: false,\n        };\n    }\n\n    decodeInput(data) {\n        return decodeOutput(this.inputs, '0x' + data);\n    }\n\n    onMethod(...args) {\n        let rawParameter = '';\n        if (this.abi && !/event/i.test(this.abi.type))\n            rawParameter = encodeParamsV2ByABI(this.abi, args);\n\n        return {\n            call: (\n                options: ITriggerContractOptions = {},\n                callback?: _CallbackT<any>,\n            ) => {\n                options = {\n                    ...options,\n                    rawParameter,\n                };\n\n                return this._call([], [], options, callback);\n            },\n\n            send: (\n                options: Partial<ContractOptions> & IMethodSendOptions = {},\n                privateKey: string = this.tronWeb.defaultPrivateKey,\n                callback?: _CallbackT<any>,\n            ) => {\n                options = {\n                    ...options,\n                    rawParameter,\n                };\n\n                return this._send([], [], options, privateKey, callback);\n            },\n            watch: (this['_watch'] = this._watch.bind(this)),\n        } as IOnMethod;\n    }\n\n    async _call(\n        types: string[],\n        args: unknown[],\n        options: ITriggerContractOptions = {},\n        callback?: _CallbackT<any>,\n    ) {\n        if (!callback)\n            return this.injectPromise(this._call, types, args, options);\n\n        if (types.length !== args.length)\n            return callback('Invalid argument count provided');\n\n        if (!this.contract.address) return callback(MISSING_ADDRESS_MSG);\n\n        if (!this.contract.deployed)\n            return callback(\n                'Calling smart contracts requires you to load the contract first',\n            );\n\n        const {stateMutability} = this.abi;\n\n        if (!['pure', 'view'].includes(stateMutability.toLowerCase()))\n            return callback(\n                `Methods with state mutability \"${stateMutability}\" must use send()`,\n            );\n\n        const final_options: ContractOptions & {\n            _isConstant: boolean;\n            from: string;\n        } = {\n            ...this.defaultOptions,\n            from: this.tronWeb.defaultAddress.hex,\n            ...options,\n            _isConstant: true,\n        } as any;\n\n        const parameters = args.map((value, index) => ({\n            type: types[index],\n            value,\n        }));\n\n        // Changed by me, was triggerSmartContract\n        this.tronWeb.transactionBuilder.triggerConstantContract(\n            this.contract.address,\n            this.functionSelector,\n            final_options,\n            parameters,\n            final_options.from\n                ? this.tronWeb.address.toHex(final_options.from)\n                : undefined,\n            (err: unknown, transaction?: ITriggerConstantContract): void => {\n                if (err) return callback(err);\n\n                if (\n                    !transaction ||\n                    !utils.hasProperty(transaction, 'constant_result')\n                )\n                    return callback('Failed to execute');\n\n                try {\n                    const len = transaction.constant_result[0].length;\n                    if (len === 0 || len % 64 === 8) {\n                        let msg =\n                            'The call has been reverted or has thrown an error.';\n                        if (len !== 0) {\n                            msg += ' Error message: ';\n                            let msg2 = '';\n                            const chunk =\n                                transaction.constant_result[0].substring(8);\n                            for (let i = 0; i < len - 8; i += 64)\n                                msg2 += this.tronWeb.toUtf8(\n                                    chunk.substring(i, i + 64),\n                                );\n\n                            msg += msg2\n                                // eslint-disable-next-line no-control-regex\n                                .replace(/(\\u0000|\\u000b|\\f)+/g, ' ')\n                                .replace(/ +/g, ' ')\n                                .replace(/\\s+$/g, '');\n                        }\n                        return callback(msg);\n                    }\n\n                    let output = decodeOutput(\n                        this.abi,\n                        '0x' + transaction.constant_result[0],\n                    );\n\n                    if (output.length === 1 && Object.keys(output).length === 1)\n                        output = output[0];\n\n                    return callback(null, output);\n                } catch (ex) {\n                    return callback(ex);\n                }\n            },\n        );\n    }\n\n    async _send(\n        types: string[],\n        args: unknown[],\n        options: IMethodSendOptions = {},\n        privateKey: string = this.tronWeb.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ) {\n        if (!callback)\n            return this.injectPromise(\n                this._send,\n                types,\n                args,\n                options,\n                privateKey,\n            );\n\n        if (types.length !== args.length)\n            throw new Error('Invalid argument count provided');\n\n        if (!this.contract.address) return callback(MISSING_ADDRESS_MSG);\n\n        if (!this.contract.deployed)\n            return callback(\n                'Calling smart contracts requires you to load the contract first',\n            );\n\n        const {stateMutability} = this.abi;\n\n        if (['pure', 'view'].includes(stateMutability.toLowerCase()))\n            return callback(\n                `Methods with state mutability \"${stateMutability}\" must use call()`,\n            );\n\n        // If a function isn't payable, dont provide a callValue.\n        if (!['payable'].includes(stateMutability.toLowerCase()))\n            options.callValue = 0;\n\n        // TODO: this intersection may be not needed after final options cleanup\n        const final_options: ContractOptions & IMethodSendOptions = {\n            ...this.defaultOptions,\n            from: this.tronWeb.defaultAddress.hex,\n            ...options,\n        } as any;\n\n        const parameters = args.map((value, index) => ({\n            type: types[index],\n            value,\n        }));\n\n        try {\n            const address = privateKey\n                ? this.tronWeb.address.fromPrivateKey(privateKey)\n                : this.tronWeb.defaultAddress.base58;\n            const transaction =\n                await this.tronWeb.transactionBuilder.triggerSmartContract(\n                    this.contract.address,\n                    this.functionSelector,\n                    final_options,\n                    parameters,\n                    this.tronWeb.address.toHex(address),\n                );\n\n            if (!transaction.result || !transaction.result.result)\n                return callback(\n                    'Unknown error: ' + JSON.stringify(transaction, null, 2),\n                );\n\n            // If privateKey is false, this won't be signed here.\n            // We assume sign functionality will be replaced.\n            const signedTransaction = await this.tronWeb.trx.sign(\n                transaction.transaction,\n                privateKey,\n            );\n\n            if (!signedTransaction.signature) {\n                if (!privateKey)\n                    return callback('Transaction was not signed properly');\n\n                return callback('Invalid private key provided');\n            }\n\n            const broadcast = await this.tronWeb.trx.sendRawTransaction(\n                signedTransaction,\n            );\n\n            if (broadcast.code) {\n                const err = {\n                    error: broadcast.code,\n                    message: broadcast.code,\n                };\n                if (broadcast.message)\n                    err.message = this.tronWeb.toUtf8(broadcast.message);\n                return callback(err);\n            }\n\n            if (!final_options.shouldPollResponse)\n                return callback(null, signedTransaction.txID);\n\n            const {maxRetries = 20, pollingInterval = 3_000} = options;\n\n            const checkResult = async (index = 0) => {\n                if (index === maxRetries - 1)\n                    return callback({\n                        error: 'Cannot find result in solidity node',\n                        transaction: signedTransaction,\n                    });\n\n                const output = await this.tronWeb.trx.getTransactionInfo(\n                    signedTransaction.txID,\n                );\n\n                if (!Object.keys(output).length)\n                    return setTimeout(() => {\n                        checkResult(index + 1);\n                    }, pollingInterval);\n\n                if ('result' in output && output.result === 'FAILED')\n                    return callback({\n                        error: this.tronWeb.toUtf8(output.resMessage!),\n                        transaction: signedTransaction,\n                        output,\n                    });\n\n                if (!utils.hasProperty(output, 'contractResult'))\n                    return callback({\n                        error:\n                            'Failed to execute: ' +\n                            JSON.stringify(output, null, 2),\n                        transaction: signedTransaction,\n                        output,\n                    });\n\n                if (final_options.rawResponse) return callback(null, output);\n\n                let decoded = decodeOutput(\n                    this.abi,\n                    '0x' + output.contractResult[0],\n                );\n\n                if (decoded.length === 1 && Object.keys(decoded).length === 1)\n                    decoded = decoded[0];\n\n                if (final_options.keepTxID)\n                    return callback(null, [signedTransaction.txID, decoded]);\n\n                return callback(null, decoded);\n            };\n\n            checkResult();\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async _watch(\n        options: Partial<ContractEventOptions> = {},\n        callback: _CallbackT<any>,\n    ) {\n        if (!utils.isFunction(callback))\n            throw new Error('Expected callback to be provided');\n\n        if (!this.contract.address) return callback(MISSING_ADDRESS_MSG);\n\n        if (!this.abi.type || !/event/i.test(this.abi.type))\n            return callback('Invalid method type for event watching');\n\n        if (!this.tronWeb.eventServer)\n            return callback('No event server configured');\n\n        let listener: NodeJS.Timer | null = null;\n        let lastBlock: number | null = null;\n        const since = Date.now() - 1000;\n\n        const getEvents = async () => {\n            if (!this.contract.address) throw new Error(MISSING_ADDRESS_MSG);\n\n            try {\n                const params = {\n                    since,\n                    eventName: this.name,\n                    sort: 'block_timestamp',\n                    blockNumber: 'latest',\n                    filters: options.filters,\n                } as Record<string, unknown>;\n\n                if (options.size) params.size = options.size;\n\n                if (options.resourceNode)\n                    if (/full/i.test(options.resourceNode))\n                        params.onlyUnconfirmed = true;\n                    else params.onlyConfirmed = true;\n\n                const events =\n                    await this.tronWeb.event.getEventsByContractAddress(\n                        this.contract.address,\n                        params,\n                    );\n                const [latestEvent] = events.sort((a, b) => b.block - a.block);\n                const newEvents = events.filter((event, index) => {\n                    if (\n                        options.resourceNode &&\n                        event.resourceNode &&\n                        options.resourceNode.toLowerCase() !==\n                            event.resourceNode.toLowerCase()\n                    )\n                        return false;\n\n                    const duplicate = events\n                        .slice(0, index)\n                        .some(\n                            (priorEvent) =>\n                                JSON.stringify(priorEvent) ===\n                                JSON.stringify(event),\n                        );\n\n                    if (duplicate) return false;\n\n                    if (!lastBlock) return true;\n\n                    return event.block > lastBlock;\n                });\n\n                if (latestEvent) lastBlock = latestEvent.block;\n\n                return newEvents;\n            } catch (ex) {\n                return Promise.reject(ex);\n            }\n        };\n\n        const bindListener = () => {\n            if (listener) clearInterval(listener);\n\n            listener = setInterval(() => {\n                getEvents()\n                    .then((events) =>\n                        events.forEach((event) => {\n                            callback(null, utils.parseEvent(event, this.abi));\n                        }),\n                    )\n                    .catch((err) => callback(err));\n            }, 3000);\n        };\n\n        await getEvents();\n        bindListener();\n\n        return {\n            start: bindListener,\n            stop: () => {\n                if (!listener) return;\n\n                clearInterval(listener);\n                listener = null;\n            },\n        };\n    }\n}\n","import TronWeb from '../..';\nimport {WithTronwebAndInjectpromise} from '../../../src/utils/_base';\nimport type {SmartContract_ABI_Entry_StateMutabilityType as IAbiStateMutability} from '../../proto/core/contract/smart_contract';\nimport utils from '../../utils';\nimport type _CallbackT from '../../utils/typing';\nimport type {IEvent} from '../event';\nimport type {ContractOptions} from '../transactionBuilder';\nimport Method from './method';\n\nexport type {IMethodSendOptions} from './method';\n\nexport interface IAbiItem {\n    name: string;\n    type: string;\n    components?: IAbiItem[];\n    internalType?: string;\n}\nexport interface IEventAbiItem extends IAbiItem {\n    indexed: boolean;\n}\nexport interface IFuncAbi {\n    name: string;\n    type: 'function' | 'constructor' | 'receive' | 'fallback';\n    stateMutability: IAbiStateMutability;\n    inputs: IAbiItem[];\n    outputs: IAbiItem[];\n    constant?: boolean;\n    payable?: boolean;\n}\nexport interface IEventAbi {\n    name: string;\n    type: 'event';\n    inputs: IEventAbiItem[];\n    anonymous: boolean;\n}\nexport interface IErrorAbi {\n    name: string;\n    type: 'error';\n    inputs: IEventAbiItem[];\n}\nexport type IAbi = IFuncAbi | IEventAbi | IErrorAbi;\n\nexport interface ContractEventOptions {\n    sinceTimestamp?: number;\n    since?: any;\n    fromTimestamp?: number;\n    eventName?: string;\n    blockNumber?: number;\n    size?: number;\n    page?: number;\n    onlyConfirmed?: any;\n    onlyUnconfirmed?: any;\n    previousLastEventFingerprint?: any;\n    previousFingerprint?: any;\n    fingerprint?: any;\n    rawResponse?: boolean;\n    sort?: string;\n    filters?: unknown | unknown[];\n    resourceNode?: string;\n}\n\nclass _Contract extends WithTronwebAndInjectpromise {\n    address: string | null;\n    abi: IAbi[];\n    eventListener: NodeJS.Timer | null | undefined;\n    eventCallback: ((event: IEvent) => void) | null | undefined;\n    bytecode: unknown;\n    deployed: boolean;\n    lastBlock: unknown;\n    methods: Record<string, MethodCallT>;\n    methodInstances: Record<string, Method>;\n    props: string[];\n\n    constructor(tronWeb: TronWeb, abi: IAbi[] = [], address?: string) {\n        super(tronWeb);\n\n        this.address = address || null;\n        this.abi = abi;\n\n        this.eventListener = null;\n        this.eventCallback = null;\n        this.bytecode = null;\n        this.deployed = false;\n        this.lastBlock = null;\n\n        this.methods = {};\n        this.methodInstances = {};\n        this.props = [];\n\n        if (this.tronWeb.isAddress(address)) this.deployed = true;\n        else this.address = null;\n\n        this.loadAbi(abi);\n\n        return this;\n    }\n\n    async _getEvents(options: ContractEventOptions = {}) {\n        if (!this.address)\n            throw new Error('Contract is not configured with an address');\n        if (options.rawResponse)\n            throw new Error('Cannot parse raw response here.');\n\n        const events = await this.tronWeb.event.getEventsByContractAddress(\n            this.address,\n            options as ContractEventOptions & {rawResponse?: false},\n        );\n        const [latestEvent] = events.sort((a, b) => b.block - a.block);\n        const newEvents = events.filter((event, index) => {\n            if (\n                options.resourceNode &&\n                event.resourceNode &&\n                options.resourceNode.toLowerCase() !==\n                    event.resourceNode.toLowerCase()\n            )\n                return false;\n\n            const duplicate = events\n                .slice(0, index)\n                .some(\n                    (priorEvent) =>\n                        JSON.stringify(priorEvent) === JSON.stringify(event),\n                );\n\n            if (duplicate) return false;\n\n            if (!this.lastBlock) return true;\n\n            return event.block > this.lastBlock;\n        });\n\n        if (latestEvent) this.lastBlock = latestEvent.block;\n\n        return newEvents;\n    }\n\n    async _startEventListener(\n        options: ContractEventOptions = {},\n        callback?: (event: IEvent) => void,\n    ) {\n        if (this.eventListener) clearInterval(this.eventListener);\n\n        if (!this.tronWeb.eventServer)\n            throw new Error('Event server is not configured');\n\n        if (!this.address)\n            throw new Error('Contract is not configured with an address');\n\n        this.eventCallback = callback;\n        await this._getEvents(options);\n\n        this.eventListener = setInterval(() => {\n            this._getEvents(options)\n                .then((newEvents) =>\n                    newEvents.forEach((event) => {\n                        this.eventCallback && this.eventCallback(event);\n                    }),\n                )\n                .catch((err) => {\n                    console.error('Failed to get event list', err);\n                });\n        }, 3000);\n    }\n\n    _stopEventListener() {\n        if (!this.eventListener) return;\n\n        clearInterval(this.eventListener);\n        this.eventListener = null;\n        this.eventCallback = null;\n    }\n\n    hasProperty(property: string): boolean {\n        return (\n            Object.prototype.hasOwnProperty.call(this, property) ||\n            // TODO: just remove this, it's very old stuff\n            (this as any).__proto__.hasOwnProperty(property) // eslint-disable-line\n        );\n    }\n\n    loadAbi(abi: IAbi[]) {\n        this.abi = abi;\n        this.methods = {};\n\n        this.props.forEach((prop) => delete this[prop]);\n\n        abi.forEach((func) => {\n            // Don't build a method for constructor function.\n            // That's handled through contract create.\n            if (\n                !func.type ||\n                /constructor/i.test(func.type) ||\n                func.type === 'event' ||\n                func.type === 'error'\n            )\n                return;\n\n            const method = new Method(this as unknown as Contract, func);\n            const methodCall = method.onMethod.bind(method);\n\n            const {name, functionSelector, signature} = method;\n\n            this.methods[name] = methodCall;\n            this.methods[functionSelector] = methodCall;\n            this.methods[signature] = methodCall;\n\n            this.methodInstances[name] = method;\n            this.methodInstances[functionSelector] = method;\n            this.methodInstances[signature] = method;\n\n            if (!this.hasProperty(name)) {\n                this[name] = methodCall;\n                this.props.push(name);\n            }\n\n            if (!this.hasProperty(functionSelector)) {\n                this[functionSelector] = methodCall;\n                this.props.push(functionSelector);\n            }\n\n            if (!this.hasProperty(signature)) {\n                this[signature] = methodCall;\n                this.props.push(signature);\n            }\n        });\n    }\n\n    decodeInput(data: string) {\n        const methodName = data.substring(0, 8);\n        const inputData = data.substring(8);\n\n        if (!this.methodInstances[methodName])\n            throw new Error('Contract method ' + methodName + ' not found');\n\n        const methodInstance = this.methodInstances[methodName];\n\n        return {\n            name: methodInstance.name,\n            params: this.methodInstances[methodName].decodeInput(inputData),\n        };\n    }\n\n    async new(\n        options: ContractOptions,\n        privateKey: string,\n        callback?: unknown,\n    ): Promise<this>;\n    async new(\n        options: ContractOptions,\n        privateKey: string,\n        callback: _CallbackT<this>,\n    ): Promise<void>;\n    async new(\n        options: ContractOptions,\n        privateKey: string = this.tronWeb.defaultPrivateKey,\n        callback?: _CallbackT<this>,\n    ): Promise<void | this> {\n        if (!callback) return this.injectPromise(this.new, options, privateKey);\n\n        try {\n            const address = this.tronWeb.address.fromPrivateKey(privateKey);\n            if (!address) return callback('Invalid privateKey provided!');\n\n            const transaction =\n                await this.tronWeb.transactionBuilder.createSmartContract(\n                    options,\n                    address,\n                );\n            const signedTransaction = await this.tronWeb.trx.sign(\n                transaction,\n                privateKey,\n            );\n            const contract = await this.tronWeb.trx.sendRawTransaction(\n                signedTransaction,\n            );\n\n            if (contract.code)\n                return callback({\n                    error: contract.code,\n                    message: this.tronWeb.toUtf8(contract.message),\n                });\n\n            await utils.sleep(3000);\n            return this.at(signedTransaction.contract_address, callback);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async at(contractAddress: string, callback?: unknown): Promise<this>;\n    async at(\n        contractAddress: string,\n        callback: _CallbackT<this>,\n    ): Promise<void>;\n    async at(\n        contractAddress: string,\n        callback?: _CallbackT<this>,\n    ): Promise<void | this> {\n        if (!callback) return this.injectPromise(this.at, contractAddress);\n\n        try {\n            const contract = await this.tronWeb.trx.getContract(\n                contractAddress,\n            );\n\n            if (!contract.contract_address)\n                return callback(\n                    'Unknown error: ' + JSON.stringify(contract, null, 2),\n                );\n\n            this.address = contract.contract_address;\n            this.bytecode = contract.bytecode;\n            this.deployed = true;\n\n            this.loadAbi(\n                contract.abi?.entrys ? (contract.abi.entrys as IAbi[]) : [],\n            );\n\n            return callback(null, this);\n        } catch (ex) {\n            if (ex?.toString && ex.toString().includes('does not exist'))\n                return callback(\n                    'Contract has not been deployed on the network',\n                );\n\n            return callback(ex);\n        }\n    }\n\n    events(options: ContractEventOptions = {}, callback: _CallbackT<any>) {\n        if (!utils.isFunction(callback))\n            throw new Error('Callback function expected');\n\n        const self = this;\n\n        return {\n            start(startCallback: (err?: unknown) => unknown) {\n                if (!startCallback) {\n                    self._startEventListener(options, callback);\n                    return this;\n                }\n\n                self._startEventListener(options, callback)\n                    .then(() => {\n                        startCallback();\n                    })\n                    .catch((err) => {\n                        startCallback(err);\n                    });\n\n                return this;\n            },\n            stop() {\n                self._stopEventListener();\n            },\n        };\n    }\n}\n\n// Hack\n// Pretend like we export class that has additional method-based properties\ntype MethodCallT = Method['onMethod'];\ntype ContractT = _Contract & {[key: string]: MethodCallT};\nconst _ContractI: {\n    new (tronWeb: TronWeb, abi: IAbi[], address?: string): ContractT;\n} = _Contract as any;\n\nexport default class Contract extends _ContractI {}\n// export default Contract;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"querystring\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"axios\");","import axios from 'axios';\nimport type {AxiosInstance, Method} from 'axios';\n\nimport type {\n    Wallet,\n    WalletExtension,\n    WalletSolidity,\n} from '../../proto/api/api';\nimport type {Transaction as ITransaction} from '../../proto/core/Tron';\nimport utils from '../../utils';\nimport type {IEventResponse} from '../event';\nimport {\n    serviceToUrl,\n    walletExtensionMethods,\n    walletMethods,\n    walletSolidityMethods,\n} from './serviceToUrl';\n\nexport class HttpProvider {\n    host: string;\n    timeout: number;\n    user: string | undefined;\n    password: string | undefined;\n    headers: Record<string, string>;\n    statusPage: string;\n    instance: AxiosInstance;\n\n    constructor(\n        host: string,\n        timeout = 30000,\n        user: string | undefined = undefined,\n        password: string | undefined = undefined,\n        headers: Record<string, string> = {},\n        statusPage = '/',\n    ) {\n        if (!utils.isValidURL(host))\n            throw new Error('Invalid URL provided to HttpProvider');\n\n        if (isNaN(timeout) || timeout < 0)\n            throw new Error('Invalid timeout duration provided');\n\n        if (!utils.isObject(headers))\n            throw new Error('Invalid headers object provided');\n\n        host = host.replace(/\\/+$/, '');\n\n        this.host = host;\n        this.timeout = timeout;\n        this.user = user;\n        this.password = password;\n        this.headers = headers;\n        this.statusPage = statusPage;\n\n        this.instance = axios.create({\n            baseURL: host,\n            timeout: timeout,\n            headers: headers,\n            // TODO: was it a typo? was `user` before, and axios refuse to accept it\n            auth:\n                user && password\n                    ? {\n                          // user,\n                          username: user,\n                          password,\n                      }\n                    : undefined,\n        });\n    }\n\n    setStatusPage(statusPage = '/') {\n        this.statusPage = statusPage;\n    }\n\n    async isConnected(statusPage = this.statusPage) {\n        return this.request(statusPage)\n            .then((data) => {\n                return utils.hasProperties(data, 'blockID', 'block_header');\n            })\n            .catch(() => false);\n    }\n\n    request<T extends string & keyof typeof walletMethods>(\n        serviceName: `wallet/${T}` | `/wallet/${T}`,\n        payload?: undefined,\n        method?: 'get' | 'GET',\n    ): ReturnType<Wallet[typeof walletMethods[T]]>;\n    request<T extends string & keyof typeof walletMethods>(\n        serviceName: `wallet/${T}` | `/wallet/${T}`,\n        payload?: Parameters<\n            Wallet[typeof walletMethods[T]]\n        >[0] extends ITransaction\n            ? Parameters<Wallet[typeof walletMethods[T]]>[0]\n            : never,\n        method?: Method,\n    ): ReturnType<Wallet[typeof walletMethods[T]]>;\n    request<T extends string & keyof typeof walletMethods>(\n        serviceName: `wallet/${T}` | `/wallet/${T}`,\n        payload: Parameters<Wallet[typeof walletMethods[T]]>[0],\n        method?: Method,\n    ): ReturnType<Wallet[typeof walletMethods[T]]>;\n    request<T extends string & keyof typeof walletSolidityMethods>(\n        serviceName: `walletsolidity/${T}` | `/walletsolidity/${T}`,\n        payload?: undefined,\n        method?: 'get' | 'GET',\n    ): ReturnType<WalletSolidity[typeof walletSolidityMethods[T]]>;\n    request<T extends string & keyof typeof walletSolidityMethods>(\n        serviceName: `walletsolidity/${T}` | `/walletsolidity/${T}`,\n        payload?: Parameters<\n            WalletSolidity[typeof walletSolidityMethods[T]]\n        >[0] extends ITransaction\n            ? Parameters<WalletSolidity[typeof walletSolidityMethods[T]]>[0]\n            : never,\n        method?: Method,\n    ): ReturnType<WalletSolidity[typeof walletSolidityMethods[T]]>;\n    request<T extends string & keyof typeof walletSolidityMethods>(\n        serviceName: `walletsolidity/${T}` | `/walletsolidity/${T}`,\n        payload: Parameters<WalletSolidity[typeof walletSolidityMethods[T]]>[0],\n        method?: Method,\n    ): ReturnType<WalletSolidity[typeof walletSolidityMethods[T]]>;\n    request<T extends string & keyof typeof walletExtensionMethods>(\n        serviceName: `walletextension/${T}` | `/walletextension/${T}`,\n        payload?: undefined,\n        method?: 'get' | 'GET',\n    ): ReturnType<WalletExtension[typeof walletExtensionMethods[T]]>;\n    request<T extends string & keyof typeof walletExtensionMethods>(\n        serviceName: `walletextension/${T}` | `/walletextension/${T}`,\n        payload?: Parameters<\n            WalletExtension[typeof walletExtensionMethods[T]]\n        >[0] extends ITransaction\n            ? Parameters<WalletExtension[typeof walletExtensionMethods[T]]>[0]\n            : never,\n        method?: Method,\n    ): ReturnType<WalletExtension[typeof walletExtensionMethods[T]]>;\n    request<T extends string & keyof typeof walletExtensionMethods>(\n        serviceName: `walletextension/${T}` | `/walletextension/${T}`,\n        payload: Parameters<\n            WalletExtension[typeof walletExtensionMethods[T]]\n        >[0],\n        method?: Method,\n    ): ReturnType<WalletExtension[typeof walletExtensionMethods[T]]>;\n    request<T extends string, Q extends 'transaction' | 'contract'>(\n        serviceName: `event/${Q}/${T}` | `/event/${Q}/${T}`,\n        payload?: undefined,\n        method?: 'get' | 'GET',\n    ): Promise<IEventResponse[]>;\n    request(\n        serviceName: string,\n        payload?: undefined,\n        method?: Method,\n    ): Promise<unknown>;\n    request(serviceName: string, payload = {}, method: Method = 'get') {\n        method = method.toLowerCase() as Method;\n\n        return this.instance\n            .request({\n                data:\n                    method === 'post' && Object.keys(payload).length\n                        ? payload\n                        : null,\n                params: method === 'get' && payload,\n                url: serviceToUrl(serviceName),\n                method,\n            })\n            .then(({data}) => data);\n    }\n}\n","import {HttpProvider} from './HttpProvider';\n\nexport {HttpProvider} from './HttpProvider';\n\nexport default {\n    HttpProvider,\n};\n","import querystring from 'querystring';\n\nimport {WithTronwebAndInjectpromise} from '../../src/utils/_base';\nimport utils from '../utils';\nimport type _CallbackT from '../utils/typing';\nimport type {ContractEventOptions} from './contract';\nimport * as providers from './providers';\n\nexport interface IEventResponse {\n    block_number: number;\n    block_timestamp: number;\n    contract_address: string;\n    event_name: string;\n    transaction_id: string;\n    result: Record<string, unknown> | unknown[];\n    resource_Node?: string;\n    _unconfirmed?: boolean;\n    _fingerprint?: string;\n}\nexport interface IEvent {\n    block: number;\n    timestamp: number;\n    contract: string;\n    name: string;\n    transaction: string;\n    result: Record<string, unknown> | unknown[];\n    resourceNode?: string;\n    unconfirmed?: boolean;\n    fingerprint?: string;\n}\n\nexport default class Event extends WithTronwebAndInjectpromise {\n    setServer(\n        eventServer: string | providers.HttpProvider | null | undefined,\n        healthcheck = 'healthcheck',\n    ): void {\n        // tronWeb instance attrs are handled in a weird way\n        // All usages do not check for undefined, but allow to set\n        // attrs to undefined regularly.\n        // FIXME: should it be allowed?\n        // @ts-ignore\n        if (!eventServer) return (this.tronWeb.eventServer = undefined);\n\n        if (utils.isString(eventServer))\n            eventServer = new providers.HttpProvider(eventServer);\n\n        if (!this.tronWeb.isValidProvider(eventServer))\n            throw new Error('Invalid event server provided');\n\n        this.tronWeb.eventServer = eventServer;\n        this.tronWeb.eventServer.isConnected = () =>\n            this.tronWeb.eventServer\n                .request(healthcheck)\n                .then(() => true)\n                .catch(() => false);\n    }\n\n    getEventsByContractAddress(\n        contractAddress: string,\n        options?: ContractEventOptions & {rawResponse: true},\n        callback?: undefined,\n    ): Promise<IEventResponse[]>;\n    getEventsByContractAddress(\n        contractAddress: string,\n        options?: ContractEventOptions & {rawResponse?: false},\n        callback?: undefined,\n    ): Promise<IEvent[]>;\n    getEventsByContractAddress(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback: _CallbackT<IEventResponse[]>,\n    ): void;\n    getEventsByContractAddress(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback: _CallbackT<IEvent[]>,\n    ): void;\n    getEventsByContractAddress(\n        contractAddress: string,\n        options: ContractEventOptions = {},\n        callback?: _CallbackT<IEventResponse[]> | _CallbackT<IEvent[]>,\n    ): void | Promise<IEventResponse[]> | Promise<IEvent[]> {\n        /* eslint-disable prefer-const */\n        let {\n            sinceTimestamp,\n            since,\n            fromTimestamp,\n            eventName,\n            blockNumber,\n            size,\n            page,\n            onlyConfirmed,\n            onlyUnconfirmed,\n            previousLastEventFingerprint,\n            previousFingerprint,\n            fingerprint,\n            rawResponse,\n            sort,\n            filters,\n        } = Object.assign(\n            {\n                sinceTimestamp: 0,\n                eventName: false,\n                blockNumber: false,\n                size: 20,\n                page: 1,\n            },\n            options,\n        ) as ContractEventOptions;\n        /* eslint-enable prefer-const */\n\n        if (!callback)\n            return this.injectPromise(\n                this.getEventsByContractAddress,\n                contractAddress,\n                options,\n            );\n\n        fromTimestamp = fromTimestamp || sinceTimestamp || since;\n\n        if (!this.tronWeb.eventServer)\n            return callback('No event server configured');\n\n        const routeParams: (string | number)[] = [];\n\n        if (!this.tronWeb.isAddress(contractAddress))\n            return callback('Invalid contract address provided');\n\n        if (eventName && !contractAddress)\n            return callback(\n                'Usage of event name filtering requires a contract address',\n            );\n\n        if (\n            typeof fromTimestamp !== 'undefined' &&\n            !utils.isInteger(fromTimestamp)\n        )\n            return callback('Invalid fromTimestamp provided');\n\n        if (!utils.isInteger(size)) return callback('Invalid size provided');\n\n        if (size > 200) {\n            console.warn('Defaulting to maximum accepted size: 200');\n            size = 200;\n        }\n\n        if (!utils.isInteger(page)) return callback('Invalid page provided');\n\n        if (blockNumber && !eventName)\n            return callback(\n                'Usage of block number filtering requires an event name',\n            );\n\n        if (contractAddress)\n            routeParams.push(this.tronWeb.address.fromHex(contractAddress));\n\n        if (eventName) routeParams.push(eventName);\n\n        if (blockNumber) routeParams.push(blockNumber);\n\n        const qs: Record<string, string | number | boolean> = {\n            size,\n            page,\n        };\n\n        if (\n            filters != null &&\n            typeof filters === 'object' &&\n            Object.keys(filters).length > 0\n        )\n            qs.filters = JSON.stringify(filters);\n\n        if (fromTimestamp) qs.fromTimestamp = qs.since = fromTimestamp;\n\n        if (onlyConfirmed) qs.only_confirmed = onlyConfirmed;\n\n        if (onlyUnconfirmed && !onlyConfirmed)\n            qs.only_unconfirmed = onlyUnconfirmed;\n\n        if (sort) qs.sort = sort;\n\n        fingerprint =\n            fingerprint || previousFingerprint || previousLastEventFingerprint;\n        if (fingerprint) qs.fingerprint = fingerprint;\n\n        return this.tronWeb.eventServer\n            .request(\n                `event/contract/${routeParams.join(\n                    '/',\n                )}?${querystring.stringify(qs)}`,\n            )\n            .then((data) => {\n                if (!data) return callback('Unknown error occurred');\n                if (!utils.isArray(data)) return callback(data);\n\n                if (rawResponse) return callback(null, data as any);\n                else\n                    return callback(\n                        null,\n                        data.map((event) => utils.mapEvent(event)) as any,\n                    );\n            })\n            .catch((err: any) =>\n                callback((err.response && err.response.data) || err),\n            ) as unknown as void;\n    }\n\n    getEventsByTransactionID(\n        transactionID: string,\n        options?: {rawResponse: true},\n        callback?: undefined,\n    ): Promise<IEventResponse[]>;\n    getEventsByTransactionID(\n        transactionID: string,\n        options?: {rawResponse?: false},\n        callback?: undefined,\n    ): Promise<IEvent[]>;\n    getEventsByTransactionID(\n        transactionID: string,\n        options: {rawResponse: true},\n        callback: _CallbackT<IEventResponse[]>,\n    ): void;\n    getEventsByTransactionID(\n        transactionID: string,\n        options: {rawResponse?: false},\n        callback: _CallbackT<IEvent[]>,\n    ): void;\n    getEventsByTransactionID(\n        transactionID: string,\n        options: {rawResponse?: boolean} = {},\n        callback?: _CallbackT<IEventResponse[]> | _CallbackT<IEvent[]>,\n    ): void | Promise<IEventResponse[]> | Promise<IEvent[]> {\n        if (!callback || !utils.isFunction(callback))\n            return this.injectPromise(\n                this.getEventsByTransactionID,\n                transactionID,\n                options,\n            );\n\n        if (!this.tronWeb.eventServer)\n            return callback('No event server configured');\n\n        return this.tronWeb.eventServer\n            .request(`event/transaction/${transactionID}`)\n            .then((data) => {\n                if (!callback) return null;\n\n                if (!data) return callback('Unknown error occurred');\n                if (!utils.isArray(data)) return callback(data);\n\n                return callback(\n                    null,\n                    options.rawResponse === true\n                        ? data\n                        : (data.map((event) => utils.mapEvent(event)) as any),\n                );\n            })\n            .catch(\n                (err: any) =>\n                    callback &&\n                    callback((err.response && err.response.data) || err),\n            ) as unknown as void;\n    }\n}\n","import semver from 'semver';\n\nimport TronWeb from '..';\nimport utils from '../utils';\n\nexport interface IPluginRegisterResult {\n    libs: string[];\n    plugged: string[];\n    skipped: string[];\n    error?: string;\n}\nexport interface IPluginDefn {\n    // TODO: it can be better\n    requires?: string;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    components?: Record<string, Record<string, Function>>;\n    fullClass?: boolean;\n}\n\nexport interface IPlugin<T extends Record<string, unknown> | null | unknown> {\n    pluginInterface?: (options?: T) => IPluginDefn;\n}\ntype Class<I, Args extends any[] = any[]> = new (...args: Args) => I;\n\nexport default class Plugin {\n    tronWeb: TronWeb;\n    pluginNoOverride: string[];\n    disablePlugins: string[] | undefined;\n\n    constructor(tronWeb: TronWeb, options: {disablePlugins?: string[]} = {}) {\n        if (!tronWeb || !(tronWeb instanceof TronWeb))\n            throw new Error('Expected instance of TronWeb');\n        this.tronWeb = tronWeb;\n        this.pluginNoOverride = ['register'];\n        this.disablePlugins = options.disablePlugins;\n    }\n\n    register<T>(PluginCls: Class<IPlugin<T>>, options?: T) {\n        let pluginInterface: IPluginDefn = {\n            requires: '0.0.0',\n            components: {},\n        };\n        const result: IPluginRegisterResult = {\n            libs: [],\n            plugged: [],\n            skipped: [],\n        };\n        if (this.disablePlugins) {\n            result.error = 'This instance of TronWeb has plugins disabled.';\n            return result;\n        }\n        const plugin = new PluginCls(this.tronWeb);\n        if (utils.isFunction(plugin.pluginInterface))\n            pluginInterface = plugin.pluginInterface(options);\n\n        if (\n            !pluginInterface.requires ||\n            semver.satisfies(TronWeb.version, pluginInterface.requires)\n        )\n            if (pluginInterface.fullClass) {\n                // plug the entire class at the same level of tronWeb.trx\n                const className = plugin.constructor.name;\n                const classInstanceName =\n                    className.substring(0, 1).toLowerCase() +\n                    className.substring(1);\n                if (className !== classInstanceName) {\n                    TronWeb[className] = PluginCls;\n                    this.tronWeb[classInstanceName] = plugin;\n                    result.libs.push(className);\n                }\n            } else {\n                // plug methods into a class, like trx\n                for (const component in pluginInterface.components) {\n                    if (\n                        !Object.prototype.hasOwnProperty.call(\n                            this.tronWeb,\n                            component,\n                        )\n                    )\n                        continue;\n\n                    const methods = pluginInterface.components[component];\n                    const pluginNoOverride =\n                        this.tronWeb[component].pluginNoOverride || [];\n                    for (const method in methods) {\n                        if (\n                            method === 'constructor' ||\n                            (this.tronWeb[component][method] &&\n                                // blacklisted methods\n                                (pluginNoOverride.includes(method) ||\n                                    // private methods\n                                    /^_/.test(method)))\n                        ) {\n                            result.skipped.push(method);\n                            continue;\n                        }\n                        this.tronWeb[component][method] = methods[method].bind(\n                            this.tronWeb[component],\n                        );\n                        result.plugged.push(method);\n                    }\n                }\n            }\n        else\n            throw new Error(\n                'The plugin is not compatible with this version of TronWeb',\n            );\n\n        return result;\n    }\n}\n","import TronWeb from '..';\nimport utils from '../utils';\n\ninterface IOperatorBase {\n    msg?: string;\n    value?: any;\n    optional?: boolean;\n}\nexport type IUnaryOperator = IOperatorBase &\n    (\n        | {\n              name: string;\n              type:\n                  | 'address'\n                  | 'positive-integer'\n                  | 'tokenId'\n                  | 'notEmptyObject'\n                  | 'resource'\n                  | 'url'\n                  | 'hex'\n                  | 'array'\n                  | 'not-empty-string'\n                  | 'boolean';\n          }\n        | {\n              name: string;\n              type: 'integer' | 'string';\n              gt?: number;\n              lt?: number;\n              gte?: number;\n              lte?: number;\n          }\n    );\nexport type IBinaryOperator = IOperatorBase & {\n    msg: string;\n    type: 'notEqual';\n    names: [string, string];\n};\nexport type IOperator = IUnaryOperator | IBinaryOperator;\n\nfunction compare(\n    value: number,\n    opts: {gt?: number; gte?: number; lt?: number; lte?: number},\n) {\n    const {gt, lt, gte, lte} = opts;\n    return !(\n        (typeof gt === 'number' && value <= gt) ||\n        (typeof lt === 'number' && value >= lt) ||\n        (typeof gte === 'number' && value < gte) ||\n        (typeof lte === 'number' && value > lte)\n    );\n}\n\nexport default class Validator {\n    tronWeb: TronWeb;\n\n    constructor(tronWeb: TronWeb) {\n        if (!tronWeb || !(tronWeb instanceof TronWeb))\n            throw new Error('Expected instance of TronWeb');\n        this.tronWeb = tronWeb;\n    }\n\n    invalid(param: IOperator): string {\n        if (!('name' in param)) return param.msg;\n\n        return (\n            param.msg ||\n            `Invalid ${param.name}${\n                param.type === 'address' ? ' address' : ''\n            } provided`\n        );\n    }\n\n    notPositive(param: IUnaryOperator): string {\n        return `${param.name} must be a positive integer`;\n    }\n\n    notEqual(param: IBinaryOperator): string {\n        return (\n            param.msg ||\n            `${param.names[0]} can not be equal to ${param.names[1]}`\n        );\n    }\n\n    notValid(params: IOperator[] = [], callback = new Function()) {\n        const normalized: {[key: string]: any} = {};\n        let no = false;\n        for (const param of params) {\n            const {value, type, optional} = param;\n            if (\n                optional &&\n                (!utils.isNotNullOrUndefined(value) ||\n                    (type !== 'boolean' && value === false))\n            )\n                continue;\n\n            if ('name' in param) normalized[param.name] = value;\n\n            switch (param.type) {\n                case 'address':\n                    if (!this.tronWeb.isAddress(value)) no = true;\n                    else\n                        normalized[param.name] =\n                            this.tronWeb.address.toHex(value);\n\n                    break;\n\n                case 'integer': {\n                    if (!utils.isInteger(value) || !compare(value, param))\n                        no = true;\n                    break;\n                }\n                case 'positive-integer':\n                    if (!utils.isInteger(value) || value <= 0) {\n                        callback(this.notPositive(param));\n                        return;\n                    }\n                    break;\n\n                case 'tokenId':\n                    if (!utils.isString(value) || !value.length) no = true;\n                    break;\n\n                case 'notEmptyObject':\n                    if (!utils.isObject(value) || !Object.keys(value).length)\n                        no = true;\n                    break;\n\n                case 'notEqual':\n                    if (\n                        normalized[param.names[0]] ===\n                        normalized[param.names[1]]\n                    ) {\n                        callback(this.notEqual(param));\n                        return true;\n                    }\n                    break;\n\n                case 'resource':\n                    if (!['BANDWIDTH', 'ENERGY'].includes(value)) no = true;\n                    break;\n\n                case 'url':\n                    if (!utils.isValidURL(value)) no = true;\n\n                    break;\n\n                case 'hex':\n                    if (!utils.isHex(value)) no = true;\n\n                    break;\n\n                case 'array':\n                    if (!Array.isArray(value)) no = true;\n                    break;\n\n                case 'not-empty-string':\n                    if (!utils.isString(value) || !value.length) no = true;\n                    break;\n\n                case 'boolean':\n                    if (!utils.isBoolean(value)) no = true;\n                    break;\n                case 'string': {\n                    if (!utils.isString(value) || !compare(value.length, param))\n                        no = true;\n                    break;\n                }\n                default: {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    const _exhaustiveCheck: never = param;\n                }\n            }\n            if (no) {\n                callback(this.invalid(param));\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","import BigNumber from 'bignumber.js';\nimport injectpromise from 'injectpromise';\n\nimport TronWeb from '..';\nimport Validator from '../paramValidator';\nimport type _CallbackT from '../utils/typing';\nimport type {IMethodSendOptions} from './contract';\nimport {HttpProvider} from './providers';\nimport type {ITransaction} from './transactionBuilder';\nimport type {ITransactionInfo, MakeSigned} from './trx';\n\n// ! This file shows [almost] proper overloads for\n// - methods accepting callback\n\nexport type IChainOptions = {\n    mainGatewayAddress: string;\n    sideGatewayAddress: string;\n    sideChainId: string;\n} & (\n    | {fullHost: string}\n    | {\n          fullNode: HttpProvider | string;\n          solidityNode: HttpProvider | string;\n          eventServer?: HttpProvider | string;\n      }\n);\n\nconst INVALID_TX_MESSAGE = 'Invalid transaction provided';\n\nexport default class SideChain<T extends TronWeb> {\n    mainchain: T;\n    sidechain: TronWeb;\n    isAddress: TronWeb['isAddress'];\n    utils: TronWeb['utils'];\n    injectPromise: injectpromise;\n    validator: Validator;\n\n    mainGatewayAddress!: string;\n    sideGatewayAddress!: string;\n    chainId!: string;\n\n    constructor(\n        sideOptions: IChainOptions,\n        TronWebCls: typeof TronWeb,\n        mainchain: T,\n        privateKey: string,\n    ) {\n        this.mainchain = mainchain;\n        const {mainGatewayAddress, sideGatewayAddress, sideChainId} =\n            sideOptions;\n        if ('fullHost' in sideOptions)\n            this.sidechain = new TronWebCls(\n                sideOptions.fullHost,\n                sideOptions.fullHost,\n                sideOptions.fullHost,\n                privateKey,\n            );\n        else\n            this.sidechain = new TronWebCls(\n                sideOptions.fullNode,\n                sideOptions.solidityNode,\n                sideOptions.eventServer,\n                privateKey,\n            );\n        this.isAddress = this.mainchain.isAddress;\n        this.utils = this.mainchain.utils;\n        this.setMainGatewayAddress(mainGatewayAddress);\n        this.setSideGatewayAddress(sideGatewayAddress);\n        this.setChainId(sideChainId);\n        this.injectPromise = injectpromise(this);\n        this.validator = new Validator(this.sidechain);\n\n        const self = this;\n        // @ts-ignore\n        this.sidechain.trx.sign = (...args) => {\n            // @ts-ignore\n            return self.sign(...args);\n        };\n        // @ts-ignore\n        this.sidechain.trx.multiSign = (...args) => {\n            // @ts-ignore\n            return self.multiSign(...args);\n        };\n    }\n\n    // TODO: this and two next must be setters\n    setMainGatewayAddress(mainGatewayAddress) {\n        if (!this.isAddress(mainGatewayAddress))\n            throw new Error('Invalid main gateway address provided');\n        this.mainGatewayAddress = mainGatewayAddress;\n    }\n\n    setSideGatewayAddress(sideGatewayAddress) {\n        if (!this.isAddress(sideGatewayAddress))\n            throw new Error('Invalid side gateway address provided');\n        this.sideGatewayAddress = sideGatewayAddress;\n    }\n\n    setChainId(sideChainId) {\n        if (!this.utils.isString(sideChainId) || !sideChainId)\n            throw new Error('Invalid side chainId provided');\n        this.chainId = sideChainId;\n    }\n\n    signTransaction<T extends ITransaction>(\n        priKeyBytes: string | Uint8Array | Buffer | number[],\n        transaction: T,\n    ): MakeSigned<T> {\n        if (typeof priKeyBytes === 'string')\n            priKeyBytes = this.utils.code.hexStr2byteArray(priKeyBytes);\n\n        const chainIdByteArr = this.utils.code.hexStr2byteArray(this.chainId);\n\n        const _byteArr = this.utils.code.hexStr2byteArray(transaction.txID);\n        // We're doing this once only, so performance effect is low\n        const byteArr = new Uint8Array([..._byteArr, ...chainIdByteArr]);\n        const byteArrHash = this.sidechain.utils.ethersUtils.sha256(byteArr);\n\n        // eslint-disable-next-line new-cap\n        const signature = this.utils.crypto.ECKeySign(\n            this.utils.code.hexStr2byteArray(byteArrHash.replace(/^0x/, '')),\n            priKeyBytes,\n        );\n\n        if (Array.isArray(transaction.signature)) {\n            if (!transaction.signature.includes(signature))\n                transaction.signature.push(signature);\n        } else {\n            transaction.signature = [signature];\n        }\n        return transaction as MakeSigned<T>;\n    }\n\n    async multiSign(\n        transaction: ITransaction,\n        privateKey?: string,\n        permissionId?: number,\n        callback?: undefined,\n    ): Promise<MakeSigned<ITransaction>>;\n    async multiSign(\n        transaction: ITransaction,\n        privateKey: string | undefined,\n        permissionId: number | undefined | null,\n        callback?: _CallbackT<MakeSigned<ITransaction>>,\n    ): Promise<void>;\n    async multiSign(\n        transaction: ITransaction,\n        privateKey: string = this.sidechain.defaultPrivateKey,\n        permissionId?: number,\n        callback?: _CallbackT<MakeSigned<ITransaction>>,\n    ): Promise<void | MakeSigned<ITransaction>> {\n        if (!callback)\n            return this.injectPromise(\n                this.multiSign,\n                transaction,\n                privateKey,\n                permissionId,\n            );\n\n        if (\n            !this.utils.isObject(transaction) ||\n            !transaction.raw_data ||\n            !transaction.raw_data.contract\n        )\n            return callback(INVALID_TX_MESSAGE);\n\n        if (\n            !transaction.raw_data.contract[0].Permission_id &&\n            permissionId &&\n            permissionId > 0\n        ) {\n            // set permission id\n            transaction.raw_data.contract[0].Permission_id = permissionId;\n\n            // check if private key insides permission list\n            const address = this.sidechain.address\n                .toHex(this.sidechain.address.fromPrivateKey(privateKey))\n                .toLowerCase();\n            const signWeight = await this.sidechain.trx.getSignWeight(\n                transaction,\n                permissionId,\n            );\n\n            if (signWeight.result.code === 'PERMISSION_ERROR')\n                return callback(signWeight.result.message);\n\n            let foundKey = false;\n            if (signWeight.permission)\n                signWeight.permission.keys.map((key) => {\n                    if (key.address === address) foundKey = true;\n                });\n\n            if (!foundKey)\n                return callback(privateKey + ' has no permission to sign');\n\n            if (\n                signWeight.approved_list &&\n                signWeight.approved_list.indexOf(address) !== -1\n            )\n                return callback(privateKey + ' already sign transaction');\n\n            // reset transaction\n            if (signWeight.transaction && signWeight.transaction.transaction) {\n                transaction = signWeight.transaction.transaction;\n                transaction.raw_data.contract[0].Permission_id = permissionId;\n            } else {\n                return callback(INVALID_TX_MESSAGE);\n            }\n        }\n        // sign\n        try {\n            return callback(\n                null,\n                this.signTransaction(privateKey, transaction),\n            );\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey?: string,\n        useTronHeader?: boolean,\n        multisig?: boolean,\n        callback?: undefined,\n    ): Promise<MakeSigned<T>>;\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey: string,\n        useTronHeader: boolean,\n        multisig: boolean,\n        callback: _CallbackT<MakeSigned<T>>,\n    ): Promise<void>;\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey: string = this.sidechain.defaultPrivateKey,\n        useTronHeader = true,\n        multisig = false,\n        callback?: _CallbackT<MakeSigned<T>>,\n    ): Promise<void | MakeSigned<T>> {\n        if (!callback)\n            return this.injectPromise(\n                this.sign,\n                transaction,\n                privateKey,\n                useTronHeader,\n                multisig,\n            );\n\n        // Message signing\n        if (this.utils.isString(transaction)) {\n            if (!this.utils.isHex(transaction))\n                return callback('Expected hex message input');\n\n            try {\n                const signatureHex = this.sidechain.trx.signString(\n                    transaction,\n                    privateKey,\n                    useTronHeader,\n                );\n                return callback(null, signatureHex as MakeSigned<T>);\n            } catch (ex) {\n                callback(ex);\n            }\n            return;\n        }\n\n        if (!this.utils.isObject(transaction))\n            return callback(INVALID_TX_MESSAGE);\n\n        if (!multisig && (transaction as ITransaction).signature)\n            return callback('Transaction is already signed');\n\n        try {\n            if (!multisig) {\n                const address = this.sidechain.address\n                    .toHex(this.sidechain.address.fromPrivateKey(privateKey))\n                    .toLowerCase();\n                if (\n                    address !==\n                    this.sidechain.address.toHex(\n                        transaction.raw_data.contract[0].parameter.value\n                            .owner_address,\n                    )\n                )\n                    return callback(\n                        'Private key does not match address in transaction',\n                    );\n            }\n            return callback(\n                null,\n                this.signTransaction(privateKey, transaction) as MakeSigned<T>,\n            );\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    /**\n     * deposit asset to sidechain\n     */\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.depositTrx,\n                callValue,\n                depositFee,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'callValue',\n                        type: 'integer',\n                        value: callValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'depositFee',\n                        type: 'integer',\n                        value: depositFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            callValue: Number(callValue) + Number(depositFee),\n            feeLimit,\n            ...options,\n        };\n        try {\n            const contractInstance = await this.mainchain\n                .contract()\n                .at(this.mainGatewayAddress);\n            const result = await contractInstance\n                .depositTRX()\n                .send(options, privateKey);\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.depositTrc10,\n                tokenId,\n                tokenValue,\n                depositFee,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'tokenValue',\n                        type: 'integer',\n                        value: tokenValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'depositFee',\n                        type: 'integer',\n                        value: depositFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                    {\n                        name: 'tokenId',\n                        type: 'integer',\n                        value: tokenId,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            tokenId,\n            tokenValue,\n            feeLimit,\n            ...options,\n            callValue: depositFee,\n        };\n        try {\n            const contractInstance = await this.mainchain\n                .contract()\n                .at(this.mainGatewayAddress);\n            const result = await contractInstance\n                .depositTRC10(tokenId, tokenValue)\n                .send(options, privateKey);\n            callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.depositTrc,\n                functionSelector,\n                num,\n                fee,\n                feeLimit,\n                contractAddress,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'functionSelector',\n                        type: 'not-empty-string',\n                        value: functionSelector,\n                    },\n                    {\n                        name: 'num',\n                        type: 'integer',\n                        value: num,\n                        gte: 0,\n                    },\n                    {\n                        name: 'fee',\n                        type: 'integer',\n                        value: fee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                    {\n                        name: 'contractAddress',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            feeLimit,\n            ...options,\n            callValue: fee,\n            tokenId: '',\n            tokenValue: 0,\n        };\n        try {\n            let result = null;\n            if (functionSelector === 'approve') {\n                const approveInstance = await this.mainchain\n                    .contract()\n                    .at(contractAddress);\n                result = await approveInstance\n                    .approve(this.mainGatewayAddress, num)\n                    .send(options, privateKey);\n            } else {\n                const contractInstance = await this.mainchain\n                    .contract()\n                    .at(this.mainGatewayAddress);\n                switch (functionSelector) {\n                    case 'depositTRC20':\n                    case 'depositTRC721':\n                        result = await contractInstance[functionSelector](\n                            contractAddress,\n                            num,\n                        ).send(options, privateKey);\n                        break;\n                    case 'retryDeposit':\n                    case 'retryMapping':\n                        result = await contractInstance[functionSelector](\n                            num,\n                        ).send(options, privateKey);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'approve';\n        return this.depositTrc(\n            functionSelector,\n            num,\n            0,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async approveTrc721(\n        id: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'approve';\n        return this.depositTrc(\n            functionSelector,\n            id,\n            0,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'depositTRC20';\n        return this.depositTrc(\n            functionSelector,\n            num,\n            depositFee,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    depositTrc721: this['depositTrc20'] = async (\n        id: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> => {\n        const functionSelector = 'depositTRC721';\n        return this.depositTrc(\n            functionSelector,\n            id,\n            depositFee,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    };\n\n    /**\n     * mapping asset TRC20 or TRC721 to DAppChain\n     */\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.mappingTrc,\n                trxHash,\n                mappingFee,\n                feeLimit,\n                functionSelector,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'trxHash',\n                        type: 'not-empty-string',\n                        value: trxHash,\n                    },\n                    {\n                        name: 'mappingFee',\n                        type: 'integer',\n                        value: mappingFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        trxHash = trxHash.startsWith('0x') ? trxHash : '0x' + trxHash;\n        options = {\n            feeLimit,\n            ...options,\n            callValue: mappingFee,\n        };\n        try {\n            const contractInstance = await this.mainchain\n                .contract()\n                .at(this.mainGatewayAddress);\n            let result = null;\n            if (functionSelector === 'mappingTRC20')\n                result = await contractInstance\n                    .mappingTRC20(trxHash)\n                    .send(options, privateKey);\n            else if (functionSelector === 'mappingTRC721')\n                result = await contractInstance\n                    .mappingTRC721(trxHash)\n                    .send(options, privateKey);\n            else callback(new Error('type must be trc20 or trc721'));\n\n            callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'mappingTRC20';\n        return this.mappingTrc(\n            trxHash,\n            mappingFee,\n            feeLimit,\n            functionSelector,\n            options,\n            privateKey,\n            callback,\n        );\n    }\n\n    mappingTrc721: this['mappingTrc20'] = async (\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> => {\n        const functionSelector = 'mappingTRC721';\n        return this.mappingTrc(\n            trxHash,\n            mappingFee,\n            feeLimit,\n            functionSelector,\n            options,\n            privateKey,\n            callback,\n        );\n    };\n\n    /**\n     * withdraw trx from sidechain to mainchain\n     */\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawTrx,\n                callValue,\n                withdrawFee,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'callValue',\n                        type: 'integer',\n                        value: callValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'withdrawFee',\n                        type: 'integer',\n                        value: withdrawFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            callValue: Number(callValue) + Number(withdrawFee),\n            feeLimit,\n            ...options,\n        };\n        try {\n            const contractInstance = await this.sidechain\n                .contract()\n                .at(this.sideGatewayAddress);\n            const result = await contractInstance\n                .withdrawTRX()\n                .send(options, privateKey);\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawTrc10,\n                tokenId,\n                tokenValue,\n                withdrawFee,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'tokenId',\n                        type: 'integer',\n                        value: tokenId,\n                        gte: 0,\n                    },\n                    {\n                        name: 'tokenValue',\n                        type: 'integer',\n                        value: tokenValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'withdrawFee',\n                        type: 'integer',\n                        value: withdrawFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            tokenValue,\n            tokenId,\n            callValue: withdrawFee,\n            feeLimit,\n            ...options,\n        };\n        try {\n            const contractInstance = await this.sidechain\n                .contract()\n                .at(this.sideGatewayAddress);\n            const result = await contractInstance\n                .withdrawTRC10(tokenId, tokenValue)\n                .send(options, privateKey);\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawTrc,\n                functionSelector,\n                numOrId,\n                withdrawFee,\n                feeLimit,\n                contractAddress,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'functionSelector',\n                        type: 'not-empty-string',\n                        value: functionSelector,\n                    },\n                    {\n                        name: 'numOrId',\n                        type: 'integer',\n                        value: numOrId,\n                        gte: 0,\n                    },\n                    {\n                        name: 'withdrawFee',\n                        type: 'integer',\n                        value: withdrawFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                    {\n                        name: 'contractAddress',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            feeLimit,\n            ...options,\n            callValue: withdrawFee,\n        };\n\n        const contract = this.sidechain.contract(\n            [\n                {\n                    name: functionSelector.split('(')[0],\n                    type: 'function',\n                    stateMutability: 'nonpayable',\n                    inputs: [{type: 'uint256', name: ''}],\n                    outputs: [],\n                },\n            ],\n            contractAddress,\n        );\n        const method = contract.methods[functionSelector];\n        return (await method(numOrId).send(\n            options,\n            privateKey,\n            callback,\n        )) as void;\n    }\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrc20(\n        num: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        return this.withdrawTrc(\n            'withdrawal(uint256)',\n            num,\n            withdrawFee,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrc721(\n        id: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        return this.withdrawTrc(\n            'withdrawal(uint256)',\n            id,\n            withdrawFee,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    async injectFund(\n        num: number,\n        feeLimit: number,\n        options?: unknown,\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async injectFund(\n        num: number,\n        feeLimit: number,\n        options: unknown,\n        privateKey: string,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n    async injectFund(\n        num: number,\n        feeLimit: number,\n        options: unknown = 'UNUSED (LEGACY?) ARGUMENT',\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<string>,\n    ): Promise<void | string> {\n        if (!callback)\n            return this.injectPromise(\n                this.injectFund,\n                num,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'num',\n                        type: 'integer',\n                        value: num,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        try {\n            const address = this.sidechain.address.fromPrivateKey(privateKey);\n            const hexAddress = this.sidechain.address.toHex(address);\n            const transaction = await this.sidechain.fullNode.request(\n                '/wallet/fundinject',\n                {\n                    owner_address: hexAddress,\n                    amount: num,\n                },\n                'post',\n            );\n\n            const signedTransaction = await this.sidechain.trx.sign(\n                transaction,\n                privateKey,\n            );\n\n            if (!signedTransaction.signature) {\n                if (!privateKey)\n                    return callback('Transaction was not signed properly');\n\n                return callback('Invalid private key provided');\n            }\n\n            const broadcast = await this.sidechain.trx.sendRawTransaction(\n                signedTransaction,\n            );\n            if (broadcast.code) {\n                const err = {\n                    error: broadcast.code,\n                    message: broadcast.code,\n                };\n                if (broadcast.message)\n                    err.message = this.mainchain.toUtf8(broadcast.message);\n                return callback(err);\n            }\n            return callback(null, signedTransaction.txID);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'retryWithdraw(uint256)';\n        return this.withdrawTrc(\n            functionSelector,\n            nonce,\n            retryFee,\n            feeLimit,\n            this.sideGatewayAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    retryDeposit: this['retryWithdraw'] = async (\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> => {\n        const functionSelector = 'retryDeposit';\n        return this.depositTrc(\n            functionSelector,\n            nonce,\n            retryFee,\n            feeLimit,\n            this.mainGatewayAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    };\n\n    retryMapping: this['retryWithdraw'] = async (\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> => {\n        const functionSelector = 'retryMapping';\n        return this.depositTrc(\n            functionSelector,\n            nonce,\n            retryFee,\n            feeLimit,\n            this.mainGatewayAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    };\n}\n","/* eslint-disable */\n\nexport const protobufPackage = 'protocol';\n\nexport const ResourceCode = {\n    BANDWIDTH: 'BANDWIDTH',\n    ENERGY: 'ENERGY',\n    TRON_POWER: 'TRON_POWER',\n} as const;\n\nexport type ResourceCode = typeof ResourceCode[keyof typeof ResourceCode];\n","import TronWeb from '..';\nimport {WithTronwebAndInjectpromise} from '../../src/utils/_base';\nimport Validator from '../paramValidator';\nimport type {\n    AccountResourceMessage as IAccountResource,\n    BlockExtention as IBlockExtention,\n    TransactionSignWeight as ISignWeight,\n    TransactionApprovedList as ITransactionApprovedList,\n    TransactionExtention as ITransactionExtention,\n} from '../proto/api/api';\nimport type {\n    Account as IAccount,\n    ChainParameters_ChainParameter as IChainParameter,\n    Exchange as IExchange,\n    NodeInfo as INodeInfo,\n    Proposal as IProposal,\n    TransactionInfo as ITransactionInfo,\n    Witness as IWitness,\n} from '../proto/core/Tron';\nimport type {AssetIssueContract as IToken} from '../proto/core/contract/asset_issue_contract';\nimport {ResourceCode as ResourceT} from '../proto/core/contract/common';\nimport type {SmartContract as ISmartContract} from '../proto/core/contract/smart_contract';\nimport utils from '../utils';\nimport {ADDRESS_PREFIX} from '../utils/address';\nimport type {SomeBytes} from '../utils/bytes';\nimport type {TypedDataTypes} from '../utils/crypto';\nimport {\n    SigningKey,\n    keccak256,\n    recoverAddress,\n    toUtf8Bytes,\n} from '../utils/ethersUtils';\nimport type {IDomain} from '../utils/typedData';\nimport type _CallbackT from '../utils/typing';\nimport type {\n    ISignedTransaction,\n    Transaction as ITransaction,\n} from './transactionBuilder';\n\nexport {ResourceCode as ResourceT} from '../proto/core/contract/common';\n\nconst TRX_MESSAGE_HEADER = '\\x19TRON Signed Message:\\n32';\n// it should be: '\\x15TRON Signed Message:\\n32';\nconst ETH_MESSAGE_HEADER = '\\x19Ethereum Signed Message:\\n32';\n\nexport type BlockT = number | 'latest' | 'earliest' | string;\n\nexport type {\n    Block as IBlock,\n    TransactionInfo_Log as ILog,\n    TransactionInfo as ITransactionInfo,\n    Account as IAccount,\n    Proposal as IProposal,\n    Exchange as IExchange,\n    Witness as IWitness,\n    ChainParameters_ChainParameter as IChainParameter,\n    NodeInfo as INodeInfo,\n} from '../proto/core/Tron';\n\nexport type {\n    TransactionExtention as ITransactionExtention,\n    TransactionSignWeight as ISignWeight,\n    BlockExtention as IBlockExtention,\n    TransactionApprovedList as ITransactionApprovedList,\n    AccountResourceMessage as IAccountResource,\n} from '../proto/api/api';\nexport type {SmartContract as ISmartContract} from '../proto/core/contract/smart_contract';\nexport type {AssetIssueContract as IToken} from '../proto/core/contract/asset_issue_contract';\n\nexport type MakeSigned<T> = T extends string ? T : T & {signature: string[]};\n\nexport type IBroadcastResult = {\n    code: string;\n    message: string;\n} & (\n    | {result: true; transaction: ISignedTransaction; txid: string}\n    | {result: false}\n);\nexport type IBroadcastHexResult = {\n    code: string;\n    message: string;\n} & (\n    | {result: true; transaction: ISignedTransaction; hexTransaction: string}\n    | {result: false}\n);\n\nexport interface IAddressOrPk {\n    privateKey?: string;\n    address?: string;\n}\n\nfunction toHex(value: string): string {\n    return TronWeb.address.toHex(value);\n}\n\nconst INVALID_ADDRESS_MSG = 'Invalid address provided';\nconst INVALID_TOKEN_ID_MSG = 'Invalid token ID provided';\nconst TOKEN_DOES_NOT_EXIST_MSG = 'Token does not exist';\nconst INVALID_TRANSACTION_MSG = 'Invalid transaction provided';\nconst INVALID_AMOUNT_MSG = 'Invalid amount provided';\nconst NEED_PK_OR_ADDRESS_MSG =\n    'Function requires either a private key or address to be set';\n\nexport default class Trx extends WithTronwebAndInjectpromise {\n    cache: {contracts: Record<string, ISmartContract>};\n    validator: Validator;\n\n    constructor(tronWeb: TronWeb) {\n        super(tronWeb);\n        this.cache = {\n            contracts: {},\n        };\n        this.validator = new Validator(tronWeb);\n    }\n\n    _parseToken(token: IToken): IToken {\n        return {\n            ...token,\n            name: this.tronWeb.toUtf8(token.name),\n            abbr: token.abbr && this.tronWeb.toUtf8(token.abbr),\n            description:\n                token.description && this.tronWeb.toUtf8(token.description),\n            url: token.url && this.tronWeb.toUtf8(token.url),\n        };\n    }\n\n    getCurrentBlock(callback?: undefined): Promise<IBlockExtention>;\n    getCurrentBlock(callback: _CallbackT<IBlockExtention>): void;\n    getCurrentBlock(\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback) return this.injectPromise(this.getCurrentBlock);\n        this.tronWeb.fullNode\n            .request('wallet/getnowblock')\n            .then((block) => {\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getConfirmedCurrentBlock(callback?: undefined): Promise<IBlockExtention>;\n    getConfirmedCurrentBlock(callback: _CallbackT<IBlockExtention>): void;\n    getConfirmedCurrentBlock(\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback) return this.injectPromise(this.getConfirmedCurrentBlock);\n        this.tronWeb.solidityNode\n            .request('walletsolidity/getnowblock')\n            .then((block) => {\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBlock(\n        block?: BlockT | null,\n        callback?: undefined,\n    ): Promise<IBlockExtention>;\n    getBlock(\n        block: BlockT | null | undefined,\n        callback: _CallbackT<IBlockExtention>,\n    ): void;\n    getBlock(\n        block: BlockT | null = this.tronWeb.defaultBlock,\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback) return this.injectPromise(this.getBlock, block);\n\n        if (block === null) return callback('No block identifier provided');\n\n        if (block === 'earliest') block = 0;\n        if (block === 'latest') return this.getCurrentBlock(callback);\n\n        // TODO: can we drop this weird isNaN for string?..\n        // if (isNaN(block as any as number) && utils.isHex(block))\n        if (utils.isHex(block)) return this.getBlockByHash(block, callback);\n\n        this.getBlockByNumber(block, callback);\n    }\n\n    getBlockByHash(\n        blockHash: string,\n        callback?: undefined,\n    ): Promise<IBlockExtention>;\n    getBlockByHash(\n        blockHash: string,\n        callback: _CallbackT<IBlockExtention>,\n    ): void;\n    getBlockByHash(\n        blockHash: string,\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback)\n            return this.injectPromise(this.getBlockByHash, blockHash);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getblockbyid',\n                {\n                    value: blockHash,\n                },\n                'post',\n            )\n            .then((block) => {\n                if (!Object.keys(block).length)\n                    return callback('Block not found');\n\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBlockByNumber(\n        blockID: number,\n        callback?: undefined,\n    ): Promise<IBlockExtention>;\n    getBlockByNumber(\n        blockID: number,\n        callback: _CallbackT<IBlockExtention>,\n    ): void;\n    getBlockByNumber(\n        blockID: number,\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback)\n            return this.injectPromise(this.getBlockByNumber, blockID);\n\n        if (!utils.isInteger(blockID) || blockID < 0)\n            return callback('Invalid block number provided');\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getblockbynum',\n                {num: parseInt(blockID.toString())},\n                'post',\n            )\n            .then((block) => {\n                if (!Object.keys(block).length)\n                    return callback('Block not found');\n\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBlockTransactionCount(\n        block?: BlockT | null | undefined,\n    ): Promise<number>;\n    getBlockTransactionCount(\n        block: BlockT | null | undefined,\n        callback: _CallbackT<number>,\n    ): void;\n    getBlockTransactionCount(\n        block: BlockT | null = this.tronWeb.defaultBlock,\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback)\n            return this.injectPromise(this.getBlockTransactionCount, block);\n\n        this.getBlock(block)\n            .then(({transactions = []}) => {\n                callback(null, transactions.length);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTransactionFromBlock(block?: BlockT | null): Promise<ITransaction[]>;\n    getTransactionFromBlock(\n        block: BlockT | null | undefined,\n        index: number,\n    ): Promise<ITransaction>;\n    getTransactionFromBlock(\n        block: BlockT | null | undefined,\n        index: null | undefined,\n        callback: _CallbackT<ITransaction[]>,\n    ): void;\n    getTransactionFromBlock(\n        block: BlockT | null | undefined,\n        index: number,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    getTransactionFromBlock(\n        block: BlockT | null = this.tronWeb.defaultBlock,\n        index?: number | null,\n        callback?: _CallbackT<ITransaction> | _CallbackT<ITransaction[]>,\n    ): void | Promise<ITransaction> | Promise<ITransaction[]> {\n        if (!callback)\n            return this.injectPromise(\n                this.getTransactionFromBlock,\n                block,\n                index,\n            );\n\n        this.getBlock(block)\n            .then(({transactions}) => {\n                if (!transactions) callback('Transaction not found in block');\n                else if (typeof index === 'number')\n                    if (index >= 0 && index < transactions.length)\n                        callback(null, transactions[index] as any);\n                    else callback('Invalid transaction index provided');\n                else callback(null, transactions as any);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTransaction(\n        transactionID: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    getTransaction(\n        transactionID: string,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    getTransaction(\n        transactionID: string,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.getTransaction, transactionID);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/gettransactionbyid',\n                {value: transactionID},\n                'post',\n            )\n            .then((transaction) => {\n                if (!Object.keys(transaction).length)\n                    return callback('Transaction not found');\n\n                callback(null, transaction);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getConfirmedTransaction(\n        transactionID: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    getConfirmedTransaction(\n        transactionID: string,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    getConfirmedTransaction(\n        transactionID: string,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.getConfirmedTransaction,\n                transactionID,\n            );\n\n        this.tronWeb.solidityNode\n            .request(\n                'walletsolidity/gettransactionbyid',\n                {value: transactionID},\n                'post',\n            )\n            .then((transaction) => {\n                if (!Object.keys(transaction).length)\n                    return callback('Transaction not found');\n\n                callback(null, transaction);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getUnconfirmedTransaction(\n        transactionID: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    getUnconfirmedTransaction(\n        transactionID: string,\n        callback: _CallbackT<ITransactionInfo>,\n    ): void;\n    getUnconfirmedTransaction(\n        transactionID: string,\n        callback?: _CallbackT<ITransactionInfo>,\n    ): void | Promise<ITransactionInfo> {\n        return this._getTransactionInfoById(\n            transactionID,\n            {confirmed: false},\n            callback as any,\n        );\n    }\n\n    getTransactionInfo(\n        transactionID: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    getTransactionInfo(\n        transactionID: string,\n        callback: _CallbackT<ITransactionInfo>,\n    ): void;\n    getTransactionInfo(\n        transactionID: string,\n        callback?: _CallbackT<ITransactionInfo>,\n    ): void | Promise<ITransactionInfo> {\n        return this._getTransactionInfoById(\n            transactionID,\n            {confirmed: true},\n            callback as any,\n        );\n    }\n\n    _getTransactionInfoById(\n        transactionID: string,\n        options: {confirmed: boolean},\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    _getTransactionInfoById(\n        transactionID: string,\n        options: {confirmed: boolean},\n        callback: _CallbackT<ITransactionInfo>,\n    ): void;\n    _getTransactionInfoById(\n        transactionID: string,\n        options: {confirmed: boolean},\n        callback?: _CallbackT<ITransactionInfo>,\n    ): void | Promise<ITransactionInfo> {\n        if (!callback)\n            return this.injectPromise(\n                this._getTransactionInfoById,\n                transactionID,\n                options,\n            );\n\n        if (options.confirmed)\n            this.tronWeb.solidityNode\n                .request(\n                    'wallet/gettransactioninfobyid',\n                    {value: transactionID},\n                    'post',\n                )\n                .then((transaction) => {\n                    callback(null, transaction);\n                })\n                .catch((err) => callback(err));\n        else\n            this.tronWeb.fullNode\n                .request(\n                    'walletsolidity/gettransactioninfobyid',\n                    {value: transactionID},\n                    'post',\n                )\n                .then((transaction) => {\n                    callback(null, transaction);\n                })\n                .catch((err) => callback(err));\n    }\n\n    /**\n     * @deprecated This api is no longer supported in the latest version\n     * You can use the central node api: 47.90.247.237:8091/walletextension/gettransactionsfromthis\n     */\n    async getTransactionsToAddress(\n        address?: string,\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<ITransactionExtention[]>;\n    async getTransactionsToAddress(\n        address: string | undefined,\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void>;\n    async getTransactionsToAddress(\n        address: string = this.tronWeb.defaultAddress.hex,\n        limit = 30,\n        offset = 0,\n        callback?: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void | ITransactionExtention[]> {\n        return this.getTransactionsRelated(\n            address,\n            'to',\n            limit,\n            offset,\n            callback as any,\n        );\n    }\n\n    /**\n     * @deprecated This api is no longer supported in the latest version\n     * You can use the central node api: 47.90.247.237:8091/walletextension/gettransactionsfromthis\n     */\n    async getTransactionsFromAddress(\n        address?: string,\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<ITransactionExtention[]>;\n    async getTransactionsFromAddress(\n        address: string | undefined,\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void>;\n    async getTransactionsFromAddress(\n        address: string = this.tronWeb.defaultAddress.hex,\n        limit = 30,\n        offset = 0,\n        callback?: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void | ITransactionExtention[]> {\n        return this.getTransactionsRelated(\n            address,\n            'from',\n            limit,\n            offset,\n            callback as any,\n        );\n    }\n\n    /**\n     * @deprecated This api is no longer supported in the latest version\n     * You can use the central node api: 47.90.247.237:8091/walletextension/gettransactionsfromthis\n     */\n    async getTransactionsRelated(\n        address?: string,\n        direction?: 'all',\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<(ITransactionExtention & {direction: 'to' | 'from'})[]>;\n    async getTransactionsRelated(\n        address?: string,\n        direction?: 'to' | 'from',\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<ITransactionExtention[]>;\n    async getTransactionsRelated(\n        address: string | undefined,\n        direction: 'all' | undefined,\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<\n            (ITransactionExtention & {direction: 'to' | 'from'})[]\n        >,\n    ): Promise<void>;\n    async getTransactionsRelated(\n        address: string | undefined,\n        direction: 'to' | 'from',\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void>;\n    async getTransactionsRelated(\n        address: string = this.tronWeb.defaultAddress.hex,\n        direction: 'all' | 'to' | 'from' = 'all',\n        limit = 30,\n        offset = 0,\n        callback?:\n            | _CallbackT<(ITransactionExtention & {direction: 'to' | 'from'})[]>\n            | _CallbackT<ITransactionExtention[]>,\n    ): Promise<\n        | void\n        | (ITransactionExtention & {direction: 'to' | 'from'})[]\n        | ITransactionExtention[]\n    > {\n        if (!callback)\n            return this.injectPromise(\n                this.getTransactionsRelated,\n                address,\n                direction,\n                limit,\n                offset,\n            );\n\n        if (!['to', 'from', 'all'].includes(direction))\n            return callback(\n                'Invalid direction provided: Expected \"to\", \"from\" or \"all\"',\n            );\n\n        if (direction === 'all')\n            try {\n                const [from, to] = await Promise.all([\n                    this.getTransactionsRelated(address, 'from', limit, offset),\n                    this.getTransactionsRelated(address, 'to', limit, offset),\n                ]);\n\n                return callback(\n                    null,\n                    [\n                        ...from.map((tx: any) => ((tx.direction = 'from'), tx)),\n                        ...to.map((tx: any) => ((tx.direction = 'to'), tx)),\n                    ].sort((a, b) => {\n                        return b.raw_data.timestamp - a.raw_data.timestamp;\n                    }),\n                );\n            } catch (ex) {\n                return callback(ex);\n            }\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        if (!utils.isInteger(limit) || limit < 0 || (offset && limit < 1))\n            return callback('Invalid limit provided');\n\n        if (!utils.isInteger(offset) || offset < 0)\n            return callback('Invalid offset provided');\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.solidityNode\n            .request(\n                `walletextension/gettransactions${direction}this`,\n                {\n                    account: {\n                        address,\n                    } as IAccount,\n                    offset,\n                    limit,\n                },\n                'post',\n            )\n            .then(({transaction}) => {\n                callback(null, transaction as any);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getAccount(address?: string, callback?: undefined): Promise<IAccount>;\n    getAccount(\n        address: string | undefined,\n        callback: _CallbackT<IAccount>,\n    ): void;\n    getAccount(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<IAccount>,\n    ): void | Promise<IAccount> {\n        if (!callback) return this.injectPromise(this.getAccount, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.solidityNode\n            .request('walletsolidity/getaccount', {address} as IAccount, 'post')\n            .then((account) => {\n                callback(null, account);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getAccountById(id: string, callback?: undefined): Promise<IAccount>;\n    getAccountById(id: string, callback: _CallbackT<IAccount>): void;\n    getAccountById(\n        id: string,\n        callback?: _CallbackT<IAccount>,\n    ): void | Promise<IAccount> {\n        if (!callback) return this.injectPromise(this.getAccountById, id);\n        this.getAccountInfoById(id, {confirmed: true}, callback);\n    }\n\n    getAccountInfoById(\n        id: string,\n        options: {confirmed?: boolean} | undefined,\n        callback: _CallbackT<IAccount>,\n    ): void {\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'accountId',\n                        type: 'hex',\n                        value: id,\n                    },\n                    {\n                        name: 'accountId',\n                        type: 'string',\n                        lte: 32,\n                        gte: 8,\n                        value: id,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        if (id.startsWith('0x')) id = id.slice(2);\n\n        if (options && options.confirmed)\n            this.tronWeb.solidityNode\n                .request(\n                    'walletsolidity/getaccountbyid',\n                    {account_id: id} as IAccount,\n                    'post',\n                )\n                .then((account) => {\n                    callback(null, account);\n                })\n                .catch((err) => callback(err));\n        else\n            this.tronWeb.fullNode\n                .request(\n                    'wallet/getaccountbyid',\n                    {account_id: id} as IAccount,\n                    'post',\n                )\n                .then((account) => {\n                    callback(null, account);\n                })\n                .catch((err) => callback(err));\n    }\n\n    getBalance(address?: string, callback?: undefined): Promise<number>;\n    getBalance(address: string, callback: _CallbackT<number>): void;\n    getBalance(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback) return this.injectPromise(this.getBalance, address);\n\n        this.getAccount(address)\n            .then(({balance = 0}) => {\n                callback(null, balance);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getUnconfirmedAccount(\n        address?: string,\n        callback?: undefined,\n    ): Promise<IAccount>;\n    getUnconfirmedAccount(\n        address: string,\n        callback: _CallbackT<IAccount>,\n    ): void;\n    getUnconfirmedAccount(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<IAccount>,\n    ): void | Promise<IAccount> {\n        if (!callback)\n            return this.injectPromise(this.getUnconfirmedAccount, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.fullNode\n            .request('wallet/getaccount', {address} as IAccount, 'post')\n            .then((account) => {\n                callback(null, account);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getUnconfirmedAccountById(\n        id: string,\n        callback?: undefined,\n    ): Promise<IAccount>;\n    getUnconfirmedAccountById(id: string, callback: _CallbackT<IAccount>): void;\n    getUnconfirmedAccountById(\n        id: string,\n        callback?: _CallbackT<IAccount>,\n    ): void | Promise<IAccount> {\n        if (!callback)\n            return this.injectPromise(this.getUnconfirmedAccountById, id);\n        this.getAccountInfoById(id, {confirmed: false}, callback);\n    }\n\n    getUnconfirmedBalance(\n        address?: string,\n        callback?: undefined,\n    ): Promise<number>;\n    getUnconfirmedBalance(address: string, callback: _CallbackT<number>): void;\n    getUnconfirmedBalance(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback)\n            return this.injectPromise(this.getUnconfirmedBalance, address);\n\n        this.getUnconfirmedAccount(address)\n            .then(({balance = 0}) => {\n                callback(null, balance);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBandwidth(address?: string, callback?: undefined): Promise<number>;\n    getBandwidth(address: string, callback: _CallbackT<number>): void;\n    getBandwidth(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback) return this.injectPromise(this.getBandwidth, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.fullNode\n            .request('wallet/getaccountnet', {address} as IAccount, 'post')\n            .then(\n                ({\n                    freeNetUsed = 0,\n                    freeNetLimit = 0,\n                    NetUsed = 0,\n                    NetLimit = 0,\n                }) => {\n                    callback(\n                        null,\n                        freeNetLimit - freeNetUsed + (NetLimit - NetUsed),\n                    );\n                },\n            )\n            .catch((err) => callback(err));\n    }\n\n    getTokensIssuedByAddress(\n        address?: string,\n        callback?: undefined,\n    ): Promise<Record<string, IToken>>;\n    getTokensIssuedByAddress(\n        address: string,\n        callback: _CallbackT<Record<string, IToken>>,\n    ): void;\n    getTokensIssuedByAddress(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<Record<string, IToken>>,\n    ): void | Promise<Record<string, IToken>> {\n        if (!callback)\n            return this.injectPromise(this.getTokensIssuedByAddress, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getassetissuebyaccount',\n                {address} as IAccount,\n                'post',\n            )\n            .then(({assetIssue}) => {\n                if (!assetIssue) return callback(null, {});\n\n                const tokens = assetIssue\n                    .map((token) => this._parseToken(token))\n                    .reduce((tokens, token) => {\n                        return (tokens[token.name] = token), tokens;\n                    }, {} as Record<string, IToken>);\n\n                callback(null, tokens);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTokenFromID(\n        tokenID: string | number,\n        callback?: undefined,\n    ): Promise<IToken>;\n    getTokenFromID(\n        tokenID: string | number,\n        callback: _CallbackT<IToken>,\n    ): void;\n    getTokenFromID(\n        tokenID: string | number,\n        callback?: _CallbackT<IToken>,\n    ): void | Promise<IToken> {\n        if (!callback) return this.injectPromise(this.getTokenFromID, tokenID);\n\n        if (utils.isInteger(tokenID)) tokenID = tokenID.toString();\n\n        if (!utils.isString(tokenID) || !tokenID.length)\n            return callback(INVALID_TOKEN_ID_MSG);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getassetissuebyname',\n                {value: this.tronWeb.fromUtf8(tokenID)},\n                'post',\n            )\n            .then((token) => {\n                if (!token.name) return callback(TOKEN_DOES_NOT_EXIST_MSG);\n\n                callback(null, this._parseToken(token));\n            })\n            .catch((err) => callback(err));\n    }\n\n    listNodes(callback?: undefined): Promise<string[]>;\n    listNodes(callback: _CallbackT<string[]>): void;\n    listNodes(callback?: _CallbackT<string[]>): void | Promise<string[]> {\n        if (!callback) return this.injectPromise(this.listNodes);\n\n        this.tronWeb.fullNode\n            .request('wallet/listnodes')\n            .then(({nodes = []}) => {\n                callback(\n                    null,\n                    nodes.map(\n                        ({address: a}) =>\n                            `${this.tronWeb.toUtf8(a!.host)}:${a!.port}`,\n                    ),\n                );\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBlockRange(\n        start?: number,\n        end?: number,\n        callback?: undefined,\n    ): Promise<IBlockExtention[]>;\n    getBlockRange(\n        start: number | undefined,\n        end: number | undefined,\n        callback: _CallbackT<IBlockExtention[]>,\n    ): void;\n    getBlockRange(\n        start = 0,\n        end = 30,\n        callback?: _CallbackT<IBlockExtention[]>,\n    ): void | Promise<IBlockExtention[]> {\n        if (!callback)\n            return this.injectPromise(this.getBlockRange, start, end);\n\n        if (!utils.isInteger(start) || start < 0)\n            return callback('Invalid start of range provided');\n\n        if (!utils.isInteger(end) || end <= start)\n            return callback('Invalid end of range provided');\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getblockbylimitnext',\n                {\n                    startNum: parseInt(start.toString()),\n                    endNum: parseInt(end.toString()) + 1,\n                },\n                'post',\n            )\n            .then(({block = []}) => {\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    listSuperRepresentatives(callback?: undefined): Promise<IWitness[]>;\n    listSuperRepresentatives(callback: _CallbackT<IWitness[]>): void;\n    listSuperRepresentatives(\n        callback?: _CallbackT<IWitness[]>,\n    ): void | Promise<IWitness[]> {\n        if (!callback) return this.injectPromise(this.listSuperRepresentatives);\n\n        this.tronWeb.fullNode\n            .request('wallet/listwitnesses')\n            .then(({witnesses = []}) => {\n                callback(null, witnesses);\n            })\n            .catch((err) => callback(err));\n    }\n\n    listTokens(\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<IToken[]>;\n    listTokens(\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<IToken[]>,\n    ): void;\n    listTokens(\n        limit = 0,\n        offset = 0,\n        callback?: _CallbackT<IToken[]>,\n    ): void | Promise<IToken[]> {\n        if (!callback)\n            return this.injectPromise(this.listTokens, limit, offset);\n\n        if (!utils.isInteger(limit) || limit < 0 || (offset && limit < 1))\n            return callback('Invalid limit provided');\n\n        if (!utils.isInteger(offset) || offset < 0)\n            return callback('Invalid offset provided');\n\n        if (!limit)\n            return this.tronWeb.fullNode\n                .request('wallet/getassetissuelist')\n                .then(({assetIssue = [] as IToken[]}) => {\n                    callback(\n                        null,\n                        assetIssue.map((token) => this._parseToken(token)),\n                    );\n                })\n                .catch((err) => callback(err)) as unknown as void;\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getpaginatedassetissuelist',\n                {\n                    offset: parseInt(offset.toString()),\n                    limit: parseInt(limit.toString()),\n                },\n                'post',\n            )\n            .then(({assetIssue = []}) => {\n                callback(\n                    null,\n                    assetIssue.map((token) => this._parseToken(token)),\n                );\n            })\n            .catch((err) => callback(err));\n    }\n\n    timeUntilNextVoteCycle(callback?: undefined): Promise<number>;\n    timeUntilNextVoteCycle(callback: _CallbackT<number>): void;\n    timeUntilNextVoteCycle(\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback) return this.injectPromise(this.timeUntilNextVoteCycle);\n\n        this.tronWeb.fullNode\n            .request('wallet/getnextmaintenancetime')\n            .then(({num = -1}) => {\n                if (num === -1)\n                    return callback('Failed to get time until next vote cycle');\n\n                callback(null, Math.floor(num / 1000));\n            })\n            .catch((err) => callback(err));\n    }\n\n    getContract(\n        contractAddress: string,\n        callback?: undefined,\n    ): Promise<ISmartContract>;\n    getContract(\n        contractAddress: string,\n        callback: _CallbackT<ISmartContract>,\n    ): void;\n    getContract(\n        contractAddress: string,\n        callback?: _CallbackT<ISmartContract>,\n    ): void | Promise<ISmartContract> {\n        if (!callback)\n            return this.injectPromise(this.getContract, contractAddress);\n\n        if (!this.tronWeb.isAddress(contractAddress))\n            return callback('Invalid contract address provided');\n\n        if (this.cache.contracts[contractAddress]) {\n            callback(null, this.cache.contracts[contractAddress]);\n            return undefined;\n        }\n\n        contractAddress = this.tronWeb.address.toHex(contractAddress);\n\n        this.tronWeb.fullNode\n            .request('wallet/getcontract', {value: contractAddress})\n            .then((contract) => {\n                if ('Error' in contract)\n                    return callback('Contract does not exist');\n                this.cache.contracts[contractAddress] = contract;\n                callback(null, contract);\n            })\n            .catch((err) => callback(err));\n    }\n\n    async verifyMessage(\n        message: string,\n        signature: string,\n        address?: string,\n        useTronHeader?: boolean,\n        callback?: undefined,\n    ): Promise<boolean>;\n    async verifyMessage(\n        message: string,\n        signature: string,\n        address: string | undefined,\n        useTronHeader: boolean | undefined,\n        callback: _CallbackT<boolean>,\n    ): Promise<void>;\n    async verifyMessage(\n        message: string,\n        signature: string,\n        address: string = this.tronWeb.defaultAddress.base58,\n        useTronHeader: boolean | undefined = true,\n        callback?: _CallbackT<boolean>,\n    ): Promise<void | boolean> {\n        if (!callback)\n            return this.injectPromise(\n                this.verifyMessage,\n                message,\n                signature,\n                address,\n                useTronHeader,\n            );\n\n        if (!utils.isHex(message))\n            return callback('Expected hex message input');\n\n        if (Trx.verifySignature(message, address, signature, useTronHeader))\n            return callback(null, true);\n\n        callback('Signature does not match');\n    }\n\n    static verifySignature(\n        message: string,\n        address: string,\n        signature: string,\n        useTronHeader: boolean | undefined = true,\n    ): boolean {\n        message = message.replace(/^0x/, '');\n        signature = signature.replace(/^0x/, '');\n        const messageBytes = [\n            ...toUtf8Bytes(\n                useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER,\n            ),\n            ...utils.code.hexStr2byteArray(message),\n        ];\n\n        const messageDigest = keccak256(messageBytes);\n        const recovered = recoverAddress(messageDigest, {\n            recoveryParam: signature.substring(128, 130) === '1c' ? 1 : 0,\n            r: '0x' + signature.substring(0, 64),\n            s: '0x' + signature.substring(64, 128),\n        });\n\n        const tronAddress = ADDRESS_PREFIX + recovered.substr(2);\n        const base58Address = TronWeb.address.fromHex(tronAddress);\n\n        return base58Address === TronWeb.address.fromHex(address);\n    }\n\n    verifyMessageV2(\n        message: string,\n        signature: string,\n        options: _CallbackT<string>,\n        callback?: undefined,\n    ): void;\n    verifyMessageV2(\n        message: string,\n        signature: string,\n        options: undefined,\n        callback?: undefined,\n    ): Promise<string>;\n    verifyMessageV2(\n        message: string,\n        signature: string,\n        options: undefined,\n        callback: _CallbackT<string>,\n    ): void;\n    verifyMessageV2(\n        message: string,\n        signature: string,\n        options?: undefined | _CallbackT<string>,\n        callback?: _CallbackT<string>,\n    ): void | Promise<string> {\n        if (utils.isFunction(options))\n            return this.verifyMessageV2(message, signature, undefined, options);\n\n        if (!callback)\n            return this.injectPromise(\n                this.verifyMessageV2,\n                message,\n                signature,\n                options,\n            );\n\n        try {\n            const base58Address = Trx.verifyMessageV2(message, signature);\n            callback(null, base58Address);\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    static verifyMessageV2(message: string, signature: string): string {\n        return utils.message.verifyMessage(message, signature);\n    }\n\n    verifyTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        signature: string,\n        address?: string,\n        callback?: undefined,\n    ): Promise<boolean>;\n    verifyTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        signature: string,\n        address: string | undefined,\n        callback: _CallbackT<boolean>,\n    ): void;\n    verifyTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        signature: string,\n        address: string = this.tronWeb.defaultAddress.base58,\n        callback?: _CallbackT<boolean>,\n    ): void | Promise<boolean> {\n        if (!callback)\n            return this.injectPromise(\n                this.verifyTypedData,\n                domain,\n                types,\n                value,\n                signature,\n                address,\n            );\n\n        if (Trx.verifyTypedData(domain, types, value, signature, address))\n            return callback(null, true);\n\n        callback('Signature does not match');\n    }\n\n    static verifyTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        signature: string,\n        address: string,\n    ): boolean {\n        signature = signature.replace(/^0x/, '');\n\n        const messageDigest = utils._TypedDataEncoder.hash(\n            domain,\n            types,\n            value,\n        );\n        const recovered = recoverAddress(messageDigest, {\n            recoveryParam: signature.substring(128, 130) === '1c' ? 1 : 0,\n            r: '0x' + signature.substring(0, 64),\n            s: '0x' + signature.substring(64, 128),\n        });\n\n        const tronAddress = ADDRESS_PREFIX + recovered.substr(2);\n        const base58Address = TronWeb.address.fromHex(tronAddress);\n\n        return base58Address === TronWeb.address.fromHex(address);\n    }\n\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey?: string,\n        useTronHeader?: boolean,\n        multisig?: boolean,\n        callback?: undefined,\n    ): Promise<MakeSigned<T>>;\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey: string | undefined,\n        useTronHeader: boolean | undefined,\n        multisig: boolean | undefined,\n        callback: _CallbackT<MakeSigned<T>>,\n    ): Promise<void>;\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey: string = this.tronWeb.defaultAddress.hex,\n        useTronHeader: boolean | undefined = false,\n        multisig = false,\n        callback?: _CallbackT<MakeSigned<T>>,\n    ): Promise<void | MakeSigned<T>> {\n        if (!callback)\n            return this.injectPromise(\n                this.sign,\n                transaction,\n                privateKey,\n                useTronHeader,\n                multisig,\n            );\n\n        // Message signing\n        if (utils.isString(transaction)) {\n            if (!utils.isHex(transaction))\n                return callback('Expected hex message input');\n\n            try {\n                const signatureHex = Trx.signString(\n                    transaction,\n                    privateKey,\n                    useTronHeader,\n                );\n                return callback(null, signatureHex as MakeSigned<T>);\n            } catch (ex) {\n                callback(ex);\n            }\n        }\n\n        if (!utils.isObject(transaction))\n            return callback(INVALID_TRANSACTION_MSG);\n\n        if (!multisig && transaction.signature)\n            return callback('Transaction is already signed');\n\n        try {\n            if (!multisig) {\n                const address = this.tronWeb.address\n                    .toHex(this.tronWeb.address.fromPrivateKey(privateKey))\n                    .toLowerCase();\n\n                if (\n                    address !==\n                    this.tronWeb.address.toHex(\n                        transaction.raw_data.contract[0].parameter.value\n                            .owner_address,\n                    )\n                )\n                    return callback(\n                        'Private key does not match address in transaction',\n                    );\n            }\n            return callback(\n                null,\n                utils.crypto.signTransaction(\n                    privateKey,\n                    transaction,\n                ) as unknown as MakeSigned<T>,\n            );\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    static signString(\n        message: string,\n        privateKey: string,\n        useTronHeader: boolean | undefined = true,\n    ): string {\n        message = message.replace(/^0x/, '');\n        const value = {\n            toHexString: function () {\n                return '0x' + privateKey;\n            },\n            value: privateKey,\n        };\n        const signingKey = new SigningKey(value);\n        const messageBytes = [\n            ...toUtf8Bytes(\n                useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER,\n            ),\n            ...utils.code.hexStr2byteArray(message),\n        ];\n        const messageDigest = keccak256(messageBytes);\n        const signature = signingKey.signDigest(messageDigest);\n        return [\n            '0x',\n            signature.r.substring(2),\n            signature.s.substring(2),\n            Number(signature.v).toString(16),\n        ].join('');\n    }\n\n    signString(\n        message: string,\n        privateKey: string,\n        useTronHeader: boolean | undefined = true,\n    ): string {\n        return Trx.signString(message, privateKey, useTronHeader);\n    }\n\n    /**\n     * Sign message v2 for verified header length.\n     *\n     * @param {message to be signed, should be Bytes or string} message\n     * @param {privateKey for signature} privateKey\n     * @param {reserved} options\n     * @param {callback function} callback\n     */\n    signMessageV2(\n        message: SomeBytes | string,\n        privateKey?: string,\n        options?: undefined,\n        callback?: undefined,\n    ): Promise<string>;\n    signMessageV2(\n        message: SomeBytes | string,\n        privateKey: string | undefined,\n        options: undefined,\n        callback: _CallbackT<string>,\n    ): void;\n    signMessageV2(\n        message: SomeBytes | string,\n        privateKey: string = this.tronWeb.defaultPrivateKey,\n        options?: undefined | _CallbackT<string>,\n        callback?: _CallbackT<string>,\n    ): void | Promise<string> {\n        if (!callback)\n            return this.injectPromise(this.signMessageV2, message, privateKey);\n\n        try {\n            const signatureHex = Trx.signMessageV2(message, privateKey);\n            return callback(null, signatureHex);\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    static signMessageV2(\n        message: SomeBytes | string,\n        privateKey: string,\n    ): string {\n        return utils.message.signMessage(message, privateKey);\n    }\n\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n    ): Promise<string>;\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: _CallbackT<string>,\n    ): void;\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: string,\n        callback?: undefined,\n    ): Promise<string>;\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: string,\n        callback: _CallbackT<string>,\n    ): void;\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: string | _CallbackT<string> = this.tronWeb\n            .defaultPrivateKey,\n        callback?: _CallbackT<string>,\n    ): void | Promise<string> {\n        if (utils.isFunction(privateKey))\n            return this._signTypedData(\n                domain,\n                types,\n                value,\n                this.tronWeb.defaultPrivateKey,\n                privateKey,\n            );\n\n        if (!callback)\n            return this.injectPromise(\n                this._signTypedData,\n                domain,\n                types,\n                value,\n                privateKey,\n            );\n\n        try {\n            const signatureHex = Trx._signTypedData(\n                domain,\n                types,\n                value,\n                privateKey,\n            );\n            return callback(null, signatureHex);\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    static _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: string,\n    ): string {\n        return utils.crypto._signTypedData(domain, types, value, privateKey);\n    }\n\n    async multiSign(\n        transaction: ITransaction,\n        privateKey?: string,\n        permissionId?: number,\n        callback?: undefined,\n    ): Promise<ISignedTransaction>;\n    async multiSign(\n        transaction: ITransaction,\n        privateKey: string | undefined,\n        permissionId: number | undefined,\n        callback: _CallbackT<ISignedTransaction>,\n    ): Promise<void>;\n    async multiSign(\n        transaction: ITransaction,\n        privateKey: string = this.tronWeb.defaultPrivateKey,\n        permissionId = 0,\n        callback?: _CallbackT<ISignedTransaction>,\n    ): Promise<void | ISignedTransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.multiSign,\n                transaction,\n                privateKey,\n                permissionId,\n            );\n\n        if (\n            !utils.isObject(transaction) ||\n            !transaction.raw_data ||\n            !transaction.raw_data.contract\n        )\n            return callback(INVALID_TRANSACTION_MSG);\n\n        // If owner permission or permission id exists in transaction, do sign directly\n        // If no permission id inside transaction or user passes permission id,\n        // use old way to reset permission id\n        if (\n            !transaction.raw_data.contract[0].Permission_id &&\n            permissionId > 0\n        ) {\n            // set permission id\n            transaction.raw_data.contract[0].Permission_id = permissionId;\n\n            // check if private key insides permission list\n            const address = this.tronWeb.address\n                .toHex(this.tronWeb.address.fromPrivateKey(privateKey))\n                .toLowerCase();\n            const signWeight = await this.getSignWeight(\n                transaction,\n                permissionId,\n            );\n\n            let foundKey = false;\n            signWeight.permission &&\n                signWeight.permission.keys.map((key) => {\n                    if (key.address === address) foundKey = true;\n                });\n\n            if (!foundKey)\n                return callback(privateKey + ' has no permission to sign');\n\n            if (\n                signWeight.approved_list &&\n                signWeight.approved_list.indexOf(address) !== -1\n            )\n                return callback(privateKey + ' already sign transaction');\n\n            // reset transaction\n            if (signWeight.transaction && signWeight.transaction.transaction) {\n                transaction = signWeight.transaction.transaction;\n                if (permissionId > 0)\n                    transaction.raw_data.contract[0].Permission_id =\n                        permissionId;\n            } else {\n                return callback(INVALID_TRANSACTION_MSG);\n            }\n        }\n\n        // sign\n        try {\n            return callback(\n                null,\n                utils.crypto.signTransaction(privateKey, transaction),\n            );\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    async getApprovedList(\n        transaction: ITransaction,\n        callback?: undefined,\n    ): Promise<any>;\n    async getApprovedList(\n        transaction: ITransaction,\n        callback: _CallbackT<ITransactionApprovedList>,\n    ): Promise<void>;\n    async getApprovedList(\n        transaction: ITransaction,\n        callback?: _CallbackT<ITransactionApprovedList>,\n    ): Promise<void | ITransactionApprovedList> {\n        if (!callback)\n            return this.injectPromise(this.getApprovedList, transaction);\n\n        if (!utils.isObject(transaction))\n            return callback(INVALID_TRANSACTION_MSG);\n\n        this.tronWeb.fullNode\n            .request('wallet/getapprovedlist', transaction, 'post')\n            .then((result) => {\n                callback(null, result);\n            })\n            .catch((err) => callback(err));\n    }\n\n    async getSignWeight(\n        transaction: ITransaction,\n        permissionId?: number,\n        callback?: undefined,\n    ): Promise<ISignWeight>;\n    async getSignWeight(\n        transaction: ITransaction,\n        permissionId: number | undefined,\n        callback?: _CallbackT<ISignWeight>,\n    ): Promise<void>;\n    async getSignWeight(\n        transaction: ITransaction,\n        permissionId?: number,\n        callback?: _CallbackT<ISignWeight>,\n    ): Promise<void | ISignWeight> {\n        if (!callback)\n            return this.injectPromise(\n                this.getSignWeight,\n                transaction,\n                permissionId,\n            );\n\n        if (\n            !utils.isObject(transaction) ||\n            !transaction.raw_data ||\n            !transaction.raw_data.contract\n        )\n            return callback(INVALID_TRANSACTION_MSG);\n\n        if (utils.isInteger(permissionId))\n            transaction.raw_data.contract[0].Permission_id = parseInt(\n                permissionId.toString(),\n            );\n        else if (\n            typeof transaction.raw_data.contract[0].Permission_id !== 'number'\n        )\n            transaction.raw_data.contract[0].Permission_id = 0;\n\n        if (!utils.isObject(transaction))\n            return callback(INVALID_TRANSACTION_MSG);\n\n        this.tronWeb.fullNode\n            .request('wallet/getsignweight', transaction, 'post')\n            .then((result) => {\n                callback(null, result);\n            })\n            .catch((err) => callback(err));\n    }\n\n    sendRawTransaction(\n        signedTransaction: ITransaction,\n        options?: undefined,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    sendRawTransaction(\n        signedTransaction: ITransaction,\n        options: undefined,\n        callback: _CallbackT<IBroadcastResult>,\n    ): void;\n    sendRawTransaction(\n        signedTransaction: ITransaction,\n        options?: undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): void | Promise<IBroadcastResult> {\n        if (!callback)\n            return this.injectPromise(\n                this.sendRawTransaction,\n                signedTransaction,\n                options,\n            );\n\n        if (!utils.isObject(signedTransaction))\n            return callback(INVALID_TRANSACTION_MSG);\n\n        if (\n            !signedTransaction.signature ||\n            !utils.isArray(signedTransaction.signature)\n        )\n            return callback('Transaction is not signed');\n\n        this.tronWeb.fullNode\n            .request('wallet/broadcasttransaction', signedTransaction, 'post')\n            .then((result) => {\n                const r = result as IBroadcastResult;\n                if (r.result) r.transaction = signedTransaction;\n                callback(null, r);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Broadcast a transaction in hex form\n     *  Warning: This method is missing in .proto and absent in docker test node\n     */\n    sendHexTransaction(\n        signedHexTransaction: string,\n        options?: undefined,\n        callback?: undefined,\n    ): Promise<IBroadcastHexResult>;\n    sendHexTransaction(\n        signedHexTransaction: string,\n        options: undefined,\n        callback: _CallbackT<IBroadcastHexResult>,\n    ): void;\n    sendHexTransaction(\n        signedHexTransaction: string,\n        options?: undefined,\n        callback?: _CallbackT<IBroadcastHexResult>,\n    ): void | Promise<IBroadcastHexResult> {\n        if (!callback)\n            return this.injectPromise(\n                this.sendHexTransaction,\n                signedHexTransaction,\n                options,\n            );\n\n        if (!utils.isHex(signedHexTransaction))\n            return callback('Invalid hex transaction provided');\n\n        const params = {\n            transaction: signedHexTransaction,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/broadcasthex' as any, params, 'post')\n            .then((result) => {\n                if (result.result) {\n                    result.transaction = JSON.parse(result.transaction);\n                    result.hexTransaction = signedHexTransaction;\n                }\n                callback(null, result);\n            })\n            .catch((err) => callback(err));\n    }\n\n    async sendTransaction(\n        to: string,\n        amount: number,\n        options?: string | IAddressOrPk,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async sendTransaction(\n        to: string,\n        amount: number,\n        options: string | IAddressOrPk | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async sendTransaction(\n        to: string,\n        amount: number,\n        options?: string | IAddressOrPk,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(\n                this.sendTransaction,\n                to,\n                amount,\n                options,\n            );\n\n        if (!this.tronWeb.isAddress(to))\n            return callback('Invalid recipient provided');\n\n        if (!utils.isInteger(amount) || amount <= 0)\n            return callback(INVALID_AMOUNT_MSG);\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const transaction = await this.tronWeb.transactionBuilder.sendTrx(\n                to,\n                amount,\n                address,\n            );\n            const signedTransaction = await this.sign(\n                transaction,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async sendToken(\n        to: string,\n        amount: number,\n        tokenID: string | number,\n        options?: string | IAddressOrPk,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async sendToken(\n        to: string,\n        amount: number,\n        tokenID: string | number,\n        options: string | IAddressOrPk | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async sendToken(\n        to: string,\n        amount: number,\n        tokenID: string | number,\n        options?: string | IAddressOrPk | _CallbackT<IBroadcastResult>,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(\n                this.sendToken,\n                to,\n                amount,\n                tokenID,\n                options,\n            );\n\n        if (!this.tronWeb.isAddress(to))\n            return callback('Invalid recipient provided');\n\n        if (!utils.isInteger(amount) || amount <= 0)\n            return callback(INVALID_AMOUNT_MSG);\n\n        if (utils.isInteger(tokenID)) tokenID = tokenID.toString();\n\n        if (!utils.isString(tokenID)) return callback(INVALID_TOKEN_ID_MSG);\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const transaction = await this.tronWeb.transactionBuilder.sendToken(\n                to,\n                amount,\n                tokenID,\n                address,\n            );\n            const signedTransaction = await this.sign(\n                transaction,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    /**\n     * Freezes an amount of TRX.\n     * Will give bandwidth OR Energy and TRON Power(voting rights)\n     * to the owner of the frozen tokens.\n     *\n     * @param amount - is the number of frozen trx\n     * @param duration - is the duration in days to be frozen\n     * @param resource - is the type, must be either \"ENERGY\" or \"BANDWIDTH\"\n     * @param options\n     * @param callback\n     */\n    async freezeBalance(\n        amount: number,\n        duration?: number,\n        resource?: ResourceT,\n        options?: IAddressOrPk | string,\n        receiverAddress?: string,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async freezeBalance(\n        amount: number,\n        duration: number | undefined,\n        resource: ResourceT | undefined,\n        options: IAddressOrPk | string | undefined,\n        receiverAddress: string | undefined,\n        callback: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async freezeBalance(\n        amount: number,\n        duration = 3,\n        resource: ResourceT = 'BANDWIDTH',\n        options: IAddressOrPk | string = {},\n        receiverAddress?: string | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(\n                this.freezeBalance,\n                amount,\n                duration,\n                resource,\n                options,\n                receiverAddress,\n            );\n\n        if (!['BANDWIDTH', 'ENERGY'].includes(resource))\n            return callback(\n                'Invalid resource provided: Expected \"BANDWIDTH\" or \"ENERGY\"',\n            );\n\n        if (!utils.isInteger(amount) || amount <= 0)\n            return callback(INVALID_AMOUNT_MSG);\n\n        if (!utils.isInteger(duration) || duration < 3)\n            return callback('Invalid duration provided, minimum of 3 days');\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const freezeBalance =\n                await this.tronWeb.transactionBuilder.freezeBalance(\n                    amount,\n                    duration,\n                    resource,\n                    address,\n                    receiverAddress,\n                );\n            const signedTransaction = await this.sign(\n                freezeBalance,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    /**\n     * Unfreeze TRX that has passed the minimum freeze duration.\n     * Unfreezing will remove bandwidth and TRON Power.\n     *\n     * @param resource - is the type, must be either \"ENERGY\" or \"BANDWIDTH\"\n     * @param options\n     * @param callback\n     */\n    async unfreezeBalance(\n        resource?: ResourceT,\n        options?: IAddressOrPk,\n        receiverAddress?: string,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async unfreezeBalance(\n        resource: ResourceT | undefined,\n        options: IAddressOrPk | undefined,\n        receiverAddress: string | undefined,\n        callback: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async unfreezeBalance(\n        resource: ResourceT = 'BANDWIDTH',\n        options: IAddressOrPk = {},\n        receiverAddress?: string | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(\n                this.unfreezeBalance,\n                resource,\n                options,\n                receiverAddress,\n            );\n\n        if (!['BANDWIDTH', 'ENERGY'].includes(resource))\n            return callback(\n                'Invalid resource provided: Expected \"BANDWIDTH\" or \"ENERGY\"',\n            );\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const unfreezeBalance =\n                await this.tronWeb.transactionBuilder.unfreezeBalance(\n                    resource,\n                    address,\n                    receiverAddress,\n                );\n            const signedTransaction = await this.sign(\n                unfreezeBalance,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    /**\n     * Modify account name\n     * Note: Username is allowed to edit only once.\n     *\n     * @param privateKey - Account private Key\n     * @param accountName - name of the account\n     * @param callback\n     *\n     * @return modified Transaction Object\n     */\n    async updateAccount(\n        accountName: string,\n        options?: IAddressOrPk,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async updateAccount(\n        accountName: string,\n        options: IAddressOrPk | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async updateAccount(\n        accountName: string,\n        options?: IAddressOrPk,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(this.updateAccount, accountName, options);\n\n        if (!utils.isString(accountName) || !accountName.length)\n            return callback('Name must be a string');\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const updateAccount =\n                await this.tronWeb.transactionBuilder.updateAccount(\n                    accountName,\n                    address,\n                );\n            const signedTransaction = await this.sign(\n                updateAccount,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    signMessage: Trx['sign'] = this.sign.bind(this);\n    sendAsset: Trx['sendToken'] = this.sendToken.bind(this);\n    send: Trx['sendTransaction'] = this.sendTransaction.bind(this);\n    sendTrx: Trx['sendTransaction'] = this.sendTransaction.bind(this);\n    broadcast: Trx['sendRawTransaction'] = this.sendRawTransaction.bind(this);\n    broadcastHex: Trx['sendHexTransaction'] =\n        this.sendHexTransaction.bind(this);\n    signTransaction: Trx['sign'] = this.sign.bind(this);\n    getUnconfirmedTransactionInfo: Trx['getUnconfirmedTransaction'] =\n        this.getUnconfirmedTransaction.bind(this);\n\n    /**\n     * Gets a network modification proposal by ID.\n     */\n    getProposal(proposalID: number, callback?: undefined): Promise<IProposal>;\n    getProposal(proposalID: number, callback: _CallbackT<IProposal>): void;\n    getProposal(\n        proposalID: number,\n        callback?: _CallbackT<IProposal>,\n    ): void | Promise<IProposal> {\n        if (!callback) return this.injectPromise(this.getProposal, proposalID);\n\n        if (!utils.isInteger(proposalID) || proposalID < 0)\n            return callback('Invalid proposalID provided');\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getproposalbyid',\n                {id: parseInt(proposalID.toString())},\n                'post',\n            )\n            .then((proposal) => {\n                callback(null, proposal);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Lists all network modification proposals.\n     */\n    listProposals(callback?: undefined): Promise<IProposal[]>;\n    listProposals(callback: _CallbackT<IProposal[]>): void;\n    listProposals(\n        callback?: _CallbackT<IProposal[]>,\n    ): void | Promise<IProposal[]> {\n        if (!callback) return this.injectPromise(this.listProposals);\n\n        this.tronWeb.fullNode\n            .request('wallet/listproposals', {}, 'post')\n            .then(({proposals = []}) => {\n                callback(null, proposals);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Lists all parameters available for network modification proposals.\n     */\n    getChainParameters(callback?: undefined): Promise<IChainParameter[]>;\n    getChainParameters(callback: _CallbackT<IChainParameter[]>): void;\n    getChainParameters(\n        callback?: _CallbackT<IChainParameter[]>,\n    ): void | Promise<IChainParameter[]> {\n        if (!callback) return this.injectPromise(this.getChainParameters);\n\n        this.tronWeb.fullNode\n            .request('wallet/getchainparameters', {}, 'post')\n            .then(({chainParameter = []}) => {\n                callback(null, chainParameter);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Get the account resources\n     */\n    getAccountResources(\n        address: string,\n        callback?: undefined,\n    ): Promise<IAccountResource>;\n    getAccountResources(\n        address: string,\n        callback: _CallbackT<IAccountResource>,\n    ): void;\n    getAccountResources(\n        address: string,\n        callback?: _CallbackT<IAccountResource>,\n    ): void | Promise<IAccountResource> {\n        if (!callback)\n            return this.injectPromise(this.getAccountResources, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getaccountresource',\n                {address: this.tronWeb.address.toHex(address)} as IAccount,\n                'post',\n            )\n            .then((resources) => {\n                callback(null, resources);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Get the exchange ID.\n     */\n    getExchangeByID(\n        exchangeID: number,\n        callback?: undefined,\n    ): Promise<IExchange>;\n    getExchangeByID(exchangeID: number, callback: _CallbackT<IExchange>): void;\n    getExchangeByID(\n        exchangeID: number,\n        callback?: _CallbackT<IExchange>,\n    ): void | Promise<IExchange> {\n        if (!callback)\n            return this.injectPromise(this.getExchangeByID, exchangeID);\n\n        if (!utils.isInteger(exchangeID) || exchangeID < 0)\n            return callback('Invalid exchangeID provided');\n\n        this.tronWeb.fullNode\n            .request('wallet/getexchangebyid', {id: exchangeID}, 'post')\n            .then((exchange) => {\n                callback(null, exchange);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Lists the exchanges\n     */\n    listExchanges(callback?: undefined): Promise<IExchange[]>;\n    listExchanges(callback: _CallbackT<IExchange[]>): void;\n    listExchanges(\n        callback?: _CallbackT<IExchange[]>,\n    ): void | Promise<IExchange[]> {\n        if (!callback) return this.injectPromise(this.listExchanges);\n\n        this.tronWeb.fullNode\n            .request('wallet/listexchanges', {}, 'post')\n            .then(({exchanges = []}) => {\n                callback(null, exchanges);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Lists all network modification proposals.\n     */\n    listExchangesPaginated(\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<IExchange[]>;\n    listExchangesPaginated(\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<IExchange[]>,\n    ): void;\n    listExchangesPaginated(\n        limit = 0,\n        offset = 0,\n        callback?: _CallbackT<IExchange[]>,\n    ): void | Promise<IExchange[]> {\n        if (!callback)\n            return this.injectPromise(\n                this.listExchangesPaginated,\n                limit,\n                offset,\n            );\n\n        this.tronWeb.fullNode\n            .request('wallet/getpaginatedexchangelist', {limit, offset}, 'post')\n            .then(({exchanges = []}) => {\n                callback(null, exchanges);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Get info about the node\n     */\n    getNodeInfo(callback?: undefined): Promise<INodeInfo>;\n    getNodeInfo(callback: _CallbackT<INodeInfo>): void;\n    getNodeInfo(callback?: _CallbackT<INodeInfo>): void | Promise<INodeInfo> {\n        if (!callback) return this.injectPromise(this.getNodeInfo);\n\n        this.tronWeb.fullNode\n            .request('wallet/getnodeinfo', {}, 'post')\n            .then((info) => {\n                callback(null, info);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTokenListByName(\n        tokenID: string | number,\n        callback?: undefined,\n    ): Promise<IToken[]>;\n    getTokenListByName(\n        tokenID: string | number,\n        callback: _CallbackT<IToken[]>,\n    ): void;\n    getTokenListByName(\n        tokenID: string | number,\n        callback?: _CallbackT<IToken[]>,\n    ): void | Promise<IToken[]> {\n        if (!callback)\n            return this.injectPromise(this.getTokenListByName, tokenID);\n\n        if (utils.isInteger(tokenID)) tokenID = tokenID.toString();\n\n        if (!utils.isString(tokenID) || !tokenID.length)\n            return callback(INVALID_TOKEN_ID_MSG);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getassetissuelistbyname',\n                {value: this.tronWeb.fromUtf8(tokenID)},\n                'post',\n            )\n            .then((token) => {\n                if (Array.isArray(token.assetIssue))\n                    return callback(\n                        null,\n                        token.assetIssue.map((t) => this._parseToken(t)),\n                    );\n                else if (!('name' in token) || !(token as any).name)\n                    return callback(TOKEN_DOES_NOT_EXIST_MSG);\n                // TODO: borrowed from old impl. This should never happen\n                else return callback(null, [this._parseToken(token as any)]);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTokenByID(\n        tokenID: string | number,\n        callback?: undefined,\n    ): Promise<IToken>;\n    getTokenByID(tokenID: string | number, callback: _CallbackT<IToken>): void;\n    getTokenByID(\n        tokenID: string | number,\n        callback?: _CallbackT<IToken>,\n    ): void | Promise<IToken> {\n        if (!callback) return this.injectPromise(this.getTokenByID, tokenID);\n\n        if (utils.isInteger(tokenID)) tokenID = tokenID.toString();\n\n        if (!utils.isString(tokenID) || !tokenID.length)\n            return callback(INVALID_TOKEN_ID_MSG);\n\n        this.tronWeb.fullNode\n            .request('wallet/getassetissuebyid', {value: tokenID}, 'post')\n            .then((token) => {\n                if (!token.name) return callback(TOKEN_DOES_NOT_EXIST_MSG);\n\n                callback(null, this._parseToken(token));\n            })\n            .catch((err) => callback(err));\n    }\n\n    async getReward(\n        address: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async getReward(\n        address: string,\n        options: {confirmed?: boolean},\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async getReward(\n        address: string,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        options.confirmed = true;\n        return this._getReward(address, options, callback as any);\n    }\n\n    async getUnconfirmedReward(\n        address: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async getUnconfirmedReward(\n        address: string,\n        options: {confirmed?: boolean},\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async getUnconfirmedReward(\n        address: string,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        options.confirmed = false;\n        return this._getReward(address, options, callback as any);\n    }\n\n    async getBrokerage(\n        address: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async getBrokerage(\n        address: string,\n        options: {confirmed?: boolean},\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async getBrokerage(\n        address: string,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        options.confirmed = true;\n        return this._getBrokerage(address, options, callback as any);\n    }\n\n    async getUnconfirmedBrokerage(\n        address: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async getUnconfirmedBrokerage(\n        address: string,\n        options: {confirmed?: boolean},\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async getUnconfirmedBrokerage(\n        address: string,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        options.confirmed = false;\n        return this._getBrokerage(address, options, callback as any);\n    }\n\n    async _getReward(\n        address?: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async _getReward(\n        address: string | undefined,\n        options: {confirmed?: boolean} | undefined,\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async _getReward(\n        address: string = this.tronWeb.defaultAddress.hex,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        if (!callback)\n            return this.injectPromise(this._getReward, address, options);\n        if (!utils.isString(address)) return callback('Invalid address.');\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {address: toHex(address)};\n\n        (options.confirmed\n            ? this.tronWeb.solidityNode.request(\n                  'walletsolidity/getReward',\n                  data,\n                  'post',\n              )\n            : this.tronWeb.fullNode.request('wallet/getReward', data, 'post')\n        )\n            .then((result = {}) => {\n                if (typeof result.reward === 'undefined')\n                    return callback('Not found.');\n\n                callback(null, result.reward);\n            })\n            .catch((err) => callback(err));\n    }\n\n    async _getBrokerage(\n        address?: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async _getBrokerage(\n        address: string | undefined,\n        options: {confirmed?: boolean} | undefined,\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async _getBrokerage(\n        address: string = this.tronWeb.defaultAddress.hex,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        if (!callback)\n            return this.injectPromise(this._getBrokerage, address, options);\n        if (!utils.isString(address))\n            return callback(`Invalid address: ${address}.`);\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {address: toHex(address)};\n\n        (options.confirmed\n            ? this.tronWeb.solidityNode.request(\n                  'walletsolidity/getBrokerage',\n                  data,\n                  'post',\n              )\n            : this.tronWeb.fullNode.request('wallet/getBrokerage', data, 'post')\n        )\n            .then((result) => {\n                if (typeof result.brokerage === 'undefined')\n                    return callback('Not found.');\n\n                callback(null, result.brokerage);\n            })\n            .catch((err) => callback(err));\n    }\n}\n","import TronWeb from '..';\nimport Validator from '../paramValidator';\nimport type {Permission as IPermissions, Transaction} from '../proto/core/Tron';\nimport utils from '../utils';\nimport {WithTronwebAndInjectpromise} from '../utils/_base';\nimport {encodeParamsV2ByABI} from '../utils/abi';\nimport {ADDRESS_PREFIX_REGEX} from '../utils/address';\nimport {AbiCoder} from '../utils/ethersUtils';\nimport type _CallbackT from '../utils/typing';\nimport type {IAbi} from './contract';\nimport type {ILog} from './trx';\nimport {ResourceT} from './trx';\n\nexport type {Transaction, Permission as IPermissions} from '../proto/core/Tron';\n\nconst INVALID_RESOURCE_MESSAGE =\n    'Invalid resource provided: Expected \"BANDWIDTH\" or \"ENERGY';\nlet self;\n\n// @ts-ignore\nexport interface IPermissionsMinimal extends IPermissions {\n    // making some fields optional without importing all that stuff\n    id?: number;\n    parent_id?: number;\n    operations?: string;\n}\nexport type ITransaction = Transaction;\n\nexport interface ISignedTransaction extends ITransaction {\n    signature: string[];\n}\nexport interface BaseOptions {\n    feeLimit?: number;\n    userFeePercentage?: number;\n    originEnergyLimit?: number;\n    callValue?: any;\n    tokenValue?: number;\n    tokenId?: number | string;\n    token_id?: number;\n    funcABIV2?: any;\n    parametersV2?: any;\n    permissionId?: number;\n    rawParameter?: string;\n    shieldedParameter?: string;\n    confirmed?: boolean;\n    estimateEnergy?: boolean;\n}\nexport interface ContractOptions extends BaseOptions {\n    abi: string | {entrys: IAbi[]} | IAbi[];\n    bytecode: string;\n    parameters?: any[] | string;\n    shouldPollResponse?: boolean;\n    name?: string;\n}\nexport interface ITriggerContractOptions extends BaseOptions {\n    _isConstant?: boolean;\n}\n\ninterface IPermissionId {\n    permissionId?: number;\n}\nexport interface IUpdateTokenOptions extends IPermissionId {\n    description: string;\n    url: string;\n    // The creator's \"donated\" bandwidth for use by token holders\n    freeBandwidth?: number | string;\n    // Out of `totalFreeBandwidth`, the amount each token holder get\n    freeBandwidthLimit?: number | string;\n}\nexport interface ICreateTokenOptions extends IUpdateTokenOptions {\n    name: string;\n    abbreviation: string;\n    totalSupply: number | string;\n    voteScore?: number | string;\n    precision?: number | string;\n\n    // Timestamps\n    saleStart?: number | string;\n    saleEnd: number | string;\n\n    // How much TRX will `tokenRatio` cost?\n    trxRatio?: number | string;\n    // How many tokens will `trxRatio` afford?\n    tokenRatio?: number | string;\n    frozenAmount?: number | string;\n    frozenDuration?: number | string;\n    // for now there is no default for the following values\n}\ntype IResources = any;\n\nexport interface ITriggerSmartContract {\n    transaction: ITransaction;\n    result: {result: boolean};\n}\nexport interface ITriggerConstantContract extends ITriggerSmartContract {\n    energy_used: number;\n    constant_result: string[];\n    logs: ILog[];\n}\n\n//helpers\n\nfunction toHex(value: string): string {\n    return TronWeb.address.toHex(value);\n}\n\nfunction fromUtf8(value: string): string {\n    return self.tronWeb.fromUtf8(value);\n}\n\nfunction resultManager(transaction, callback) {\n    if (transaction.Error) return callback(transaction.Error);\n\n    if (transaction.result && transaction.result.message)\n        return callback(self.tronWeb.toUtf8(transaction.result.message));\n\n    return callback(null, transaction);\n}\n\nexport default class TransactionBuilder extends WithTronwebAndInjectpromise {\n    validator: Validator;\n\n    constructor(tronWeb: TronWeb) {\n        super(tronWeb);\n        self = this;\n        this.validator = new Validator(tronWeb);\n    }\n\n    sendTrx(\n        to: string,\n        amount?: string | number,\n        from?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    sendTrx(\n        to: string,\n        amount: string | number | undefined,\n        from: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    sendTrx(\n        to: string,\n        amount: string | number = 0,\n        from: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.sendTrx, to, amount, from, options);\n\n        // accept amounts passed as strings\n        amount = parseInt(amount.toString());\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'recipient',\n                        type: 'address',\n                        value: to,\n                    },\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: from,\n                    },\n                    {\n                        names: ['recipient', 'origin'],\n                        type: 'notEqual',\n                        msg: 'Cannot transfer TRX to the same account',\n                    },\n                    {\n                        name: 'amount',\n                        type: 'integer',\n                        gt: 0,\n                        value: amount,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            to_address: toHex(to),\n            owner_address: toHex(from),\n            amount: amount,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/createtransaction', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    sendToken(\n        to: string,\n        amount: number | string | undefined,\n        tokenID: string,\n        from?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    sendToken(\n        to: string,\n        amount: number | string | undefined,\n        tokenID: string,\n        from: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    sendToken(\n        to: string,\n        amount: number | string = 0,\n        tokenID: string,\n        from: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.sendToken,\n                to,\n                amount,\n                tokenID,\n                from,\n                options,\n            );\n\n        amount = parseInt(amount.toString());\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'recipient',\n                        type: 'address',\n                        value: to,\n                    },\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: from,\n                    },\n                    {\n                        names: ['recipient', 'origin'],\n                        type: 'notEqual',\n                        msg: 'Cannot transfer tokens to the same account',\n                    },\n                    {\n                        name: 'amount',\n                        type: 'integer',\n                        gt: 0,\n                        value: amount,\n                    },\n                    {\n                        name: 'token ID',\n                        type: 'tokenId',\n                        value: tokenID,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            to_address: toHex(to),\n            owner_address: toHex(from),\n            asset_name: fromUtf8(tokenID),\n            amount: parseInt(amount.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/transferasset', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    purchaseToken(\n        issuerAddress: string,\n        tokenID: string,\n        amount?: number,\n        buyer?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    purchaseToken(\n        issuerAddress: string,\n        tokenID: string,\n        amount: number | undefined,\n        buyer: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    purchaseToken(\n        issuerAddress: string,\n        tokenID: string,\n        amount: number | string = 0,\n        buyer: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.purchaseToken,\n                issuerAddress,\n                tokenID,\n                amount,\n                buyer,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'buyer',\n                        type: 'address',\n                        value: buyer,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        names: ['buyer', 'issuer'],\n                        type: 'notEqual',\n                        msg: 'Cannot purchase tokens from same account',\n                    },\n                    {\n                        name: 'amount',\n                        type: 'integer',\n                        gt: 0,\n                        value: amount,\n                    },\n                    {\n                        name: 'token ID',\n                        type: 'tokenId',\n                        value: tokenID,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            to_address: toHex(issuerAddress),\n            owner_address: toHex(buyer),\n            asset_name: fromUtf8(tokenID),\n            amount: parseInt(amount.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/participateassetissue', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    freezeBalance(\n        amount: number,\n        duration: number,\n        resource?: ResourceT,\n        address?: string,\n        receiverAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    freezeBalance(\n        amount: number,\n        duration: number,\n        resource: ResourceT | undefined,\n        address: string | undefined,\n        receiverAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    freezeBalance(\n        amount = 0,\n        duration = 3,\n        resource: ResourceT = ResourceT.BANDWIDTH,\n        address: string = this.tronWeb.defaultAddress.hex,\n        receiverAddress?: string,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.freezeBalance,\n                amount,\n                duration,\n                resource,\n                address,\n                receiverAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                    {\n                        name: 'receiver',\n                        type: 'address',\n                        value: receiverAddress,\n                        optional: true,\n                    },\n                    {\n                        name: 'amount',\n                        type: 'integer',\n                        gt: 0,\n                        value: amount,\n                    },\n                    {\n                        name: 'duration',\n                        type: 'integer',\n                        gte: 3,\n                        value: duration,\n                    },\n                    {\n                        name: 'resource',\n                        type: 'resource',\n                        value: resource,\n                        msg: INVALID_RESOURCE_MESSAGE,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(address),\n            frozen_balance: parseInt(amount.toString()),\n            frozen_duration: parseInt(duration.toString()),\n            resource: resource,\n            receiver_address:\n                receiverAddress != null &&\n                toHex(receiverAddress) !== toHex(address)\n                    ? toHex(receiverAddress)\n                    : undefined,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/freezebalance', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    unfreezeBalance(\n        resource?: ResourceT,\n        address?: string,\n        receiverAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    unfreezeBalance(\n        resource: ResourceT | undefined,\n        address: string | undefined,\n        receiverAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    unfreezeBalance(\n        resource: ResourceT = ResourceT.BANDWIDTH,\n        address: string = this.tronWeb.defaultAddress.hex,\n        receiverAddress: string | undefined,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.unfreezeBalance,\n                resource,\n                address,\n                receiverAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                    {\n                        name: 'receiver',\n                        type: 'address',\n                        value: receiverAddress,\n                        optional: true,\n                    },\n                    {\n                        name: 'resource',\n                        type: 'resource',\n                        value: resource,\n                        msg: INVALID_RESOURCE_MESSAGE,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(address),\n            resource: resource,\n            receiver_address:\n                receiverAddress != null &&\n                toHex(receiverAddress) !== toHex(address)\n                    ? toHex(receiverAddress)\n                    : undefined,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/unfreezebalance', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    withdrawBlockRewards(\n        address?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    withdrawBlockRewards(\n        address: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    withdrawBlockRewards(\n        address: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawBlockRewards,\n                address,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(address),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/withdrawbalance', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    applyForSR(\n        address: string | undefined,\n        url: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    applyForSR(\n        address: string | undefined,\n        url: string,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    applyForSR(\n        address: string = this.tronWeb.defaultAddress.hex,\n        url: string,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.applyForSR, address, url, options);\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                    {\n                        name: 'url',\n                        type: 'url',\n                        value: url,\n                        msg: 'Invalid url provided',\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(address),\n            url: fromUtf8(url),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/createwitness', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    vote(\n        votes: Record<string, number>,\n        voterAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    vote(\n        votes: Record<string, number>,\n        voterAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    vote(\n        votes: Record<string, number>,\n        voterAddress: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ) {\n        if (!callback)\n            return this.injectPromise(this.vote, votes, voterAddress, options);\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'voter',\n                        type: 'address',\n                        value: voterAddress,\n                    },\n                    {\n                        name: 'votes',\n                        type: 'notEmptyObject',\n                        value: votes,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        let invalid = false;\n        const votesArr = Object.entries(votes).map(([srAddress, voteCount]) => {\n            if (invalid) return;\n\n            if (\n                this.validator.notValid([\n                    {\n                        name: 'SR',\n                        type: 'address',\n                        value: srAddress,\n                    },\n                    {\n                        name: 'vote count',\n                        type: 'integer',\n                        gt: 0,\n                        value: voteCount,\n                        msg: 'Invalid vote count provided for SR: ' + srAddress,\n                    },\n                ])\n            )\n                return (invalid = true);\n\n            return {\n                vote_address: toHex(srAddress),\n                vote_count: parseInt(voteCount.toString()),\n            };\n        }) as {vote_address: string; vote_count: number}[];\n        // Casting, because we'll return immediately otherwise\n        // It doesn't affect typechecking anyway\n\n        if (invalid) return;\n\n        const data = {\n            owner_address: toHex(voterAddress),\n            votes: votesArr,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/votewitnessaccount', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    createSmartContract(\n        options: ContractOptions,\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITransaction & {contract_address: string}>;\n    createSmartContract(\n        options: ContractOptions,\n        issuerAddress: string | undefined,\n        callback?: _CallbackT<ITransaction & {contract_address: string}>,\n    ): void;\n    createSmartContract(\n        options: ContractOptions,\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction & {contract_address: string}>,\n    ): void | Promise<ITransaction & {contract_address: string}> {\n        if (!callback)\n            return this.injectPromise(\n                this.createSmartContract,\n                options,\n                issuerAddress,\n            );\n\n        const feeLimit = options.feeLimit || this.tronWeb.feeLimit;\n        let userFeePercentage = options.userFeePercentage;\n        if (typeof userFeePercentage !== 'number' && !userFeePercentage)\n            userFeePercentage = 100;\n\n        const originEnergyLimit = options.originEnergyLimit || 10_000_000;\n        const callValue = options.callValue || 0;\n        const tokenValue = options.tokenValue;\n        const tokenId = options.tokenId || options.token_id;\n\n        // eslint-disable-next-line prefer-const\n        let {abi = '', bytecode, parameters = [], name = ''} = options;\n\n        if (abi && utils.isString(abi))\n            try {\n                abi = JSON.parse(abi);\n            } catch {\n                return callback('Invalid options.abi provided');\n            }\n\n        if (utils.isString(abi)) throw new Error('Impossible!');\n\n        const abi_arr = 'entrys' in abi ? abi.entrys : abi;\n\n        if (!utils.isArray(abi_arr))\n            return callback('Invalid options.abi provided');\n\n        const payable = abi_arr.some((func) => {\n            return (\n                func.type === 'constructor' &&\n                'payable' === func.stateMutability.toLowerCase()\n            );\n        });\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'bytecode',\n                        type: 'hex',\n                        value: bytecode,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gt: 0,\n                    },\n                    {\n                        name: 'callValue',\n                        type: 'integer',\n                        value: callValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'userFeePercentage',\n                        type: 'integer',\n                        value: userFeePercentage,\n                        gte: 0,\n                        lte: 100,\n                    },\n                    {\n                        name: 'originEnergyLimit',\n                        type: 'integer',\n                        value: originEnergyLimit,\n                        gte: 0,\n                        lte: 10_000_000,\n                    },\n                    {\n                        name: 'parameters',\n                        type: 'array',\n                        value: parameters,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        name: 'tokenValue',\n                        type: 'integer',\n                        value: tokenValue,\n                        gte: 0,\n                        optional: true,\n                    },\n                    {\n                        name: 'tokenId',\n                        type: 'integer',\n                        value: tokenId,\n                        gte: 0,\n                        optional: true,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        if (payable && callValue === 0 && tokenValue === 0)\n            return callback(\n                'When contract is payable, options.callValue or options.tokenValue' +\n                    ' must be a positive integer',\n            );\n\n        if (!payable && (callValue > 0 || (tokenValue && tokenValue > 0)))\n            return callback(\n                'When contract is not payable, options.callValue' +\n                    ' and options.tokenValue must be 0',\n            );\n\n        if (options.rawParameter && utils.isString(options.rawParameter)) {\n            parameters = options.rawParameter.replace(/^(0x)/, '');\n        } else if (options.funcABIV2) {\n            parameters = encodeParamsV2ByABI(\n                options.funcABIV2,\n                options.parametersV2,\n            ).replace(/^(0x)/, '');\n        } else {\n            const constructorParams = abi_arr.find((it) => {\n                return it.type === 'constructor';\n            });\n\n            if (typeof constructorParams !== 'undefined' && constructorParams) {\n                const abiCoder = new AbiCoder();\n                const types: string[] = [];\n                const values: unknown[] = [];\n                const constructorParams2: {type?: string}[] =\n                    constructorParams.inputs;\n\n                if (parameters.length !== constructorParams2.length)\n                    return callback(\n                        `constructor needs ${constructorParams2.length}` +\n                            ` but ${parameters.length} provided`,\n                    );\n\n                for (let i = 0; i < parameters.length; i++) {\n                    let type = constructorParams2[i].type;\n                    let value = parameters[i];\n\n                    if (!type || !utils.isString(type) || !type.length)\n                        return callback(\n                            'Invalid parameter type provided: ' + type,\n                        );\n\n                    if (type === 'address')\n                        value = toHex(value).replace(\n                            ADDRESS_PREFIX_REGEX,\n                            '0x',\n                        );\n                    else if (\n                        type.match(/^([^\\x5b]*)(\\x5b|$)/)![0] === 'address['\n                    )\n                        value = value.map((v) =>\n                            toHex(v).replace(ADDRESS_PREFIX_REGEX, '0x'),\n                        );\n                    else if (/trcToken/.test(type))\n                        type = type.replace(/trcToken/, 'uint256');\n\n                    types.push(type);\n                    values.push(value);\n                }\n\n                try {\n                    parameters = abiCoder\n                        .encode(types, values)\n                        .replace(/^(0x)/, '');\n                } catch (ex) {\n                    return callback(ex);\n                }\n            } else {\n                parameters = '';\n            }\n        }\n\n        const args = {\n            owner_address: toHex(issuerAddress),\n            fee_limit: parseInt(feeLimit.toString()),\n            call_value: parseInt(callValue),\n            consume_user_resource_percent: userFeePercentage,\n            origin_energy_limit: originEnergyLimit,\n            abi: JSON.stringify(abi_arr) as any,\n            bytecode,\n            parameter: parameters,\n            name,\n            token_id:\n                tokenId != null ? parseInt(tokenId.toString()) : undefined,\n            call_token_value:\n                tokenValue != null\n                    ? parseInt(tokenValue.toString())\n                    : undefined,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        // tokenValue and tokenId can cause errors if provided\n        // when the trx10 proposal has not been approved yet.\n        // So we set them only if they are passed to the method.\n\n        this.tronWeb.fullNode\n            .request('wallet/deploycontract', args, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters?: {type: string; value: any}[] | undefined,\n        issuerAddress?: string | undefined,\n        callback?: undefined,\n    ): Promise<ITriggerSmartContract>;\n    triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] | undefined,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITriggerSmartContract>,\n    ): void;\n    triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] = [],\n        issuerAddress: string | undefined = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITriggerSmartContract>,\n    ): void | Promise<ITriggerSmartContract> {\n        return this._triggerSmartContract(\n            contractAddress,\n            functionSelector,\n            options,\n            parameters,\n            issuerAddress,\n            callback as any,\n        );\n    }\n\n    triggerConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters?: {type: string; value: any}[],\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITriggerConstantContract>;\n    triggerConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] | undefined,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITriggerConstantContract>,\n    ): void;\n    triggerConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] = [],\n        issuerAddress: string | undefined = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITriggerConstantContract>,\n    ): void | Promise<ITriggerConstantContract> {\n        options._isConstant = true;\n        return this.triggerSmartContract(\n            contractAddress,\n            functionSelector,\n            options,\n            parameters,\n            issuerAddress,\n            callback as any,\n        ) as any;\n    }\n\n    triggerConfirmedConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters?: {type: string; value: any}[],\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITriggerConstantContract>;\n    triggerConfirmedConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] | undefined,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITriggerConstantContract>,\n    ): void;\n    triggerConfirmedConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] = [],\n        issuerAddress: string | undefined = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITriggerConstantContract>,\n    ): void | Promise<ITriggerConstantContract> {\n        options._isConstant = true;\n        options.confirmed = true;\n        return this.triggerSmartContract(\n            contractAddress,\n            functionSelector,\n            options,\n            parameters,\n            issuerAddress,\n            callback as any,\n        ) as any;\n    }\n\n    estimateEnergy(...params) {\n        params[2].estimateEnergy = true;\n        return this._triggerSmartContract(params[0], params[1], params[2], params[3], params[4]. params[5])\n    }\n\n    _triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters?: {type: string; value: any}[],\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITriggerSmartContract>;\n    _triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] | undefined,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITriggerSmartContract>,\n    ): void;\n    _triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] = [],\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITriggerSmartContract>,\n    ): void | Promise<ITriggerSmartContract> {\n        if (!callback)\n            return this.injectPromise(\n                this._triggerSmartContract,\n                contractAddress,\n                functionSelector,\n                options,\n                parameters,\n                issuerAddress,\n            );\n\n        const {tokenValue, tokenId, callValue, feeLimit} = Object.assign(\n            {\n                callValue: 0,\n                feeLimit: this.tronWeb.feeLimit,\n            },\n            options,\n        );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gt: 0,\n                    },\n                    {\n                        name: 'callValue',\n                        type: 'integer',\n                        value: callValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'parameters',\n                        type: 'array',\n                        value: parameters,\n                    },\n                    {\n                        name: 'contract',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                        optional: true,\n                    },\n                    {\n                        name: 'tokenValue',\n                        type: 'integer',\n                        value: tokenValue,\n                        gte: 0,\n                        optional: true,\n                    },\n                    {\n                        name: 'tokenId',\n                        type: 'integer',\n                        value: tokenId,\n                        gte: 0,\n                        optional: true,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const args = {\n            contract_address: toHex(contractAddress),\n            owner_address: toHex(issuerAddress),\n        } as {\n            owner_address: string;\n            contract_address: string;\n            call_value: number;\n            data: string;\n            call_token_value: number;\n            token_id: number;\n            fee_limit?: number;\n            function_selector: string;\n            parameter: string;\n            Permission_id?: undefined | number;\n        };\n\n        let param_str: string;\n        if (functionSelector && utils.isString(functionSelector)) {\n            functionSelector = functionSelector.replace('/s*/g', '');\n            if (parameters.length) {\n                const abiCoder = new AbiCoder();\n                let types: string[] = [];\n                const values: unknown[] = [];\n\n                for (let i = 0; i < parameters.length; i++) {\n                    // eslint-disable-next-line prefer-const\n                    let {type, value} = parameters[i];\n\n                    if (!type || !utils.isString(type) || !type.length)\n                        return callback(\n                            'Invalid parameter type provided: ' + type,\n                        ) as any as void;\n\n                    if (type === 'address')\n                        value = toHex(value).replace(\n                            ADDRESS_PREFIX_REGEX,\n                            '0x',\n                        );\n                    else if (\n                        type.match(/^([^\\x5b]*)(\\x5b|$)/)![0] === 'address['\n                    )\n                        value = value.map((v) =>\n                            toHex(v).replace(ADDRESS_PREFIX_REGEX, '0x'),\n                        );\n\n                    types.push(type);\n                    values.push(value);\n                }\n\n                try {\n                    // workaround for unsupported trcToken type\n                    types = types.map((type) => {\n                        if (/trcToken/.test(type))\n                            type = type.replace(/trcToken/, 'uint256');\n\n                        return type;\n                    });\n\n                    param_str = abiCoder\n                        .encode(types, values)\n                        .replace(/^(0x)/, '');\n                } catch (ex) {\n                    return callback(ex) as any as void;\n                }\n            } else {\n                param_str = '';\n            }\n\n            // work for abiv2 if passed the function abi in options\n            if (options.funcABIV2)\n                param_str = encodeParamsV2ByABI(\n                    options.funcABIV2,\n                    options.parametersV2,\n                ).replace(/^(0x)/, '');\n\n            if (\n                options.shieldedParameter &&\n                utils.isString(options.shieldedParameter)\n            )\n                param_str = options.shieldedParameter.replace(/^(0x)/, '');\n\n            if (options.rawParameter && utils.isString(options.rawParameter))\n                param_str = options.rawParameter.replace(/^(0x)/, '');\n\n            args.function_selector = functionSelector;\n            args.parameter = param_str;\n        }\n\n        args.call_value = parseInt(callValue);\n        if (tokenValue != null)\n            args.call_token_value = parseInt(tokenValue.toString());\n        if (tokenId != null) args.token_id = parseInt(tokenId.toString());\n\n        if (!(options._isConstant || options.estimateEnergy))\n            args.fee_limit = parseInt(feeLimit.toString());\n\n        if (options.permissionId) args.Permission_id = options.permissionId;\n\n        let pathInfo = 'triggesmartcontract';\n        if(options._isConstant) {\n            pathInfo = 'triggerconstantcontract';\n        } else if (options.estimateEnergy) {\n            pathInfo = 'estimateenergy';\n        }\n        pathInfo = `wallet${options.confirmed ? 'solidity' : ''}/${pathInfo}`\n\n        this.tronWeb[options.confirmed ? 'solidityNode' : 'fullNode']\n            // An error occurs here we need to fix it\n            .request(\n                pathInfo,\n                // @ts-ignore\n                args,\n                'post',\n            )\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    clearABI(\n        contractAddress: string,\n        ownerAddress?: string,\n        callback?: undefined,\n    ): void | Promise<ITransaction>;\n    clearABI(\n        contractAddress: string,\n        ownerAddress: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction>;\n    clearABI(\n        contractAddress: string,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.clearABI,\n                contractAddress,\n                ownerAddress,\n            );\n\n        if (!this.tronWeb.isAddress(contractAddress))\n            return callback('Invalid contract address provided');\n\n        if (!this.tronWeb.isAddress(ownerAddress))\n            return callback('Invalid owner address provided');\n\n        const data = {\n            contract_address: toHex(contractAddress),\n            owner_address: toHex(ownerAddress),\n        };\n\n        if (this.tronWeb.trx.cache.contracts[contractAddress])\n            delete this.tronWeb.trx.cache.contracts[contractAddress];\n\n        this.tronWeb.fullNode\n            .request('wallet/clearabi', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    updateBrokerage(\n        brokerage: number,\n        ownerAddress?: string,\n        callback?: undefined,\n    ): void | Promise<ITransaction>;\n    updateBrokerage(\n        brokerage: number,\n        ownerAddress: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction>;\n    updateBrokerage(\n        brokerage: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateBrokerage,\n                brokerage,\n                ownerAddress,\n            );\n\n        if (!utils.isNotNullOrUndefined(brokerage))\n            return callback('Invalid brokerage provided');\n\n        if (!utils.isInteger(brokerage) || brokerage < 0 || brokerage > 100)\n            return callback('Brokerage must be an integer between 0 and 100');\n\n        if (!this.tronWeb.isAddress(ownerAddress))\n            return callback('Invalid owner address provided');\n\n        const data = {\n            brokerage: parseInt(brokerage.toString()),\n            owner_address: toHex(ownerAddress),\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updateBrokerage', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    createToken(\n        options: ICreateTokenOptions,\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    createToken(\n        options: ICreateTokenOptions,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    createToken(\n        options: ICreateTokenOptions,\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.createToken, options, issuerAddress);\n\n        const {\n            name,\n            abbreviation,\n            description,\n            url,\n            totalSupply,\n            voteScore,\n            precision,\n            saleStart = Date.now(),\n            saleEnd,\n\n            // How much TRX will `tokenRatio` cost?\n            trxRatio = 1,\n            // How many tokens will `trxRatio` afford?\n            tokenRatio = 1,\n            // The creator's \"donated\" bandwidth for use by token holders\n            freeBandwidth = 0,\n            // Out of `totalFreeBandwidth`, the amount each token holder get\n            freeBandwidthLimit = 0,\n            frozenAmount = 0,\n            frozenDuration = 0,\n            // for now there is no default for the following values\n        } = options;\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'Supply amount',\n                        type: 'positive-integer',\n                        value: totalSupply,\n                    },\n                    {\n                        name: 'TRX ratio',\n                        type: 'positive-integer',\n                        value: trxRatio,\n                    },\n                    {\n                        name: 'Token ratio',\n                        type: 'positive-integer',\n                        value: tokenRatio,\n                    },\n                    {\n                        name: 'token abbreviation',\n                        type: 'not-empty-string',\n                        value: abbreviation,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: name,\n                    },\n                    {\n                        name: 'token description',\n                        type: 'not-empty-string',\n                        value: description,\n                    },\n                    {\n                        name: 'token url',\n                        type: 'url',\n                        value: url,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        name: 'sale start timestamp',\n                        type: 'integer',\n                        value: saleStart,\n                        gte: Date.now(),\n                    },\n                    {\n                        name: 'sale end timestamp',\n                        type: 'integer',\n                        value: saleEnd,\n                        gt: parseInt(saleStart.toString()),\n                    },\n                    {\n                        name: 'Free bandwidth amount',\n                        type: 'integer',\n                        value: freeBandwidth,\n                        gte: 0,\n                    },\n                    {\n                        name: 'Free bandwidth limit',\n                        type: 'integer',\n                        value: freeBandwidthLimit,\n                        gte: 0,\n                    },\n                    {\n                        name: 'Frozen supply',\n                        type: 'integer',\n                        value: frozenAmount,\n                        gte: 0,\n                    },\n                    {\n                        name: 'Frozen duration',\n                        type: 'integer',\n                        value: frozenDuration,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        if (\n            utils.isNotNullOrUndefined(voteScore) &&\n            (!utils.isInteger(voteScore) || voteScore <= 0)\n        )\n            return callback(\n                'voteScore must be a positive integer greater than 0',\n            );\n\n        if (\n            utils.isNotNullOrUndefined(precision) &&\n            (!utils.isInteger(precision) || precision < 0 || precision > 6)\n        )\n            return callback(\n                'precision must be a positive integer >= 0 and <= 6',\n            );\n\n        const data = {\n            owner_address: toHex(issuerAddress),\n            name: fromUtf8(name),\n            abbr: fromUtf8(abbreviation),\n            description: fromUtf8(description),\n            url: fromUtf8(url),\n            total_supply: parseInt(totalSupply.toString()),\n            trx_num: parseInt(trxRatio.toString()),\n            num: parseInt(tokenRatio.toString()),\n            start_time: parseInt(saleStart.toString()),\n            end_time: parseInt(saleEnd.toString()),\n            free_asset_net_limit: parseInt(freeBandwidth.toString()),\n            public_free_asset_net_limit: parseInt(\n                freeBandwidthLimit.toString(),\n            ),\n            frozen_supply: {\n                frozen_amount: parseInt(frozenAmount.toString()),\n                frozen_days: parseInt(frozenDuration.toString()),\n            },\n            // precision: undefined as undefined | number,\n            // vote_score: undefined as undefined | number,\n            // Permission_id: undefined as undefined | number,\n        } as any;\n        // Can never happen, we validated before!\n        // if (!(parseInt(frozenAmount) > 0)) delete data.frozen_supply;\n\n        // TODO: refactor this to `else` of checking branch\n        if (precision && !isNaN(parseInt(precision.toString())))\n            data.precision = parseInt(precision.toString());\n\n        if (voteScore && !isNaN(parseInt(voteScore.toString())))\n            data.vote_score = parseInt(voteScore.toString());\n\n        if (options && options.permissionId)\n            data.Permission_id = options.permissionId;\n\n        this.tronWeb.fullNode\n            .request('wallet/createassetissue', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    updateAccount(\n        accountName: string,\n        address?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    updateAccount(\n        accountName: string,\n        address: string | undefined,\n        options: IPermissionId,\n        callback: _CallbackT<ITransaction>,\n    ): Promise<ITransaction>;\n    updateAccount(\n        accountName: string,\n        address: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateAccount,\n                accountName,\n                address,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'Name',\n                        type: 'not-empty-string',\n                        value: accountName,\n                    },\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            account_name: fromUtf8(accountName),\n            owner_address: toHex(address),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updateaccount', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    setAccountId(\n        accountId: string,\n        address?: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    setAccountId(\n        accountId: string,\n        address: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    setAccountId(\n        accountId: string,\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.setAccountId, accountId, address);\n\n        if (\n            accountId &&\n            utils.isString(accountId) &&\n            accountId.startsWith('0x')\n        )\n            accountId = accountId.slice(2);\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'accountId',\n                        type: 'hex',\n                        value: accountId,\n                    },\n                    {\n                        name: 'accountId',\n                        type: 'string',\n                        lte: 32,\n                        gte: 8,\n                        value: accountId,\n                    },\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/setaccountid',\n                {\n                    account_id: accountId,\n                    owner_address: toHex(address),\n                },\n                'post',\n            )\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    updateToken(\n        options: IUpdateTokenOptions & IPermissionId,\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    updateToken(\n        options: IUpdateTokenOptions & IPermissionId,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    updateToken(\n        options: IUpdateTokenOptions & IPermissionId,\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.updateToken, options, issuerAddress);\n\n        const {\n            description,\n            url,\n            // The creator's \"donated\" bandwidth for use by token holders\n            freeBandwidth = 0,\n            // Out of `totalFreeBandwidth`, the amount each token holder get\n            freeBandwidthLimit = 0,\n        } = options;\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'token description',\n                        type: 'not-empty-string',\n                        value: description,\n                    },\n                    {\n                        name: 'token url',\n                        type: 'url',\n                        value: url,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        name: 'Free bandwidth amount',\n                        type: 'positive-integer',\n                        value: freeBandwidth,\n                    },\n                    {\n                        name: 'Free bandwidth limit',\n                        type: 'positive-integer',\n                        value: freeBandwidthLimit,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(issuerAddress),\n            description: fromUtf8(description),\n            url: fromUtf8(url),\n            new_limit: parseInt(freeBandwidth.toString()),\n            new_public_limit: parseInt(freeBandwidthLimit.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updateasset', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    sendAsset: TransactionBuilder['sendToken'] = this.sendToken.bind(this);\n    purchaseAsset: TransactionBuilder['purchaseToken'] =\n        this.purchaseToken.bind(this);\n    createAsset: TransactionBuilder['createToken'] =\n        this.createToken.bind(this);\n    updateAsset: TransactionBuilder['updateToken'] =\n        this.updateToken.bind(this);\n\n    /**\n     * Creates a proposal to modify the network.\n     * Can only be created by a current Super Representative.\n     */\n    createProposal(\n        parameters:\n            | {key: number; value: number}\n            | {key: number; value: number}[],\n        issuerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    createProposal(\n        parameters:\n            | {key: number; value: number}\n            | {key: number; value: number}[],\n        issuerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    createProposal(\n        parameters:\n            | {key: number; value: number}\n            | {key: number; value: number}[],\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.createProposal,\n                parameters,\n                issuerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const invalid = 'Invalid proposal parameters provided';\n\n        if (!parameters) return callback(invalid);\n\n        if (!utils.isArray(parameters)) parameters = [parameters];\n\n        for (const parameter of parameters)\n            if (!utils.isObject(parameter)) return callback(invalid);\n\n        const data = {\n            owner_address: toHex(issuerAddress),\n            parameters: parameters,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/proposalcreate', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Deletes a network modification proposal that the owner issued.\n     * Only current Super Representative can vote on a proposal.\n     */\n    deleteProposal(\n        proposalID: number,\n        issuerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    deleteProposal(\n        proposalID: number,\n        issuerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    deleteProposal(\n        proposalID: number,\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.deleteProposal,\n                proposalID,\n                issuerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        name: 'proposalID',\n                        type: 'integer',\n                        value: proposalID,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(issuerAddress),\n            proposal_id: parseInt(proposalID.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/proposaldelete', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Adds a vote to an issued network modification proposal.\n     * Only current Super Representative can vote on a proposal.\n     */\n    voteProposal(\n        proposalID: number,\n        isApproval: boolean,\n        voterAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    voteProposal(\n        proposalID: number,\n        isApproval: boolean,\n        voterAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    voteProposal(\n        proposalID: number,\n        isApproval: boolean,\n        voterAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.voteProposal,\n                proposalID,\n                isApproval,\n                voterAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'voter',\n                        type: 'address',\n                        value: voterAddress,\n                    },\n                    {\n                        name: 'proposalID',\n                        type: 'integer',\n                        value: proposalID,\n                        gte: 0,\n                    },\n                    {\n                        name: 'has approval',\n                        type: 'boolean',\n                        value: isApproval,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(voterAddress),\n            proposal_id: parseInt(proposalID.toString()),\n            is_add_approval: isApproval,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/proposalapprove', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Create an exchange between a token and TRX.\n     * Token Name should be a CASE SENSITIVE string.\n     * PLEASE VERIFY THIS ON TRONSCAN.\n     */\n    createTRXExchange(\n        tokenName: string,\n        tokenBalance: number,\n        trxBalance: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<IResources>;\n    createTRXExchange(\n        tokenName: string,\n        tokenBalance: number,\n        trxBalance: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<IResources>,\n    ): void;\n    createTRXExchange(\n        tokenName: string,\n        tokenBalance: number,\n        trxBalance: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<IResources>,\n    ): void | Promise<IResources> {\n        if (!callback)\n            return this.injectPromise(\n                this.createTRXExchange,\n                tokenName,\n                tokenBalance,\n                trxBalance,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: tokenName,\n                    },\n                    {\n                        name: 'token balance',\n                        type: 'positive-integer',\n                        value: tokenBalance,\n                    },\n                    {\n                        name: 'trx balance',\n                        type: 'positive-integer',\n                        value: trxBalance,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            first_token_id: fromUtf8(tokenName),\n            first_token_balance: tokenBalance,\n            second_token_id: '5f', // Constant for TRX.\n            second_token_balance: trxBalance,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangecreate', data, 'post')\n            .then((resources) => {\n                callback(null, resources);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Create an exchange between a token and another token.\n     * DO NOT USE THIS FOR TRX.\n     * Token Names should be a CASE SENSITIVE string.\n     * PLEASE VERIFY THIS ON TRONSCAN.\n     */\n    createTokenExchange(\n        firstTokenName: string,\n        firstTokenBalance: number,\n        secondTokenName: string,\n        secondTokenBalance: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<IResources>;\n    createTokenExchange(\n        firstTokenName: string,\n        firstTokenBalance: number,\n        secondTokenName: string,\n        secondTokenBalance: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<IResources>,\n    ): void;\n    createTokenExchange(\n        firstTokenName: string,\n        firstTokenBalance: number,\n        secondTokenName: string,\n        secondTokenBalance: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<IResources>,\n    ): void | Promise<IResources> {\n        if (!callback)\n            return this.injectPromise(\n                this.createTokenExchange,\n                firstTokenName,\n                firstTokenBalance,\n                secondTokenName,\n                secondTokenBalance,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'first token name',\n                        type: 'not-empty-string',\n                        value: firstTokenName,\n                    },\n                    {\n                        name: 'second token name',\n                        type: 'not-empty-string',\n                        value: secondTokenName,\n                    },\n                    {\n                        name: 'first token balance',\n                        type: 'positive-integer',\n                        value: firstTokenBalance,\n                    },\n                    {\n                        name: 'second token balance',\n                        type: 'positive-integer',\n                        value: secondTokenBalance,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            first_token_id: fromUtf8(firstTokenName),\n            first_token_balance: firstTokenBalance,\n            second_token_id: fromUtf8(secondTokenName),\n            second_token_balance: secondTokenBalance,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangecreate', data, 'post')\n            .then((resources) => {\n                callback(null, resources);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Adds tokens into a bancor style exchange.\n     * Will add both tokens at market rate.\n     * Use \"_\" for the constant value for TRX.\n     */\n    injectExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    injectExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    injectExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount = 0,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.injectExchangeTokens,\n                exchangeID,\n                tokenName,\n                tokenAmount,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: tokenName,\n                    },\n                    {\n                        name: 'token amount',\n                        type: 'integer',\n                        value: tokenAmount,\n                        gte: 1,\n                    },\n                    {\n                        name: 'exchangeID',\n                        type: 'integer',\n                        value: exchangeID,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            exchange_id: parseInt(exchangeID.toString()),\n            token_id: fromUtf8(tokenName),\n            quant: parseInt(tokenAmount.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangeinject', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Withdraws tokens from a bancor style exchange.\n     * Will withdraw at market rate both tokens.\n     * Use \"_\" for the constant value for TRX.\n     */\n    withdrawExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    withdrawExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    withdrawExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount = 0,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawExchangeTokens,\n                exchangeID,\n                tokenName,\n                tokenAmount,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: tokenName,\n                    },\n                    {\n                        name: 'token amount',\n                        type: 'integer',\n                        value: tokenAmount,\n                        gte: 1,\n                    },\n                    {\n                        name: 'exchangeID',\n                        type: 'integer',\n                        value: exchangeID,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            exchange_id: parseInt(exchangeID.toString()),\n            token_id: fromUtf8(tokenName),\n            quant: parseInt(tokenAmount.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangewithdraw', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Trade tokens on a bancor style exchange.\n     * Expected value is a validation and used to cap the total amt of token 2 spent.\n     * Use \"_\" for the constant value for TRX.\n     */\n    tradeExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmountSold: number,\n        tokenAmountExpected: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    tradeExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmountSold: number,\n        tokenAmountExpected: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    tradeExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmountSold = 0,\n        tokenAmountExpected = 0,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        // if (utils.isFunction(options)) {\n        //     callback = options;\n        //     options = {};\n        // }\n\n        // if (utils.isFunction(ownerAddress)) {\n        //     callback = ownerAddress;\n        //     ownerAddress = this.tronWeb.defaultAddress.hex;\n        // } else if (utils.isObject(ownerAddress)) {\n        //     options = ownerAddress;\n        //     ownerAddress = this.tronWeb.defaultAddress.hex;\n        // }\n\n        if (!callback)\n            return this.injectPromise(\n                this.tradeExchangeTokens,\n                exchangeID,\n                tokenName,\n                tokenAmountSold,\n                tokenAmountExpected,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: tokenName,\n                    },\n                    {\n                        name: 'tokenAmountSold',\n                        type: 'integer',\n                        value: tokenAmountSold,\n                        gte: 1,\n                    },\n                    {\n                        name: 'tokenAmountExpected',\n                        type: 'integer',\n                        value: tokenAmountExpected,\n                        gte: 1,\n                    },\n                    {\n                        name: 'exchangeID',\n                        type: 'integer',\n                        value: exchangeID,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            exchange_id: parseInt(exchangeID.toString()),\n            token_id: this.tronWeb.fromAscii(tokenName),\n            quant: parseInt(tokenAmountSold.toString()),\n            expected: parseInt(tokenAmountExpected.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangetransaction', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Update userFeePercentage.\n     */\n    updateSetting(\n        contractAddress: string,\n        userFeePercentage: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    updateSetting(\n        contractAddress: string,\n        userFeePercentage: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    updateSetting(\n        contractAddress: string,\n        userFeePercentage: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateSetting,\n                contractAddress,\n                userFeePercentage,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'contract',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                    {\n                        name: 'userFeePercentage',\n                        type: 'integer',\n                        value: userFeePercentage,\n                        gte: 0,\n                        lte: 100,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            contract_address: toHex(contractAddress),\n            consume_user_resource_percent: userFeePercentage,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updatesetting', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Update energy limit.\n     */\n    updateEnergyLimit(\n        contractAddress: string,\n        originEnergyLimit: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: unknown,\n    ): Promise<ITransaction>;\n    updateEnergyLimit(\n        contractAddress: string,\n        originEnergyLimit: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    updateEnergyLimit(\n        contractAddress: string,\n        originEnergyLimit: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateEnergyLimit,\n                contractAddress,\n                originEnergyLimit,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'contract',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                    {\n                        name: 'originEnergyLimit',\n                        type: 'integer',\n                        value: originEnergyLimit,\n                        gte: 0,\n                        lte: 10_000_000,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            contract_address: toHex(contractAddress),\n            origin_energy_limit: originEnergyLimit,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updateenergylimit', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    checkPermissions(\n        permissions: IPermissionsMinimal | null | undefined,\n        type: number,\n    ): boolean {\n        if (permissions) {\n            if (\n                permissions.type !== type ||\n                !permissions.permission_name ||\n                !utils.isString(permissions.permission_name) ||\n                !utils.isInteger(permissions.threshold) ||\n                permissions.threshold < 1 ||\n                !permissions.keys\n            )\n                return false;\n\n            for (const key of permissions.keys)\n                if (\n                    !this.tronWeb.isAddress(key.address) ||\n                    !utils.isInteger(key.weight) ||\n                    key.weight > permissions.threshold ||\n                    key.weight < 1 ||\n                    (type === 2 && !permissions.operations)\n                )\n                    return false;\n        }\n        return true;\n    }\n\n    updateAccountPermissions(\n        ownerAddress?: string,\n        ownerPermissions?: IPermissionsMinimal,\n        witnessPermissions?: IPermissionsMinimal,\n        activesPermissions?:\n            | IPermissionsMinimal\n            | (IPermissionsMinimal | undefined)[],\n        callback?: unknown,\n    ): Promise<ITransaction>;\n    updateAccountPermissions(\n        ownerAddress: string | undefined,\n        ownerPermissions: IPermissionsMinimal | undefined,\n        witnessPermissions: IPermissionsMinimal | undefined,\n        activesPermissions:\n            | IPermissionsMinimal\n            | (IPermissionsMinimal | undefined)[]\n            | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    updateAccountPermissions(\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        ownerPermissions?: IPermissionsMinimal,\n        witnessPermissions?: IPermissionsMinimal,\n        activesPermissions?:\n            | IPermissionsMinimal\n            | (IPermissionsMinimal | undefined)[],\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateAccountPermissions,\n                ownerAddress,\n                ownerPermissions,\n                witnessPermissions,\n                activesPermissions,\n            );\n\n        if (!this.tronWeb.isAddress(ownerAddress))\n            return callback('Invalid ownerAddress provided');\n\n        if (!this.checkPermissions(ownerPermissions, 0))\n            return callback('Invalid ownerPermissions provided');\n\n        if (!this.checkPermissions(witnessPermissions, 1))\n            return callback('Invalid witnessPermissions provided');\n\n        if (!Array.isArray(activesPermissions))\n            activesPermissions = [activesPermissions];\n\n        for (const activesPermission of activesPermissions)\n            if (!this.checkPermissions(activesPermission, 2))\n                return callback('Invalid activesPermissions provided');\n\n        const data = {\n            owner_address: ownerAddress,\n            owner: undefined as undefined | IPermissions,\n            witness: undefined as undefined | IPermissions,\n            actives: [] as IPermissions[],\n        };\n        if (ownerPermissions) data.owner = ownerPermissions as IPermissions;\n\n        if (witnessPermissions)\n            data.witness = witnessPermissions as IPermissions;\n\n        if (activesPermissions)\n            data.actives = activesPermissions as IPermissions[];\n\n        this.tronWeb.fullNode\n            .request('wallet/accountpermissionupdate', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    async newTxID(\n        transaction: ITransaction,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    async newTxID(\n        transaction: ITransaction,\n        callback: _CallbackT<ITransaction>,\n    ): Promise<void>;\n    async newTxID(\n        transaction: ITransaction,\n        callback?: _CallbackT<ITransaction>,\n    ): Promise<void | ITransaction> {\n        if (!callback) return this.injectPromise(this.newTxID, transaction);\n\n        this.tronWeb.fullNode\n            .request('wallet/getsignweight', transaction, 'post')\n            .then((newTransaction) => {\n                const inner = newTransaction.transaction?.transaction;\n                if (inner && typeof transaction.visible === 'boolean')\n                    inner.visible = transaction.visible;\n\n                callback(null, inner);\n            })\n            .catch(() => callback('Error generating a new transaction id.'));\n    }\n\n    async alterTransaction(\n        transaction: ITransaction,\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        options: ({} | {data: unknown; dataFormat?: string}) & {\n            extension?: number;\n        },\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    async alterTransaction(\n        transaction: ITransaction,\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        options: ({} | {data: unknown; dataFormat?: string}) & {\n            extension?: number;\n        },\n        callback: _CallbackT<ITransaction>,\n    ): Promise<void>;\n    async alterTransaction(\n        transaction: ITransaction,\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        options: ({} | {data: unknown; dataFormat?: string}) & {\n            extension?: number;\n        },\n        callback?: _CallbackT<ITransaction>,\n    ): Promise<void | ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.alterTransaction,\n                transaction,\n                options,\n            );\n\n        if (transaction.signature)\n            return callback(\n                'You can not extend the expiration of a signed transaction.',\n            );\n\n        if ('data' in options && options.data) {\n            const {data} = options;\n            let sData =\n                options.dataFormat !== 'hex'\n                    ? this.tronWeb.toHex(data)\n                    : (data as string);\n            if (!utils.isString(sData))\n                throw new TypeError('Invalid data provided');\n            sData = sData.replace(/^0x/, '');\n            if (sData.length === 0) return callback('Invalid data provided');\n            transaction.raw_data.data = sData;\n            options.data = sData;\n        }\n\n        if (options.extension) {\n            options.extension = parseInt((options.extension * 1000).toString());\n            if (\n                isNaN(options.extension) ||\n                transaction.raw_data.expiration + options.extension <=\n                    Date.now() + 3000\n            )\n                return callback('Invalid extension provided');\n            transaction.raw_data.expiration += options.extension;\n        }\n\n        this.newTxID(transaction, callback);\n    }\n\n    async extendExpiration(\n        transaction: ITransaction,\n        extension: number,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    async extendExpiration(\n        transaction: ITransaction,\n        extension: number,\n        callback: _CallbackT<ITransaction>,\n    ): Promise<void>;\n    async extendExpiration(\n        transaction: ITransaction,\n        extension: number,\n        callback?: _CallbackT<ITransaction>,\n    ): Promise<void | ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.extendExpiration,\n                transaction,\n                extension,\n            );\n\n        this.alterTransaction(transaction, {extension}, callback);\n    }\n\n    async addUpdateData(\n        transaction: ITransaction,\n        data: string,\n        dataFormat?: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    async addUpdateData(\n        transaction: ITransaction,\n        data: string,\n        dataFormat: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): Promise<void>;\n    async addUpdateData(\n        transaction: ITransaction,\n        data: string,\n        dataFormat = 'utf8',\n        callback?: _CallbackT<ITransaction>,\n    ): Promise<void | ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.addUpdateData,\n                transaction,\n                data,\n                dataFormat,\n            );\n\n        this.alterTransaction(transaction, {data, dataFormat}, callback);\n    }\n}\n","import BigNumber from 'bignumber.js';\nimport EventEmitter from 'eventemitter3';\nimport injectpromise from 'injectpromise';\nimport semver from 'semver';\n\nimport {version} from '../version.js';\nimport Contract from './lib/contract';\nimport type {ContractEventOptions, IAbi} from './lib/contract';\nimport Event from './lib/event';\nimport type {IEvent, IEventResponse} from './lib/event';\nimport Plugin from './lib/plugin';\nimport providers from './lib/providers';\nimport {HttpProvider} from './lib/providers';\nimport SideChain from './lib/sidechain';\nimport type {IChainOptions} from './lib/sidechain';\nimport TransactionBuilder from './lib/transactionBuilder';\nimport Trx from './lib/trx';\nimport type {BlockT} from './lib/trx';\nimport utils from './utils';\nimport {ADDRESS_PREFIX, TRON_BIP39_PATH_INDEX_0} from './utils/address';\nimport {keccak256} from './utils/ethersUtils';\nimport type _CallbackT from './utils/typing';\n\nconst DEFAULT_VERSION = '3.5.0';\n\nconst FEE_LIMIT = 150000000;\n\nexport type ITronWebOptions = {\n    headers?: Record<string, string>;\n    eventHeaders?: Record<string, string>;\n    privateKey?: string;\n    disablePlugins?: string[];\n} & (\n    | {fullHost: string}\n    | {\n          fullNode: HttpProvider | string;\n          solidityNode: HttpProvider | string;\n          eventServer: HttpProvider | string;\n      }\n);\n\nexport default class TronWeb extends EventEmitter {\n    static providers = providers;\n    static BigNumber = BigNumber;\n    static TransactionBuilder = TransactionBuilder;\n    static Trx = Trx;\n    static Contract = Contract;\n    static Plugin = Plugin;\n    static Event = Event;\n    static version = version;\n    static utils = utils;\n    version = version;\n\n    providers = providers;\n    utils = utils;\n    BigNumber = BigNumber;\n    injectPromise: injectpromise;\n\n    event: Event;\n    transactionBuilder: TransactionBuilder;\n    trx: Trx;\n    plugin: Plugin;\n    sidechain?: SideChain<TronWeb>;\n\n    fullNode!: HttpProvider;\n    solidityNode!: HttpProvider;\n    eventServer!: HttpProvider;\n\n    defaultBlock: BlockT;\n    defaultPrivateKey: string;\n    defaultAddress: {\n        base58: string;\n        hex: string;\n    };\n    fullnodeVersion = DEFAULT_VERSION;\n    feeLimit = FEE_LIMIT;\n\n    constructor(options: ITronWebOptions, sideOptions?: IChainOptions);\n    constructor(\n        // for retro-compatibility:\n        options: string | HttpProvider,\n        solidityNode: string | HttpProvider,\n        eventServer?: string | HttpProvider,\n        sideOptions?: IChainOptions,\n        privateKey?: string | null,\n    );\n    constructor(\n        // for retro-compatibility:\n        options: string | HttpProvider,\n        solidityNode: string | HttpProvider,\n        eventServer?: string | HttpProvider,\n        sideOptions?: string | null,\n    );\n    constructor(\n        options: ITronWebOptions | string | HttpProvider,\n        // for retro-compatibility:\n        solidityNode?: string | IChainOptions | HttpProvider,\n        eventServer?: string | HttpProvider,\n        sideOptions?: IChainOptions | string | null,\n        privateKey?: string,\n    ) {\n        super();\n\n        let fullNode;\n        let headers;\n        let eventHeaders;\n\n        if (\n            typeof options === 'object' &&\n            ('fullNode' in options || 'fullHost' in options) &&\n            ('fullNode' in options ? options.fullNode : options.fullHost)\n        ) {\n            fullNode =\n                'fullNode' in options ? options.fullNode : options.fullHost;\n            // shift\n            sideOptions = solidityNode as any as IChainOptions;\n            solidityNode =\n                'solidityNode' in options\n                    ? options.solidityNode\n                    : options.fullHost;\n            eventServer =\n                'eventServer' in options\n                    ? options.eventServer\n                    : options.fullHost;\n            headers = options.headers || false;\n            eventHeaders = options.eventHeaders || headers;\n            privateKey = options.privateKey;\n        } else {\n            fullNode = options;\n        }\n        if (utils.isString(fullNode)) fullNode = new HttpProvider(fullNode);\n        if (utils.isString(solidityNode))\n            solidityNode = new HttpProvider(solidityNode);\n        if (utils.isString(eventServer))\n            eventServer = new HttpProvider(eventServer);\n\n        this.event = new Event(this);\n        this.transactionBuilder = new TransactionBuilder(this);\n        this.trx = new Trx(this);\n        this.plugin = new Plugin(this, options as Record<string, unknown>);\n\n        this.setFullNode(fullNode);\n        this.setSolidityNode(solidityNode as HttpProvider);\n        this.setEventServer(eventServer!);\n\n        // This allows undefined, but allowing it in class body raises 100+ errors\n        this.defaultBlock = undefined as any;\n        this.defaultPrivateKey = undefined as any;\n        this.defaultAddress = {\n            hex: undefined as any,\n            base58: undefined as any,\n        };\n\n        // for sidechain\n        if (\n            sideOptions &&\n            typeof sideOptions === 'object' &&\n            ('fullNode' in sideOptions\n                ? sideOptions.fullNode\n                : sideOptions.fullHost)\n        )\n            this.sidechain = new SideChain(\n                sideOptions,\n                TronWeb,\n                this,\n                // WTF? Was options.privateKey, which makes even less sense\n                // @ts-ignore\n                privateKey,\n            );\n        else if (typeof sideOptions !== 'string' && sideOptions != null)\n            throw new TypeError('Wrong options combination provided');\n        else if (sideOptions != null) privateKey = privateKey || sideOptions;\n\n        if (privateKey) this.setPrivateKey(privateKey);\n        this.injectPromise = injectpromise(this);\n\n        if (headers) this.setFullNodeHeader(headers);\n\n        if (eventHeaders) this.setEventHeader(eventHeaders);\n    }\n\n    async getFullnodeVersion() {\n        try {\n            const nodeInfo = await this.trx.getNodeInfo();\n            this.fullnodeVersion = nodeInfo.configNodeInfo!.codeVersion!;\n            if (this.fullnodeVersion.split('.').length === 2)\n                this.fullnodeVersion += '.0';\n        } catch (err) {\n            this.fullnodeVersion = DEFAULT_VERSION;\n        }\n    }\n\n    setDefaultBlock(blockID?: BlockT | undefined) {\n        if ([undefined, 'latest', 'earliest', 0].includes(blockID)) {\n            // This allows undefined, but allowing it in class body raises 100+ errors\n            // @ts-ignore\n            this.defaultBlock = blockID;\n            return;\n        }\n\n        if (!utils.isInteger(blockID) || !blockID)\n            throw new Error('Invalid block ID provided');\n\n        this.defaultBlock = Math.abs(blockID);\n    }\n\n    setPrivateKey(privateKey: string) {\n        try {\n            const addr = this.address.fromPrivateKey(privateKey);\n            if (addr) this.setAddress(addr);\n            else throw new Error();\n        } catch {\n            throw new Error('Invalid private key provided');\n        }\n\n        this.defaultPrivateKey = privateKey;\n        this.emit('privateKeyChanged', privateKey);\n    }\n\n    setAddress(address: string) {\n        if (!this.isAddress(address))\n            throw new Error('Invalid address provided');\n\n        const hex = this.address.toHex(address);\n        const base58 = this.address.fromHex(address);\n\n        if (\n            this.defaultPrivateKey &&\n            this.address.fromPrivateKey(this.defaultPrivateKey) !== base58\n        )\n            // This allows undefined, but allowing it in class body raises 100+ errors\n            // @ts-ignore\n            this.defaultPrivateKey = undefined;\n\n        this.defaultAddress = {\n            hex,\n            base58,\n        };\n\n        this.emit('addressChanged', {hex, base58});\n    }\n\n    fullnodeSatisfies(version: string): boolean {\n        return semver.satisfies(this.fullnodeVersion, version);\n    }\n\n    isValidProvider(provider: unknown): boolean {\n        return Object.values(providers).some(\n            (knownProvider: any) => provider instanceof knownProvider,\n        );\n    }\n\n    setFullNode(fullNode: string | HttpProvider) {\n        if (utils.isString(fullNode)) fullNode = new HttpProvider(fullNode);\n\n        if (!this.isValidProvider(fullNode))\n            throw new Error('Invalid full node provided');\n\n        this.fullNode = fullNode;\n        this.fullNode.setStatusPage('wallet/getnowblock');\n\n        this.getFullnodeVersion();\n    }\n\n    setSolidityNode(solidityNode: string | HttpProvider) {\n        if (utils.isString(solidityNode))\n            solidityNode = new HttpProvider(solidityNode);\n\n        if (!this.isValidProvider(solidityNode))\n            throw new Error('Invalid solidity node provided');\n\n        this.solidityNode = solidityNode;\n        this.solidityNode.setStatusPage('walletsolidity/getnowblock');\n    }\n\n    setEventServer(\n        eventServer: string | HttpProvider | undefined | null,\n        healthcheck = 'healthcheck',\n    ): void {\n        this.event.setServer(eventServer, healthcheck);\n    }\n\n    setHeader(headers: Record<string, string> = {}) {\n        const fullNode = new HttpProvider(\n            this.fullNode.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n        const solidityNode = new HttpProvider(\n            this.solidityNode.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n        const eventServer = new HttpProvider(\n            this.eventServer.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n\n        this.setFullNode(fullNode);\n        this.setSolidityNode(solidityNode);\n        this.setEventServer(eventServer);\n    }\n\n    setFullNodeHeader(headers: Record<string, string> = {}) {\n        const fullNode = new HttpProvider(\n            this.fullNode.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n        const solidityNode = new HttpProvider(\n            this.solidityNode.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n\n        this.setFullNode(fullNode);\n        this.setSolidityNode(solidityNode);\n    }\n\n    setEventHeader(headers: Record<string, string> = {}) {\n        const eventServer = new HttpProvider(\n            this.eventServer.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n        this.setEventServer(eventServer);\n    }\n\n    currentProviders() {\n        return {\n            fullNode: this.fullNode,\n            solidityNode: this.solidityNode,\n            eventServer: this.eventServer,\n        };\n    }\n\n    currentProvider() {\n        return this.currentProviders();\n    }\n\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback?: undefined,\n    ): Promise<IEventResponse>;\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback?: undefined,\n    ): Promise<IEvent>;\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback: _CallbackT<IEventResponse>,\n    ): void;\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback: _CallbackT<IEvent>,\n    ): void;\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions = {},\n        callback?: _CallbackT<IEvent> | _CallbackT<IEventResponse>,\n    ): void | Promise<IEvent> | Promise<IEventResponse> {\n        // getEventResult(...params) {\n        // if (typeof params[1] !== 'object') {\n        //     params[1] = {\n        //         sinceTimestamp: params[1] || 0,\n        //         eventName: params[2] || false,\n        //         blockNumber: params[3] || false,\n        //         size: params[4] || 20,\n        //         page: params[5] || 1,\n        //     };\n        //     params.splice(2, 4);\n\n        //     // callback:\n        //     if (!utils.isFunction(params[2])) {\n        //         if (utils.isFunction(params[1].page)) {\n        //             params[2] = params[1].page;\n        //             params[1].page = 1;\n        //         } else if (utils.isFunction(params[1].size)) {\n        //             params[2] = params[1].size;\n        //             params[1].size = 20;\n        //             params[1].page = 1;\n        //         }\n        //     }\n        // }\n\n        return this.event.getEventsByContractAddress(\n            contractAddress,\n            options as any,\n            callback as any,\n        ) as any;\n    }\n\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback?: undefined,\n    ): Promise<IEventResponse>;\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback?: undefined,\n    ): Promise<IEvent>;\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback: _CallbackT<IEventResponse>,\n    ): void;\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback: _CallbackT<IEvent>,\n    ): void;\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions = {},\n        callback?: _CallbackT<IEvent> | _CallbackT<IEventResponse>,\n    ): void | Promise<IEvent> | Promise<IEventResponse> {\n        return this.event.getEventsByTransactionID(\n            transactionID,\n            options as any,\n            callback as any,\n        ) as any;\n    }\n\n    contract(abi: IAbi[] = [], address?: string): Contract {\n        return new Contract(this, abi, address);\n    }\n\n    static get address() {\n        return {\n            fromHex(address: string): string {\n                if (!utils.isHex(address)) return address;\n\n                return utils.crypto.getBase58CheckAddress(\n                    utils.code.hexStr2byteArray(\n                        address.replace(/^0x/, ADDRESS_PREFIX),\n                    ),\n                );\n            },\n            toHex(address: string): string {\n                if (utils.isHex(address))\n                    return address.toLowerCase().replace(/^0x/, ADDRESS_PREFIX);\n\n                return utils.code\n                    .byteArray2hexStr(utils.crypto.decodeBase58Address(address))\n                    .toLowerCase();\n            },\n            fromPrivateKey(privateKey: string, strict = false): string {\n                try {\n                    return utils.crypto.pkToAddress(privateKey, strict);\n                } catch {\n                    throw new Error('Invalid private key!');\n                }\n            },\n        };\n    }\n    get address() {\n        return TronWeb.address;\n    }\n\n    static sha3(string: string, prefix = true): string {\n        return (\n            (prefix ? '0x' : '') +\n            keccak256(Buffer.from(string, 'utf-8')).toString().substring(2)\n        );\n    }\n    sha3(string: string, prefix = true): string {\n        return TronWeb.sha3(string, prefix);\n    }\n\n    static toHex(val: unknown): string {\n        if (utils.isBoolean(val)) return TronWeb.fromDecimal(+val);\n\n        if (utils.isBigNumber(val)) return TronWeb.fromDecimal(val);\n\n        if (typeof val === 'object')\n            return TronWeb.fromUtf8(JSON.stringify(val));\n\n        if (utils.isString(val)) {\n            if (/^(-|)0x/.test(val)) return val;\n\n            // `val` is really a string, and below is legacy code abusing isFinite.\n            // @ts-ignore\n            if (!isFinite(val) || /^\\s*$/.test(val))\n                return TronWeb.fromUtf8(val);\n        }\n\n        const result = TronWeb.fromDecimal(val as any);\n        if (result === '0xNaN')\n            throw new Error(\n                'The passed value is not convertible to a hex string',\n            );\n        else return result;\n    }\n    toHex(val: unknown): string {\n        return TronWeb.toHex(val);\n    }\n\n    static toUtf8(hex: string): string {\n        if (utils.isHex(hex)) {\n            hex = hex.replace(/^0x/, '');\n            return Buffer.from(hex, 'hex').toString('utf8');\n        } else {\n            throw new Error('The passed value is not a valid hex string');\n        }\n    }\n    toUtf8(hex: string): string {\n        return TronWeb.toUtf8(hex);\n    }\n\n    static fromUtf8(string: string): string {\n        if (!utils.isString(string))\n            throw new Error('The passed value is not a valid utf-8 string');\n\n        return '0x' + Buffer.from(string, 'utf8').toString('hex');\n    }\n    fromUtf8(string: string): string {\n        return TronWeb.fromUtf8(string);\n    }\n\n    static toAscii(hex: string): string {\n        if (utils.isHex(hex)) {\n            let str = '';\n            // FIXME: it's very bad\n            let i = hex.substring(0, 2) === '0x' ? 2 : 0;\n\n            for (; i < hex.length; i += 2) {\n                const code = parseInt(hex.substr(i, 2), 16);\n                str += String.fromCharCode(code);\n            }\n            return str;\n        } else {\n            throw new Error('The passed value is not a valid hex string');\n        }\n    }\n    toAscii(hex: string): string {\n        return TronWeb.toAscii(hex);\n    }\n\n    static fromAscii(string: string, padding = 0) {\n        if (!utils.isString(string))\n            throw new Error('The passed value is not a valid utf-8 string');\n\n        return (\n            '0x' +\n            Buffer.from(string, 'ascii').toString('hex').padEnd(padding, '0')\n        );\n    }\n    fromAscii(string: string, padding = 0) {\n        return TronWeb.fromAscii(string, padding);\n    }\n\n    static toDecimal(value: string | number | BigNumber): number {\n        return TronWeb.toBigNumber(value).toNumber();\n    }\n    toDecimal(value: string | number | BigNumber): number {\n        return TronWeb.toDecimal(value);\n    }\n\n    static fromDecimal(value: string | number | BigNumber): string {\n        const number = TronWeb.toBigNumber(value);\n        const result = number.toString(16);\n\n        return number.isLessThan(0) ? '-0x' + result.substr(1) : '0x' + result;\n    }\n    fromDecimal(value: string | number | BigNumber): string {\n        return TronWeb.fromDecimal(value);\n    }\n\n    static fromSun(sun: BigNumber): BigNumber;\n    static fromSun(sun: string | number): string;\n    static fromSun(sun: BigNumber | string | number): BigNumber | string {\n        const trx = TronWeb.toBigNumber(sun).div(1_000_000);\n        return utils.isBigNumber(sun) ? trx : trx.toString(10);\n    }\n    fromSun(sun: BigNumber): BigNumber;\n    fromSun(sun: string | number): string;\n    fromSun(sun: BigNumber | string | number): BigNumber | string {\n        return TronWeb.fromSun(sun as any);\n    }\n\n    static toSun(trx: BigNumber): BigNumber;\n    static toSun(trx: string | number): string;\n    static toSun(trx: BigNumber | string | number): BigNumber | string {\n        const sun = TronWeb.toBigNumber(trx).times(1_000_000);\n        return utils.isBigNumber(trx) ? sun : sun.toString(10);\n    }\n    toSun(trx: BigNumber): BigNumber;\n    toSun(trx: string | number): string;\n    toSun(trx: BigNumber | string | number): BigNumber | string {\n        return TronWeb.toSun(trx as any);\n    }\n\n    static toBigNumber(amount: string | number | BigNumber = 0): BigNumber {\n        if (utils.isBigNumber(amount)) return amount;\n\n        if (utils.isString(amount) && /^(-|)0x/.test(amount))\n            return new BigNumber(amount.replace('0x', ''), 16);\n\n        return new BigNumber(amount.toString(10), 10);\n    }\n    toBigNumber(amount: string | number | BigNumber = 0): BigNumber {\n        return TronWeb.toBigNumber(amount);\n    }\n\n    static isAddress(address: unknown): address is string {\n        if (!utils.isString(address)) return false;\n\n        // Convert HEX to Base58\n        if (address.length === 42)\n            try {\n                return TronWeb.isAddress(\n                    utils.crypto.getBase58CheckAddress(\n                        // it throws an error if the address starts with 0x\n                        utils.code.hexStr2byteArray(address),\n                    ),\n                );\n            } catch (err) {\n                return false;\n            }\n\n        try {\n            return utils.crypto.isAddressValid(address);\n        } catch (err) {\n            return false;\n        }\n    }\n    isAddress(address: unknown): address is string {\n        return TronWeb.isAddress(address);\n    }\n\n    static async createAccount() {\n        return utils.accounts.generateAccount();\n    }\n    async createAccount() {\n        return TronWeb.createAccount();\n    }\n\n    static createRandom(options = {}) {\n        return utils.accounts.generateRandom(options);\n    }\n    createRandom(options = {}) {\n        return TronWeb.createRandom(options);\n    }\n\n    static fromMnemonic(\n        mnemonic: string,\n        path = TRON_BIP39_PATH_INDEX_0,\n        wordlist = 'en',\n    ) {\n        return utils.accounts.generateAccountWithMnemonic(\n            mnemonic,\n            path,\n            wordlist,\n        );\n    }\n    fromMnemonic(\n        mnemonic: string,\n        path = TRON_BIP39_PATH_INDEX_0,\n        wordlist = 'en',\n    ) {\n        return TronWeb.fromMnemonic(mnemonic, path, wordlist);\n    }\n\n    async isConnected(callback?: undefined): Promise<any>;\n    async isConnected(callback: _CallbackT<any>): Promise<void>;\n    async isConnected(callback?: _CallbackT<any>): Promise<void | any> {\n        if (!callback) return this.injectPromise(this.isConnected);\n\n        return callback(null, {\n            fullNode: await this.fullNode.isConnected(),\n            solidityNode: await this.solidityNode.isConnected(),\n            eventServer:\n                this.eventServer && (await this.eventServer.isConnected()),\n        });\n    }\n}\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","version","WithTronwebAndInjectpromise","tronWeb","Error","this","injectPromise","injectpromise","ADDRESS_PREFIX","ADDRESS_PREFIX_REGEX","TRON_BIP39_PATH_INDEX_0","TRON_BIP39_PATH_PREFIX","keccak256","utils","sha256","toUtf8Bytes","toUtf8String","recoverAddress","SigningKey_","AbiCoder","Interface","FormatTypes","arrayify","splitSignature","joinSignature","concat","id","isValidMnemonic","SigningKey","privateKey","abiCoder","_addressToHex","TronWeb","address","toHex","replace","deepCopy","target","toString","newTarget","Array","isArray","decodeParams","names_","types_","output_","ignoreMethodHash_","ignoreMethodHash","output","types","names","length","substring","map","type","test","decode","reduce","arg","index","substr","toLowerCase","push","encodeParams","values","i","encode","extractSize","size","match","extractArrayDim","encodeParamsV2ByABI","funABI","args","buildFullTypeDefinition","typeDef","indexOf","components","innerTypes","innerType","join","convertAddresses","addrArr","forEach","addrs","mapTuple","dimension","encodeArgs","inputs","input","convertTypes","decodeParamsV2ByABI","data","decodeResult","buildFullTypeNameDefinition","name","outputs","result","outputTypes","convertTypeNames","Uint8Array","decodeResCopy","Base64","chr1","chr2","chr3","enc1","enc2","enc3","enc4","charCodeAt","isNaN","_keyStr","charAt","inputBytes","String","fromCharCode","_utf8_decode","_out2ByteArray","utftext","byteArray","string","n","c","c2","c3","byte2hexStr","byte","hexByteMap","bytesToString","arr","str","one","v","bytesLength","store","slice","st","parseInt","hextoString","hex","split","out","tmp","byteArray2hexStr","base64DecodeFromString","string64","decodeToByteArray","base64EncodeToString","bytes","encodeIgnoreUtf8","ALPHABET","ALPHABET_MAP","encode58","buffer","j","digits","carry","reverse","digit","decode58","bin2String","arrayEquals","array1","array2","strict","JSON","stringify","stringToBytes","len","hexChar2byte","isHexChar","hexStr2byteArray","k","strToDate","tempStrs","dateStrs","year","month","day","timeStrs","hour","minute","second","Date","isNumber","getStringType","logger","Logger","getTronAddress","text","padding","fill","NegativeOne","BigNumber","Zero","One","MaxUint256","hexTrue","hexZeroPad","toHexString","hexFalse","domainFieldTypes","chainId","verifyingContract","salt","domainFieldNames","checkString","throwArgumentError","domainChecks","error","hexlify","getBaseEncoder","signed","width","boundsUpper","mask","boundsLower","add","mul","lt","gt","toTwos","padOffset","hexConcat","hexPadRight","encodeType","fields","TypedDataEncoder","defineReadOnly","freeze","links","parents","subtypes","keys","uniqueNames","field","baseType","primaryTypes","filter","t","checkCircular","found","child","subtype","primaryType","sort","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","unshift","encodeData","hashStruct","callback","_visit","accum","from","domain","domainFields","b","EIP712Domain","hashDomain","hash","domainValues","domainTypes","typesWithDomain","shallowCopy","message","visit","EC","el","getBase58CheckAddress","addressBytes","checkSum","decodeBase58Address","base58String","error_msg","checkSum1","signTransaction","priKeyBytes","transaction","signature","getECKeySig","txID","includes","arrayToBase64String","btoa","signBytes","contents","_signTypedData","signingKey","messageDigest","signDigest","r","s","Number","getRowBytesFromTransactionBase64","base64Data","genPriKey","priKeyHex","genKeyPair","getPrivate","computeAddress","pubBytes","getAddressFromPriKey","getPubKeyFromPriKey","decode58Check","addressStr","decodeCheck","decodeData","isAddressValid","base58Str","getBase58CheckAddressFromPriKeyBase64String","priKeyBase64String","getHexStrAddressFromPriKeyBase64String","getAddressFromPriKeyBase64String","pubkey","keyFromPrivate","getPublic","xHex","x","padStart","yHex","y","hashBytes","sign","recoveryParam","ECKeySign","msgBytes","msgHex","ethSha256","SHA256","passwordToAddress","password","pkToAddress","com_priKeyBytes","com_addressBytes","INVALID_TRON_PATH_ERROR_MSG","generateAccount","pubKeyBytes","publicKey","base58","generateRandom","options","path","account","ethersWallet","mnemonic","generateAccountWithMnemonic","wordlist","TRON_MESSAGE_PREFIX","hashMessage","signMessage","verifyMessage","isValidURL","url","validator","protocols","require_tld","isObject","array","isJson","parse","ex","isBoolean","bool","isBigNumber","number","constructor","isString","isFunction","isHex","isInteger","hasProperty","property","hasProperties","properties","mapEvent","event","block","block_number","timestamp","block_timestamp","contract","contract_address","event_name","transaction_id","resourceNode","resource_Node","_unconfirmed","unconfirmed","_fingerprint","fingerprint","parseEvent","abi","padLeft","amount","res","isNotNullOrUndefined","val","sleep","millis","Promise","resolve","setTimeout","code","accounts","crypto","_TypedDataEncoder","ethersUtils","MISSING_ADDRESS_MSG","decodeOutput","Method","functionSelector","stateMutability","iface","getEvent","format","getFunction","getFunctionSelector","sha3","defaultOptions","feeLimit","callValue","userFeePercentage","shouldPollResponse","rawParameter","_call","send","defaultPrivateKey","_send","watch","_watch","bind","deployed","final_options","defaultAddress","_isConstant","parameters","transactionBuilder","triggerConstantContract","undefined","err","constant_result","msg","msg2","chunk","toUtf8","fromPrivateKey","triggerSmartContract","trx","signedTransaction","sendRawTransaction","broadcast","maxRetries","pollingInterval","checkResult","getTransactionInfo","resMessage","rawResponse","decoded","contractResult","keepTxID","eventServer","listener","lastBlock","since","now","getEvents","params","eventName","blockNumber","filters","onlyUnconfirmed","onlyConfirmed","getEventsByContractAddress","events","latestEvent","newEvents","some","priorEvent","reject","bindListener","clearInterval","setInterval","then","start","stop","Contract","eventListener","eventCallback","bytecode","methods","methodInstances","props","isAddress","loadAbi","_getEvents","console","__proto__","func","method","methodCall","onMethod","methodName","inputData","decodeInput","createSmartContract","at","contractAddress","getContract","entrys","self","startCallback","_startEventListener","_stopEventListener","HttpProvider","host","timeout","user","headers","statusPage","instance","axios","baseURL","auth","username","request","serviceName","payload","Event","healthcheck","providers","isValidProvider","isConnected","assign","sinceTimestamp","page","fromTimestamp","previousLastEventFingerprint","previousFingerprint","routeParams","warn","fromHex","qs","only_confirmed","only_unconfirmed","querystring","response","transactionID","getEventsByTransactionID","Plugin","pluginNoOverride","disablePlugins","PluginCls","pluginInterface","requires","libs","plugged","skipped","plugin","semver","fullClass","className","classInstanceName","component","compare","opts","gte","lte","Validator","param","Function","normalized","no","optional","notPositive","notEqual","invalid","INVALID_TX_MESSAGE","SideChain","sideOptions","TronWebCls","mainchain","depositFee","depositTrc","trxHash","mappingFee","mappingTrc","nonce","retryFee","mainGatewayAddress","sideGatewayAddress","sideChainId","sidechain","fullHost","fullNode","solidityNode","setMainGatewayAddress","setSideGatewayAddress","setChainId","multiSign","chainIdByteArr","_byteArr","byteArr","byteArrHash","permissionId","raw_data","Permission_id","getSignWeight","signWeight","foundKey","permission","approved_list","useTronHeader","multisig","signatureHex","signString","parameter","owner_address","depositTrx","notValid","contractInstance","depositTRX","tokenId","tokenValue","depositTrc10","depositTRC10","num","fee","approveInstance","approve","startsWith","mappingTRC20","mappingTRC721","withdrawFee","withdrawTrx","withdrawTRX","withdrawTrc10","withdrawTRC10","numOrId","withdrawTrc","injectFund","hexAddress","ResourceCode","TRX_MESSAGE_HEADER","ETH_MESSAGE_HEADER","INVALID_ADDRESS_MSG","INVALID_TOKEN_ID_MSG","TOKEN_DOES_NOT_EXIST_MSG","INVALID_TRANSACTION_MSG","INVALID_AMOUNT_MSG","NEED_PK_OR_ADDRESS_MSG","Trx","sendToken","sendTransaction","sendHexTransaction","getUnconfirmedTransaction","cache","contracts","token","abbr","description","getCurrentBlock","getConfirmedCurrentBlock","defaultBlock","getBlockByHash","getBlockByNumber","getBlock","blockHash","blockID","getBlockTransactionCount","transactions","getTransactionFromBlock","getTransaction","getConfirmedTransaction","_getTransactionInfoById","confirmed","limit","offset","getTransactionsRelated","direction","all","to","tx","getAccount","getAccountById","getAccountInfoById","account_id","getBalance","balance","getUnconfirmedAccount","getUnconfirmedAccountById","getUnconfirmedBalance","freeNetUsed","freeNetLimit","NetUsed","NetLimit","getBandwidth","assetIssue","tokens","_parseToken","getTokensIssuedByAddress","tokenID","fromUtf8","getTokenFromID","listNodes","nodes","port","end","startNum","endNum","getBlockRange","listSuperRepresentatives","witnesses","listTokens","timeUntilNextVoteCycle","Math","floor","verifySignature","verifyMessageV2","verifyTypedData","signMessageV2","getApprovedList","signedHexTransaction","hexTransaction","sendTrx","duration","resource","receiverAddress","freezeBalance","unfreezeBalance","accountName","updateAccount","proposalID","proposal","getProposal","listProposals","proposals","getChainParameters","chainParameter","resources","getAccountResources","exchangeID","exchange","getExchangeByID","listExchanges","exchanges","listExchangesPaginated","getNodeInfo","info","getTokenListByName","getTokenByID","_getReward","_getBrokerage","reward","brokerage","messageBytes","recovered","tronAddress","base58Address","INVALID_RESOURCE_MESSAGE","resultManager","TransactionBuilder","purchaseToken","createToken","updateToken","to_address","asset_name","issuerAddress","buyer","ResourceT","frozen_balance","frozen_duration","receiver_address","withdrawBlockRewards","applyForSR","votes","voterAddress","vote","votesArr","entries","srAddress","voteCount","vote_address","vote_count","originEnergyLimit","token_id","abi_arr","payable","funcABIV2","parametersV2","constructorParams","find","it","constructorParams2","fee_limit","call_value","consume_user_resource_percent","origin_energy_limit","call_token_value","_triggerSmartContract","estimateEnergy","param_str","shieldedParameter","function_selector","pathInfo","ownerAddress","clearABI","updateBrokerage","abbreviation","totalSupply","voteScore","precision","saleStart","saleEnd","trxRatio","tokenRatio","freeBandwidth","freeBandwidthLimit","frozenAmount","frozenDuration","total_supply","trx_num","start_time","end_time","free_asset_net_limit","public_free_asset_net_limit","frozen_supply","frozen_amount","frozen_days","vote_score","account_name","accountId","setAccountId","new_limit","new_public_limit","createProposal","deleteProposal","proposal_id","isApproval","voteProposal","is_add_approval","tokenName","tokenBalance","trxBalance","createTRXExchange","first_token_id","first_token_balance","second_token_id","second_token_balance","firstTokenName","firstTokenBalance","secondTokenName","secondTokenBalance","createTokenExchange","tokenAmount","injectExchangeTokens","exchange_id","quant","withdrawExchangeTokens","tokenAmountSold","tokenAmountExpected","tradeExchangeTokens","fromAscii","expected","updateSetting","updateEnergyLimit","permissions","permission_name","threshold","weight","operations","ownerPermissions","witnessPermissions","activesPermissions","updateAccountPermissions","checkPermissions","activesPermission","owner","witness","actives","newTxID","newTransaction","inner","visible","alterTransaction","sData","dataFormat","TypeError","extension","expiration","extendExpiration","addUpdateData","DEFAULT_VERSION","eventHeaders","setFullNode","setSolidityNode","setEventServer","setPrivateKey","setFullNodeHeader","setEventHeader","nodeInfo","fullnodeVersion","configNodeInfo","codeVersion","abs","addr","setAddress","emit","provider","knownProvider","setStatusPage","getFullnodeVersion","setServer","currentProviders","prefix","toAscii","toDecimal","fromDecimal","sun","fromSun","toSun","toBigNumber","createAccount","createRandom","fromMnemonic","Buffer","isFinite","padEnd","toNumber","isLessThan","div","times","EventEmitter"],"sourceRoot":""}