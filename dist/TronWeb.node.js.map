{"version":3,"file":"TronWeb.node.js","mappings":"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","sources":["webpack://tstron/./src/proto/core/Tron.ts","webpack://tstron/./src/proto/core/contract/account_contract.ts","webpack://tstron/./src/proto/core/contract/asset_issue_contract.ts","webpack://tstron/./src/proto/core/contract/balance_contract.ts","webpack://tstron/./src/proto/core/contract/common.ts","webpack://tstron/./src/proto/core/contract/exchange_contract.ts","webpack://tstron/./src/proto/core/contract/proposal_contract.ts","webpack://tstron/./src/proto/core/contract/smart_contract.ts","webpack://tstron/./src/proto/core/contract/storage_contract.ts","webpack://tstron/./src/proto/core/contract/witness_contract.ts","webpack://tstron/external commonjs \"@tronweb3/google-protobuf/google/protobuf/any_pb\"","webpack://tstron/webpack/bootstrap","webpack://tstron/webpack/runtime/compat get default export","webpack://tstron/webpack/runtime/define property getters","webpack://tstron/webpack/runtime/hasOwnProperty shorthand","webpack://tstron/webpack/runtime/make namespace object","webpack://tstron/external commonjs \"@babel/runtime/helpers/asyncToGenerator\"","webpack://tstron/external commonjs \"@babel/runtime/helpers/typeof\"","webpack://tstron/external commonjs \"@babel/runtime/helpers/classCallCheck\"","webpack://tstron/external commonjs \"@babel/runtime/helpers/createClass\"","webpack://tstron/external commonjs \"@babel/runtime/helpers/assertThisInitialized\"","webpack://tstron/external commonjs \"@babel/runtime/helpers/inherits\"","webpack://tstron/external commonjs \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack://tstron/external commonjs \"@babel/runtime/helpers/getPrototypeOf\"","webpack://tstron/external commonjs \"@babel/runtime/helpers/defineProperty\"","webpack://tstron/external commonjs \"@babel/runtime/regenerator\"","webpack://tstron/external commonjs \"bignumber.js\"","webpack://tstron/external commonjs \"eventemitter3\"","webpack://tstron/external commonjs \"injectpromise\"","webpack://tstron/external commonjs \"semver\"","webpack://tstron/./version.js","webpack://tstron/external commonjs \"@babel/runtime/helpers/slicedToArray\"","webpack://tstron/./src/utils/_base.ts","webpack://tstron/external commonjs \"validator\"","webpack://tstron/./src/utils/address.ts","webpack://tstron/external commonjs \"ethers\"","webpack://tstron/./src/utils/ethersUtils.ts","webpack://tstron/./src/utils/abi.ts","webpack://tstron/./src/utils/base64.ts","webpack://tstron/./src/utils/bytes.ts","webpack://tstron/external commonjs \"@babel/runtime/helpers/toConsumableArray\"","webpack://tstron/external commonjs \"elliptic\"","webpack://tstron/./src/utils/base58.ts","webpack://tstron/./src/utils/code.ts","webpack://tstron/external commonjs \"@ethersproject/bignumber\"","webpack://tstron/external commonjs \"@ethersproject/bytes\"","webpack://tstron/external commonjs \"@ethersproject/keccak256\"","webpack://tstron/external commonjs \"@ethersproject/logger\"","webpack://tstron/external commonjs \"@ethersproject/properties\"","webpack://tstron/external commonjs \"@ethersproject/strings\"","webpack://tstron/./src/utils/typedData.ts","webpack://tstron/./src/utils/crypto.ts","webpack://tstron/./src/utils/accounts.ts","webpack://tstron/./src/utils/message.ts","webpack://tstron/./src/utils/index.ts","webpack://tstron/./src/lib/contract/method.ts","webpack://tstron/./src/lib/contract/index.ts","webpack://tstron/external node-commonjs \"querystring\"","webpack://tstron/external commonjs \"axios\"","webpack://tstron/./src/lib/providers/HttpProvider.ts","webpack://tstron/./src/lib/providers/index.ts","webpack://tstron/./src/lib/event.ts","webpack://tstron/./src/lib/plugin.ts","webpack://tstron/./src/paramValidator/index.ts","webpack://tstron/./src/lib/sidechain.ts","webpack://tstron/./src/utils/transaction.ts","webpack://tstron/./src/lib/trx.ts","webpack://tstron/./src/lib/transactionBuilder.ts","webpack://tstron/./src/index.ts"],"sourcesContent":["/* eslint-disable */\nimport type {Any} from '../google/protobuf/any';\nimport type {Endpoint} from './Discover';\n\nexport const protobufPackage = 'protocol';\n\nexport const AccountType = {\n    Normal: 'Normal',\n    AssetIssue: 'AssetIssue',\n    Contract: 'Contract',\n} as const;\n\nexport type AccountType = typeof AccountType[keyof typeof AccountType];\n\nexport const ReasonCode = {\n    REQUESTED: 'REQUESTED',\n    BAD_PROTOCOL: 'BAD_PROTOCOL',\n    TOO_MANY_PEERS: 'TOO_MANY_PEERS',\n    DUPLICATE_PEER: 'DUPLICATE_PEER',\n    INCOMPATIBLE_PROTOCOL: 'INCOMPATIBLE_PROTOCOL',\n    NULL_IDENTITY: 'NULL_IDENTITY',\n    PEER_QUITING: 'PEER_QUITING',\n    UNEXPECTED_IDENTITY: 'UNEXPECTED_IDENTITY',\n    LOCAL_IDENTITY: 'LOCAL_IDENTITY',\n    PING_TIMEOUT: 'PING_TIMEOUT',\n    USER_REASON: 'USER_REASON',\n    RESET: 'RESET',\n    SYNC_FAIL: 'SYNC_FAIL',\n    FETCH_FAIL: 'FETCH_FAIL',\n    BAD_TX: 'BAD_TX',\n    BAD_BLOCK: 'BAD_BLOCK',\n    FORKED: 'FORKED',\n    UNLINKABLE: 'UNLINKABLE',\n    INCOMPATIBLE_VERSION: 'INCOMPATIBLE_VERSION',\n    INCOMPATIBLE_CHAIN: 'INCOMPATIBLE_CHAIN',\n    TIME_OUT: 'TIME_OUT',\n    CONNECT_FAIL: 'CONNECT_FAIL',\n    TOO_MANY_PEERS_WITH_SAME_IP: 'TOO_MANY_PEERS_WITH_SAME_IP',\n    LIGHT_NODE_SYNC_FAIL: 'LIGHT_NODE_SYNC_FAIL',\n    UNKNOWN: 'UNKNOWN',\n} as const;\n\nexport type ReasonCode = typeof ReasonCode[keyof typeof ReasonCode];\n\n/** AccountId, (name, address) use name, (null, address) use address, (name, null) use name, */\nexport interface AccountId {\n    name: string;\n    address: string;\n}\n\n/** vote message */\nexport interface Vote {\n    /** the super rep address */\n    vote_address: string;\n    /** the vote num to this super rep. */\n    vote_count: number;\n}\n\n/** Proposal */\nexport interface Proposal {\n    proposal_id: number;\n    proposer_address: string;\n    parameters: {key: number; value: number}[];\n    expiration_time: number;\n    create_time: number;\n    approvals: string[];\n    state: Proposal_State;\n}\n\nexport const Proposal_State = {\n    PENDING: 'PENDING',\n    DISAPPROVED: 'DISAPPROVED',\n    APPROVED: 'APPROVED',\n    CANCELED: 'CANCELED',\n} as const;\n\nexport type Proposal_State = typeof Proposal_State[keyof typeof Proposal_State];\n\nexport interface Proposal_ParametersEntry {\n    key: number;\n    value: number;\n}\n\n/** Exchange */\nexport interface Exchange {\n    exchange_id: number;\n    creator_address: string;\n    create_time: number;\n    first_token_id: string;\n    first_token_balance: number;\n    second_token_id: string;\n    second_token_balance: number;\n}\n\n/** market */\nexport interface MarketOrder {\n    order_id: string;\n    owner_address: string;\n    create_time: number;\n    sell_token_id: string;\n    sell_token_quantity: number;\n    buy_token_id: string;\n    /** min to receive */\n    buy_token_quantity: number;\n    sell_token_quantity_remain: number;\n    /**\n     * When state != ACTIVE and sell_token_quantity_return !=0,\n     * it means that some sell tokens are returned to the account due to insufficient remaining amount\n     */\n    sell_token_quantity_return: number;\n    state: MarketOrder_State;\n    prev: string;\n    next: string;\n}\n\nexport const MarketOrder_State = {\n    ACTIVE: 'ACTIVE',\n    INACTIVE: 'INACTIVE',\n    CANCELED: 'CANCELED',\n} as const;\n\nexport type MarketOrder_State =\n    typeof MarketOrder_State[keyof typeof MarketOrder_State];\n\nexport interface MarketOrderList {\n    orders: MarketOrder[];\n}\n\nexport interface MarketOrderPairList {\n    orderPair: MarketOrderPair[];\n}\n\nexport interface MarketOrderPair {\n    sell_token_id: string;\n    buy_token_id: string;\n}\n\nexport interface MarketAccountOrder {\n    owner_address: string;\n    /** order_id list */\n    orders: string[];\n    /** active count */\n    count: number;\n    total_count: number;\n}\n\nexport interface MarketPrice {\n    sell_token_quantity: number;\n    buy_token_quantity: number;\n}\n\nexport interface MarketPriceList {\n    sell_token_id: string;\n    buy_token_id: string;\n    prices: MarketPrice[];\n}\n\nexport interface MarketOrderIdList {\n    head: string;\n    tail: string;\n}\n\nexport interface ChainParameters {\n    chainParameter: ChainParameters_ChainParameter[];\n}\n\nexport interface ChainParameters_ChainParameter {\n    key: string;\n    value: number;\n}\n\n/** Account */\nexport interface Account {\n    /** account nick name */\n    account_name: string;\n    type: AccountType;\n    /** the create address */\n    address: string;\n    /** the trx balance */\n    balance: number;\n    /** the votes */\n    votes: Vote[];\n    /** the other asset owned by this account */\n    asset: {key: string; value: number}[];\n    /** the other asset owned by this account，key is assetId */\n    assetV2: {key: string; value: number}[];\n    /** the frozen balance for bandwidth */\n    frozen: Account_Frozen[];\n    /** bandwidth, get from frozen */\n    net_usage: number;\n    /** Frozen balance provided by other accounts to this account */\n    acquired_delegated_frozen_balance_for_bandwidth: number;\n    /** Freeze and provide balances to other accounts */\n    delegated_frozen_balance_for_bandwidth: number;\n    old_tron_power: number;\n    tron_power: Account_Frozen | undefined;\n    asset_optimized: boolean;\n    /** this account create time */\n    create_time: number;\n    /** this last operation time, including transfer, voting and so on. //FIXME fix grammar */\n    latest_opration_time: number;\n    /** witness block producing allowance */\n    allowance: number;\n    /** last withdraw time */\n    latest_withdraw_time: number;\n    /** not used so far */\n    code: string;\n    is_witness: boolean;\n    is_committee: boolean;\n    /** frozen asset(for asset issuer) */\n    frozen_supply: Account_Frozen[];\n    /** asset_issued_name */\n    asset_issued_name: string;\n    asset_issued_ID: string;\n    latest_asset_operation_time: {key: string; value: number}[];\n    latest_asset_operation_timeV2: {key: string; value: number}[];\n    free_net_usage: number;\n    free_asset_net_usage: {key: string; value: number}[];\n    free_asset_net_usageV2: {key: string; value: number}[];\n    latest_consume_time: number;\n    latest_consume_free_time: number;\n    /** the identity of this account, case insensitive */\n    account_id: string;\n    account_resource: Account_AccountResource | undefined;\n    codeHash: string;\n    owner_permission: Permission | undefined;\n    witness_permission: Permission | undefined;\n    active_permission: Permission[];\n}\n\n/** frozen balance */\nexport interface Account_Frozen {\n    /** the frozen trx balance */\n    frozen_balance: number;\n    /** the expire time */\n    expire_time: number;\n}\n\nexport interface Account_AssetEntry {\n    key: string;\n    value: number;\n}\n\nexport interface Account_AssetV2Entry {\n    key: string;\n    value: number;\n}\n\nexport interface Account_LatestAssetOperationTimeEntry {\n    key: string;\n    value: number;\n}\n\nexport interface Account_LatestAssetOperationTimeV2Entry {\n    key: string;\n    value: number;\n}\n\nexport interface Account_FreeAssetNetUsageEntry {\n    key: string;\n    value: number;\n}\n\nexport interface Account_FreeAssetNetUsageV2Entry {\n    key: string;\n    value: number;\n}\n\nexport interface Account_AccountResource {\n    /** energy resource, get from frozen */\n    energy_usage: number;\n    /** the frozen balance for energy */\n    frozen_balance_for_energy: Account_Frozen | undefined;\n    latest_consume_time_for_energy: number;\n    /** Frozen balance provided by other accounts to this account */\n    acquired_delegated_frozen_balance_for_energy: number;\n    /** Frozen balances provided to other accounts */\n    delegated_frozen_balance_for_energy: number;\n    /** storage resource, get from market */\n    storage_limit: number;\n    storage_usage: number;\n    latest_exchange_storage_time: number;\n}\n\nexport interface Key {\n    address: string;\n    weight: number;\n}\n\nexport interface DelegatedResource {\n    from: string;\n    to: string;\n    frozen_balance_for_bandwidth: number;\n    frozen_balance_for_energy: number;\n    expire_time_for_bandwidth: number;\n    expire_time_for_energy: number;\n}\n\nexport interface authority {\n    account: AccountId | undefined;\n    permission_name: string;\n}\n\nexport interface Permission {\n    type: Permission_PermissionType;\n    /** Owner id=0, Witness id=1, Active id start by 2 */\n    id: number;\n    permission_name: string;\n    threshold: number;\n    parent_id: number;\n    /** 1 bit 1 contract */\n    operations: string;\n    keys: Key[];\n}\n\nexport const Permission_PermissionType = {\n    Owner: 0,\n    Witness: 1,\n    Active: 2,\n} as const;\n\nexport type Permission_PermissionType =\n    typeof Permission_PermissionType[keyof typeof Permission_PermissionType];\n\n/** Witness */\nexport interface Witness {\n    address: string;\n    voteCount: number;\n    pubKey: string;\n    url: string;\n    totalProduced: number;\n    totalMissed: number;\n    latestBlockNum: number;\n    latestSlotNum: number;\n    isJobs: boolean;\n}\n\n/** Vote Change */\nexport interface Votes {\n    address: string;\n    old_votes: Vote[];\n    new_votes: Vote[];\n}\n\nexport interface TXOutput {\n    value: number;\n    pubKeyHash: string;\n}\n\nexport interface TXInput {\n    raw_data: TXInput_raw | undefined;\n    signature: string;\n}\n\nexport interface TXInput_raw {\n    txID: string;\n    vout: number;\n    pubKey: string;\n}\n\nexport interface TXOutputs {\n    outputs: TXOutput[];\n}\n\nexport interface ResourceReceipt {\n    energy_usage: number;\n    energy_fee: number;\n    origin_energy_usage: number;\n    energy_usage_total: number;\n    net_usage: number;\n    net_fee: number;\n    result: Transaction_Result_contractResult;\n}\n\nexport interface MarketOrderDetail {\n    makerOrderId: string;\n    takerOrderId: string;\n    fillSellQuantity: number;\n    fillBuyQuantity: number;\n}\n\nexport interface Transaction {\n    raw_data: Transaction_raw;\n    /** only support size = 1,  repeated list here for muti-sig extension */\n    signature: string[];\n    ret: Transaction_Result[];\n    visible?: boolean;\n    txID: string;\n    raw_data_hex: string;\n}\n\nexport interface EstimateEnergyResponse {\n    result: Object | string\n    energy_required: string\n}\n\nexport interface EstimatePrices {\n    prices: MarketPrice[]\n}\nexport interface Transaction_Contract {\n    type: Transaction_Contract_ContractType;\n    parameter: Any;\n    provider: string;\n    ContractName: string;\n    Permission_id: number;\n}\n\nexport const Transaction_Contract_ContractType = {\n    AccountCreateContract: 'AccountCreateContract',\n    TransferContract: 'TransferContract',\n    TransferAssetContract: 'TransferAssetContract',\n    VoteAssetContract: 'VoteAssetContract',\n    VoteWitnessContract: 'VoteWitnessContract',\n    WitnessCreateContract: 'WitnessCreateContract',\n    AssetIssueContract: 'AssetIssueContract',\n    WitnessUpdateContract: 'WitnessUpdateContract',\n    ParticipateAssetIssueContract: 'ParticipateAssetIssueContract',\n    AccountUpdateContract: 'AccountUpdateContract',\n    FreezeBalanceContract: 'FreezeBalanceContract',\n    UnfreezeBalanceContract: 'UnfreezeBalanceContract',\n    WithdrawBalanceContract: 'WithdrawBalanceContract',\n    UnfreezeAssetContract: 'UnfreezeAssetContract',\n    UpdateAssetContract: 'UpdateAssetContract',\n    ProposalCreateContract: 'ProposalCreateContract',\n    ProposalApproveContract: 'ProposalApproveContract',\n    ProposalDeleteContract: 'ProposalDeleteContract',\n    SetAccountIdContract: 'SetAccountIdContract',\n    CustomContract: 'CustomContract',\n    CreateSmartContract: 'CreateSmartContract',\n    TriggerSmartContract: 'TriggerSmartContract',\n    GetContract: 'GetContract',\n    UpdateSettingContract: 'UpdateSettingContract',\n    ExchangeCreateContract: 'ExchangeCreateContract',\n    ExchangeInjectContract: 'ExchangeInjectContract',\n    ExchangeWithdrawContract: 'ExchangeWithdrawContract',\n    ExchangeTransactionContract: 'ExchangeTransactionContract',\n    UpdateEnergyLimitContract: 'UpdateEnergyLimitContract',\n    AccountPermissionUpdateContract: 'AccountPermissionUpdateContract',\n    ClearABIContract: 'ClearABIContract',\n    UpdateBrokerageContract: 'UpdateBrokerageContract',\n    ShieldedTransferContract: 'ShieldedTransferContract',\n    MarketSellAssetContract: 'MarketSellAssetContract',\n    MarketCancelOrderContract: 'MarketCancelOrderContract',\n} as const;\n\nexport type Transaction_Contract_ContractType =\n    typeof Transaction_Contract_ContractType[keyof typeof Transaction_Contract_ContractType];\n\nexport interface Transaction_Result {\n    fee: number;\n    ret: Transaction_Result_code;\n    contractRet: Transaction_Result_contractResult;\n    assetIssueID: string;\n    withdraw_amount: number;\n    unfreeze_amount: number;\n    exchange_received_amount: number;\n    exchange_inject_another_amount: number;\n    exchange_withdraw_another_amount: number;\n    exchange_id: number;\n    shielded_transaction_fee: number;\n    orderId: string;\n    orderDetails: MarketOrderDetail[];\n}\n\nexport const Transaction_Result_code = {\n    SUCESS: 'SUCESS',\n    FAILED: 'FAILED',\n} as const;\n\nexport type Transaction_Result_code =\n    typeof Transaction_Result_code[keyof typeof Transaction_Result_code];\n\nexport const Transaction_Result_contractResult = {\n    DEFAULT: 'DEFAULT',\n    SUCCESS: 'SUCCESS',\n    REVERT: 'REVERT',\n    BAD_JUMP_DESTINATION: 'BAD_JUMP_DESTINATION',\n    OUT_OF_MEMORY: 'OUT_OF_MEMORY',\n    PRECOMPILED_CONTRACT: 'PRECOMPILED_CONTRACT',\n    STACK_TOO_SMALL: 'STACK_TOO_SMALL',\n    STACK_TOO_LARGE: 'STACK_TOO_LARGE',\n    ILLEGAL_OPERATION: 'ILLEGAL_OPERATION',\n    STACK_OVERFLOW: 'STACK_OVERFLOW',\n    OUT_OF_ENERGY: 'OUT_OF_ENERGY',\n    OUT_OF_TIME: 'OUT_OF_TIME',\n    JVM_STACK_OVER_FLOW: 'JVM_STACK_OVER_FLOW',\n    UNKNOWN: 'UNKNOWN',\n    TRANSFER_FAILED: 'TRANSFER_FAILED',\n    INVALID_CODE: 'INVALID_CODE',\n} as const;\n\nexport type Transaction_Result_contractResult =\n    typeof Transaction_Result_contractResult[keyof typeof Transaction_Result_contractResult];\n\nexport interface Transaction_raw {\n    ref_block_bytes: string;\n    ref_block_num: number;\n    ref_block_hash: string;\n    expiration: number;\n    auths: authority[];\n    /** data not used */\n    data: string;\n    /** only support size = 1,  repeated list here for extension */\n    contract: Transaction_Contract[];\n    /** scripts not used */\n    scripts: string;\n    timestamp: number;\n    fee_limit: number;\n}\n\nexport interface TransactionInfo {\n    id: string;\n    fee: number;\n    blockNumber: number;\n    blockTimeStamp: number;\n    contractResult: string[];\n    contract_address: string;\n    receipt: ResourceReceipt | undefined;\n    log: TransactionInfo_Log[];\n    result?: TransactionInfo_code;\n    resMessage?: string;\n    assetIssueID?: string;\n    withdraw_amount?: number;\n    unfreeze_amount?: number;\n    internal_transactions?: InternalTransaction[];\n    exchange_received_amount?: number;\n    exchange_inject_another_amount?: number;\n    exchange_withdraw_another_amount?: number;\n    exchange_id?: number;\n    shielded_transaction_fee?: number;\n    orderId?: string;\n    orderDetails?: MarketOrderDetail[];\n    packingFee?: number;\n}\n\nexport const TransactionInfo_code = {\n    SUCESS: 'SUCESS',\n    FAILED: 'FAILED',\n} as const;\n\nexport type TransactionInfo_code =\n    typeof TransactionInfo_code[keyof typeof TransactionInfo_code];\n\nexport interface TransactionInfo_Log {\n    address: string;\n    topics: string[];\n    data: string;\n}\n\nexport interface TransactionRet {\n    blockNumber: number;\n    blockTimeStamp: number;\n    transactioninfo: TransactionInfo[];\n}\n\nexport interface Transactions {\n    transactions: Transaction[];\n}\n\nexport interface TransactionSign {\n    transaction: Transaction | undefined;\n    privateKey: string;\n}\n\nexport interface BlockHeader {\n    raw_data: BlockHeader_raw;\n    witness_signature: string;\n}\n\nexport interface BlockHeader_raw {\n    timestamp: number;\n    txTrieRoot: string;\n    parentHash: string;\n    /**\n     * bytes nonce = 5;\n     * bytes difficulty = 6;\n     */\n    number: number;\n    witness_id: number;\n    witness_address: string;\n    version: number;\n    accountStateRoot: string;\n}\n\n/** block */\nexport interface Block {\n    transactions: Transaction[];\n    block_header: BlockHeader | undefined;\n}\n\nexport interface ChainInventory {\n    ids: ChainInventory_BlockId[];\n    remain_num: number;\n}\n\nexport interface ChainInventory_BlockId {\n    hash: string;\n    number: number;\n}\n\n/** Inventory */\nexport interface BlockInventory {\n    ids: BlockInventory_BlockId[];\n    type: BlockInventory_Type;\n}\n\nexport const BlockInventory_Type = {\n    SYNC: 'SYNC',\n    ADVTISE: 'ADVTISE',\n    FETCH: 'FETCH',\n} as const;\n\nexport type BlockInventory_Type =\n    typeof BlockInventory_Type[keyof typeof BlockInventory_Type];\n\nexport interface BlockInventory_BlockId {\n    hash: string;\n    number: number;\n}\n\nexport interface Inventory {\n    type: Inventory_InventoryType;\n    ids: string[];\n}\n\nexport const Inventory_InventoryType = {TRX: 'TRX', BLOCK: 'BLOCK'} as const;\n\nexport type Inventory_InventoryType =\n    typeof Inventory_InventoryType[keyof typeof Inventory_InventoryType];\n\nexport interface Items {\n    type: Items_ItemType;\n    blocks: Block[];\n    block_headers: BlockHeader[];\n    transactions: Transaction[];\n}\n\nexport const Items_ItemType = {\n    ERR: 'ERR',\n    TRX: 'TRX',\n    BLOCK: 'BLOCK',\n    BLOCKHEADER: 'BLOCKHEADER',\n} as const;\n\nexport type Items_ItemType = typeof Items_ItemType[keyof typeof Items_ItemType];\n\n/** DynamicProperties */\nexport interface DynamicProperties {\n    last_solidity_block_num: number;\n}\n\nexport interface DisconnectMessage {\n    reason: ReasonCode;\n}\n\nexport interface HelloMessage {\n    from: Endpoint | undefined;\n    version: number;\n    timestamp: number;\n    genesisBlockId: HelloMessage_BlockId | undefined;\n    solidBlockId: HelloMessage_BlockId | undefined;\n    headBlockId: HelloMessage_BlockId | undefined;\n    address: string;\n    signature: string;\n    nodeType: number;\n    lowestBlockNum: number;\n}\n\nexport interface HelloMessage_BlockId {\n    hash: string;\n    number: number;\n}\n\nexport interface InternalTransaction {\n    /**\n     * internalTransaction identity, the root InternalTransaction hash\n     * should equals to root transaction id.\n     */\n    hash: string;\n    /** the one send trx (TBD: or token) via function */\n    caller_address: string;\n    /** the one recieve trx (TBD: or token) via function */\n    transferTo_address: string;\n    callValueInfo: InternalTransaction_CallValueInfo[];\n    note: string;\n    rejected: boolean;\n    extra: string;\n}\n\nexport interface InternalTransaction_CallValueInfo {\n    /** trx (TBD: or token) value */\n    callValue: number;\n    /** TBD: tokenName, trx should be empty */\n    tokenId: string;\n}\n\nexport interface DelegatedResourceAccountIndex {\n    account: string;\n    fromAccounts: string[];\n    toAccounts: string[];\n}\n\nexport interface NodeInfo {\n    beginSyncNum: number;\n    block: string;\n    solidityBlock: string;\n    /** connect information */\n    currentConnectCount: number;\n    activeConnectCount: number;\n    passiveConnectCount: number;\n    totalFlow: number;\n    peerInfoList: NodeInfo_PeerInfo[];\n    configNodeInfo: NodeInfo_ConfigNodeInfo | undefined;\n    machineInfo: NodeInfo_MachineInfo | undefined;\n    cheatWitnessInfoMap: {key: string; value: string}[];\n}\n\nexport interface NodeInfo_CheatWitnessInfoMapEntry {\n    key: string;\n    value: string;\n}\n\nexport interface NodeInfo_PeerInfo {\n    lastSyncBlock: string;\n    remainNum: number;\n    lastBlockUpdateTime: number;\n    syncFlag: boolean;\n    headBlockTimeWeBothHave: number;\n    needSyncFromPeer: boolean;\n    needSyncFromUs: boolean;\n    host: string;\n    port: number;\n    nodeId: string;\n    connectTime: number;\n    avgLatency: number;\n    syncToFetchSize: number;\n    syncToFetchSizePeekNum: number;\n    syncBlockRequestedSize: number;\n    unFetchSynNum: number;\n    blockInPorcSize: number;\n    headBlockWeBothHave: string;\n    isActive: boolean;\n    score: number;\n    nodeCount: number;\n    inFlow: number;\n    disconnectTimes: number;\n    localDisconnectReason: string;\n    remoteDisconnectReason: string;\n}\n\nexport interface NodeInfo_ConfigNodeInfo {\n    codeVersion: string;\n    p2pVersion: string;\n    listenPort: number;\n    discoverEnable: boolean;\n    activeNodeSize: number;\n    passiveNodeSize: number;\n    sendNodeSize: number;\n    maxConnectCount: number;\n    sameIpMaxConnectCount: number;\n    backupListenPort: number;\n    backupMemberSize: number;\n    backupPriority: number;\n    dbVersion: number;\n    minParticipationRate: number;\n    supportConstant: boolean;\n    minTimeRatio: number;\n    maxTimeRatio: number;\n    allowCreationOfContracts: number;\n    allowAdaptiveEnergy: number;\n}\n\nexport interface NodeInfo_MachineInfo {\n    threadCount: number;\n    deadLockThreadCount: number;\n    cpuCount: number;\n    totalMemory: number;\n    freeMemory: number;\n    cpuRate: number;\n    javaVersion: string;\n    osName: string;\n    jvmTotalMemory: number;\n    jvmFreeMemory: number;\n    processCpuRate: number;\n    memoryDescInfoList: NodeInfo_MachineInfo_MemoryDescInfo[];\n    deadLockThreadInfoList: NodeInfo_MachineInfo_DeadLockThreadInfo[];\n}\n\nexport interface NodeInfo_MachineInfo_MemoryDescInfo {\n    name: string;\n    initSize: number;\n    useSize: number;\n    maxSize: number;\n    useRate: number;\n}\n\nexport interface NodeInfo_MachineInfo_DeadLockThreadInfo {\n    name: string;\n    lockName: string;\n    lockOwner: string;\n    state: string;\n    blockTime: number;\n    waitTime: number;\n    stackTrace: string;\n}\n\nexport interface MetricsInfo {\n    interval: number;\n    node: MetricsInfo_NodeInfo | undefined;\n    blockchain: MetricsInfo_BlockChainInfo | undefined;\n    net: MetricsInfo_NetInfo | undefined;\n}\n\nexport interface MetricsInfo_NodeInfo {\n    ip: string;\n    nodeType: number;\n    version: string;\n    backupStatus: number;\n}\n\nexport interface MetricsInfo_BlockChainInfo {\n    headBlockNum: number;\n    headBlockTimestamp: number;\n    headBlockHash: string;\n    forkCount: number;\n    failForkCount: number;\n    blockProcessTime: MetricsInfo_RateInfo | undefined;\n    tps: MetricsInfo_RateInfo | undefined;\n    transactionCacheSize: number;\n    missedTransaction: MetricsInfo_RateInfo | undefined;\n    witnesses: MetricsInfo_BlockChainInfo_Witness[];\n    failProcessBlockNum: number;\n    failProcessBlockReason: string;\n    dupWitness: MetricsInfo_BlockChainInfo_DupWitness[];\n}\n\nexport interface MetricsInfo_BlockChainInfo_Witness {\n    address: string;\n    version: number;\n}\n\nexport interface MetricsInfo_BlockChainInfo_DupWitness {\n    address: string;\n    blockNum: number;\n    count: number;\n}\n\nexport interface MetricsInfo_RateInfo {\n    count: number;\n    meanRate: number;\n    oneMinuteRate: number;\n    fiveMinuteRate: number;\n    fifteenMinuteRate: number;\n}\n\nexport interface MetricsInfo_NetInfo {\n    errorProtoCount: number;\n    api: MetricsInfo_NetInfo_ApiInfo | undefined;\n    connectionCount: number;\n    validConnectionCount: number;\n    tcpInTraffic: MetricsInfo_RateInfo | undefined;\n    tcpOutTraffic: MetricsInfo_RateInfo | undefined;\n    disconnectionCount: number;\n    disconnectionDetail: MetricsInfo_NetInfo_DisconnectionDetailInfo[];\n    udpInTraffic: MetricsInfo_RateInfo | undefined;\n    udpOutTraffic: MetricsInfo_RateInfo | undefined;\n    latency: MetricsInfo_NetInfo_LatencyInfo | undefined;\n}\n\nexport interface MetricsInfo_NetInfo_ApiInfo {\n    qps: MetricsInfo_RateInfo | undefined;\n    failQps: MetricsInfo_RateInfo | undefined;\n    outTraffic: MetricsInfo_RateInfo | undefined;\n    detail: MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo[];\n}\n\nexport interface MetricsInfo_NetInfo_ApiInfo_ApiDetailInfo {\n    name: string;\n    qps: MetricsInfo_RateInfo | undefined;\n    failQps: MetricsInfo_RateInfo | undefined;\n    outTraffic: MetricsInfo_RateInfo | undefined;\n}\n\nexport interface MetricsInfo_NetInfo_DisconnectionDetailInfo {\n    reason: string;\n    count: number;\n}\n\nexport interface MetricsInfo_NetInfo_LatencyInfo {\n    top99: number;\n    top95: number;\n    top75: number;\n    totalCount: number;\n    delay1S: number;\n    delay2S: number;\n    delay3S: number;\n    detail: MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo[];\n}\n\nexport interface MetricsInfo_NetInfo_LatencyInfo_LatencyDetailInfo {\n    witness: string;\n    top99: number;\n    top95: number;\n    top75: number;\n    count: number;\n    delay1S: number;\n    delay2S: number;\n    delay3S: number;\n}\n\nexport interface PBFTMessage {\n    raw_data: PBFTMessage_Raw | undefined;\n    signature: string;\n}\n\nexport const PBFTMessage_MsgType = {\n    VIEW_CHANGE: 'VIEW_CHANGE',\n    REQUEST: 'REQUEST',\n    PREPREPARE: 'PREPREPARE',\n    PREPARE: 'PREPARE',\n    COMMIT: 'COMMIT',\n} as const;\n\nexport type PBFTMessage_MsgType =\n    typeof PBFTMessage_MsgType[keyof typeof PBFTMessage_MsgType];\n\nexport const PBFTMessage_DataType = {BLOCK: 'BLOCK', SRL: 'SRL'} as const;\n\nexport type PBFTMessage_DataType =\n    typeof PBFTMessage_DataType[keyof typeof PBFTMessage_DataType];\n\nexport interface PBFTMessage_Raw {\n    msg_type: PBFTMessage_MsgType;\n    data_type: PBFTMessage_DataType;\n    view_n: number;\n    epoch: number;\n    data: string;\n}\n\nexport interface PBFTCommitResult {\n    data: string;\n    signature: string[];\n}\n\nexport interface SRL {\n    srAddress: string[];\n}\n","/* eslint-disable */\nimport type {AccountType, Permission} from '../Tron';\n\nexport const protobufPackage = 'protocol';\n\nexport interface AccountCreateContract {\n    owner_address: string;\n    account_address: string;\n    type: AccountType;\n}\n\n/** Update account name. Account name is not unique now. */\nexport interface AccountUpdateContract {\n    account_name: string;\n    owner_address: string;\n}\n\n/** Set account id if the account has no id. Account id is unique and case insensitive. */\nexport interface SetAccountIdContract {\n    account_id: string;\n    owner_address: string;\n}\n\nexport interface AccountPermissionUpdateContract {\n    owner_address: string;\n    /** Empty is invalidate */\n    owner: Permission | undefined;\n    /** Can be empty */\n    witness: Permission | undefined;\n    /** Empty is invalidate */\n    actives: Permission[];\n}\n","/* eslint-disable */\n\nexport const protobufPackage = 'protocol';\n\nexport interface AssetIssueContract {\n    id: string;\n    owner_address: string;\n    name: string;\n    abbr: string;\n    total_supply: number;\n    frozen_supply: AssetIssueContract_FrozenSupply;\n    trx_num: number;\n    precision: number;\n    num: number;\n    start_time: number;\n    end_time: number;\n    /** useless */\n    order: number;\n    vote_score: number;\n    description: string;\n    url: string;\n    free_asset_net_limit: number;\n    public_free_asset_net_limit: number;\n    public_free_asset_net_usage: number;\n    public_latest_free_net_time: number;\n}\n\nexport interface AssetIssueContract_FrozenSupply {\n    frozen_amount: number;\n    frozen_days: number;\n}\n\nexport interface TransferAssetContract {\n    /** this field is token name before the proposal ALLOW_SAME_TOKEN_NAME is active, otherwise it is token id and token is should be in string format. */\n    asset_name: string;\n    owner_address: string;\n    to_address: string;\n    amount: number;\n}\n\nexport interface UnfreezeAssetContract {\n    owner_address: string;\n}\n\nexport interface UpdateAssetContract {\n    owner_address: string;\n    description: string;\n    url: string;\n    new_limit: number;\n    new_public_limit: number;\n}\n\nexport interface ParticipateAssetIssueContract {\n    owner_address: string;\n    to_address: string;\n    /** this field is token name before the proposal ALLOW_SAME_TOKEN_NAME is active, otherwise it is token id and token is should be in string format. */\n    asset_name: string;\n    /** the amount of drops */\n    amount: number;\n}\n\n\nexport interface EnergyEstimateContract {\n    owner_address: string\n    contract_address: string;\n    function_selector: string;\n    parameter: string;\n    visible: boolean\n}\n","/* eslint-disable */\nimport type {ResourceCode} from './common';\n\nexport const protobufPackage = 'protocol';\n\nexport interface FreezeBalanceContract {\n    owner_address: string;\n    frozen_balance: number;\n    frozen_duration: number;\n    resource: ResourceCode;\n    receiver_address?: string | undefined;\n}\n\nexport interface UnfreezeBalanceContract {\n    owner_address: string;\n    resource: ResourceCode;\n    receiver_address?: string | undefined;\n}\n\nexport interface WithdrawBalanceContract {\n    owner_address: string;\n}\n\nexport interface TransferContract {\n    owner_address: string;\n    to_address: string;\n    amount: number;\n}\n\nexport interface TransactionBalanceTrace {\n    transaction_identifier: string;\n    operation: TransactionBalanceTrace_Operation[];\n    type: string;\n    status: string;\n}\n\nexport interface TransactionBalanceTrace_Operation {\n    operation_identifier: number;\n    address: string;\n    amount: number;\n}\n\nexport interface BlockBalanceTrace {\n    block_identifier: BlockBalanceTrace_BlockIdentifier | undefined;\n    timestamp: number;\n    /** BlockIdentifier parent_block_identifier = 4; */\n    transaction_balance_trace: TransactionBalanceTrace[];\n}\n\nexport interface BlockBalanceTrace_BlockIdentifier {\n    hash: string;\n    number: number;\n}\n\nexport interface AccountTrace {\n    balance: number;\n    placeholder: number;\n}\n\nexport interface AccountIdentifier {\n    address: string;\n}\n\nexport interface AccountBalanceRequest {\n    account_identifier: AccountIdentifier | undefined;\n    block_identifier: BlockBalanceTrace_BlockIdentifier | undefined;\n}\n\nexport interface AccountBalanceResponse {\n    balance: number;\n    block_identifier: BlockBalanceTrace_BlockIdentifier | undefined;\n}\n","/* eslint-disable */\n\nexport const protobufPackage = 'protocol';\n\nexport const ResourceCode = {\n    BANDWIDTH: 'BANDWIDTH',\n    ENERGY: 'ENERGY',\n    TRON_POWER: 'TRON_POWER',\n} as const;\n\nexport type ResourceCode = typeof ResourceCode[keyof typeof ResourceCode];\n","/* eslint-disable */\n\nexport const protobufPackage = 'protocol';\n\nexport interface ExchangeCreateContract {\n    owner_address: string;\n    first_token_id: string;\n    first_token_balance: number;\n    second_token_id: string;\n    second_token_balance: number;\n}\n\nexport interface ExchangeInjectContract {\n    owner_address: string;\n    exchange_id: number;\n    token_id: string;\n    quant: number;\n}\n\nexport interface ExchangeWithdrawContract {\n    owner_address: string;\n    exchange_id: number;\n    token_id: string;\n    quant: number;\n}\n\nexport interface ExchangeTransactionContract {\n    owner_address: string;\n    exchange_id: number;\n    token_id: string;\n    quant: number;\n    expected: number;\n}\n","/* eslint-disable */\n\nexport const protobufPackage = 'protocol';\n\nexport interface ProposalApproveContract {\n    owner_address: string;\n    proposal_id: number;\n    /** add or remove approval */\n    is_add_approval: boolean;\n}\n\nexport interface ProposalCreateContract {\n    owner_address: string;\n    parameters: {key: number; value: number}[];\n}\n\nexport interface ProposalCreateContract_ParametersEntry {\n    key: number;\n    value: number;\n}\n\nexport interface ProposalDeleteContract {\n    owner_address: string;\n    proposal_id: number;\n}\n","/* eslint-disable */\n\nexport const protobufPackage = 'protocol';\n\nexport interface SmartContract {\n    origin_address: string;\n    contract_address: string;\n    abi: SmartContract_ABI | undefined;\n    bytecode: string;\n    call_value: number;\n    consume_user_resource_percent: number;\n    name: string;\n    origin_energy_limit: number;\n    code_hash: string;\n    trx_hash: string;\n}\n\nexport interface SmartContract_ABI {\n    entrys: SmartContract_ABI_Entry[];\n}\n\nexport interface SmartContract_ABI_Entry {\n    anonymous?: boolean | undefined;\n    constant?: boolean | undefined;\n    name: string;\n    inputs: SmartContract_ABI_Entry_Param[];\n    outputs: SmartContract_ABI_Entry_Param[];\n    type: SmartContract_ABI_Entry_EntryType;\n    payable?: boolean | undefined;\n    stateMutability: SmartContract_ABI_Entry_StateMutabilityType;\n}\n\nexport const SmartContract_ABI_Entry_EntryType = {\n    UnknownEntryType: 'UnknownEntryType',\n    Constructor: 'constructor',\n    Function: 'function',\n    Event: 'event',\n    Fallback: 'fallback',\n    Receive: 'receive',\n    Error: 'error',\n} as const;\n\nexport type SmartContract_ABI_Entry_EntryType =\n    typeof SmartContract_ABI_Entry_EntryType[keyof typeof SmartContract_ABI_Entry_EntryType];\n\nexport const SmartContract_ABI_Entry_StateMutabilityType = {\n    UnknownMutabilityType: 'UnknownMutabilityType',\n    Pure: 'pure',\n    View: 'view',\n    Nonpayable: 'nonpayable',\n    Payable: 'payable',\n} as const;\n\nexport type SmartContract_ABI_Entry_StateMutabilityType =\n    typeof SmartContract_ABI_Entry_StateMutabilityType[keyof typeof SmartContract_ABI_Entry_StateMutabilityType];\n\nexport interface SmartContract_ABI_Entry_Param {\n    indexed: boolean;\n    name: string;\n    /** SolidityType type = 3; */\n    type: string;\n}\n\nexport interface CreateSmartContract {\n    owner_address: string;\n    // new_contract: SmartContract | undefined;\n    call_token_value?: number;\n    token_id?: number;\n    // Manually copied\n    origin_address?: string;\n    contract_address?: string;\n    abi: SmartContract_ABI | undefined;\n    bytecode: string;\n    call_value: number;\n    consume_user_resource_percent: number;\n    name: string;\n    origin_energy_limit: number;\n    code_hash?: string;\n    trx_hash?: string;\n}\n\nexport interface TriggerSmartContract {\n    owner_address: string;\n    contract_address: string;\n    call_value: number;\n    data: string;\n    call_token_value: number;\n    token_id: number;\n}\n\nexport interface ClearABIContract {\n    owner_address: string;\n    contract_address: string;\n}\n\nexport interface UpdateSettingContract {\n    owner_address: string;\n    contract_address: string;\n    consume_user_resource_percent: number;\n}\n\nexport interface UpdateEnergyLimitContract {\n    owner_address: string;\n    contract_address: string;\n    origin_energy_limit: number;\n}\n\nexport interface SmartContractDataWrapper {\n    smart_contract: SmartContract | undefined;\n    runtimecode: string;\n}\n","/* eslint-disable */\n\nexport const protobufPackage = 'protocol';\n\nexport interface BuyStorageBytesContract {\n    owner_address: string;\n    /** storage bytes for buy */\n    bytes: number;\n}\n\nexport interface BuyStorageContract {\n    owner_address: string;\n    /** trx quantity for buy storage (sun) */\n    quant: number;\n}\n\nexport interface SellStorageContract {\n    owner_address: string;\n    storage_bytes: number;\n}\n\nexport interface UpdateBrokerageContract {\n    owner_address: string;\n    /** 1 mean 1% */\n    brokerage: number;\n}\n","/* eslint-disable */\n\nexport const protobufPackage = 'protocol';\n\nexport interface WitnessCreateContract {\n    owner_address: string;\n    url: string;\n}\n\nexport interface WitnessUpdateContract {\n    owner_address: string;\n    update_url: string;\n}\n\nexport interface VoteWitnessContract {\n    owner_address: string;\n    votes: VoteWitnessContract_Vote[];\n    support?: boolean | undefined;\n}\n\nexport interface VoteWitnessContract_Vote {\n    vote_address: string;\n    vote_count: number;\n}\n","module.exports = require(\"@tronweb3/google-protobuf/google/protobuf/any_pb\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/asyncToGenerator\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/typeof\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/classCallCheck\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/createClass\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/assertThisInitialized\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/inherits\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/getPrototypeOf\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/defineProperty\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/regenerator\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"bignumber.js\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"eventemitter3\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"injectpromise\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"semver\");","// Generated by genversion.\nexport const version = '0.1.0-alpha.3';\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/slicedToArray\");","import injectpromise from 'injectpromise';\n\nimport TronWeb from '../../src';\n\nexport class WithTronwebAndInjectpromise {\n    tronWeb: TronWeb;\n    injectPromise: injectpromise;\n\n    constructor(tronWeb: TronWeb) {\n        if (!tronWeb)\n            throw new Error('Expected instances of TronWeb and utils');\n        this.tronWeb = tronWeb;\n        this.injectPromise = injectpromise(this);\n    }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"validator\");","export const ADDRESS_SIZE = 34;\nexport const ADDRESS_PREFIX = '41';\nexport const ADDRESS_PREFIX_BYTE = 0x41;\nexport const ADDRESS_PREFIX_REGEX = /^(41)/;\n\nexport const TRON_BIP39_PATH_PREFIX = \"m/44'/195'\";\nexport const TRON_BIP39_PATH_INDEX_0 = TRON_BIP39_PATH_PREFIX + \"/0'/0/0\";\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"ethers\");","import type {BytesLike} from '@ethersproject/bytes';\nimport {utils} from 'ethers';\n\nexport {Wallet as ethersWallet} from 'ethers';\nexport type {Wordlist} from 'ethers';\nexport type {Bytes, BytesLike} from '@ethersproject/bytes';\nexport type {Mnemonic} from '@ethersproject/hdnode';\n\nconst {\n    keccak256,\n    sha256,\n    toUtf8Bytes,\n    toUtf8String,\n    recoverAddress,\n    SigningKey: SigningKey_,\n    AbiCoder,\n    Interface,\n    FormatTypes,\n    arrayify,\n    splitSignature,\n    joinSignature,\n    concat,\n    id,\n    isValidMnemonic,\n} = utils;\n\n/**\n * Allow passing less precise values to constructor, because they work\n */\nexport class SigningKey extends SigningKey_ {\n    constructor(\n        privateKey: BytesLike | {value: string; toHexString: () => string},\n    ) {\n        super(privateKey as BytesLike);\n    }\n}\n\nexport {\n    keccak256,\n    sha256,\n    toUtf8Bytes,\n    toUtf8String,\n    recoverAddress,\n    AbiCoder,\n    Interface,\n    FormatTypes,\n    splitSignature,\n    joinSignature,\n    arrayify,\n    concat,\n    id,\n    isValidMnemonic,\n};\n","import TronWeb from '..';\nimport {ADDRESS_PREFIX, ADDRESS_PREFIX_REGEX} from './address';\nimport {AbiCoder} from './ethersUtils';\n\nconst abiCoder = new AbiCoder();\n\nfunction _addressToHex(value: string): string {\n    return TronWeb.address.toHex(value).replace(ADDRESS_PREFIX_REGEX, '0x');\n}\n\nfunction deepCopy<T>(target: T): T {\n    if (\n        Object.prototype.toString.call(target) !== '[object Object]' &&\n        Object.prototype.toString.call(target) !== '[object Array]'\n    )\n        return target;\n\n    const newTarget = (Array.isArray(target) ? [] : {}) as typeof target;\n\n    for (const key in target)\n        newTarget[key] =\n            target[key] instanceof Object && !target[key]['_isBigNumber']\n                ? deepCopy(target[key])\n                : target[key];\n\n    return newTarget;\n}\n\nexport function decodeParams(\n    names_: string[],\n    types_: string,\n    output_?: boolean,\n): any;\nexport function decodeParams(\n    names_: string[],\n    types_: string[],\n    output_?: string,\n    ignoreMethodHash_?: boolean,\n): any[];\nexport function decodeParams(\n    names_: string[],\n    types_: string[] | string,\n    output_?: string | boolean,\n    ignoreMethodHash_?: boolean,\n): any[] {\n    let ignoreMethodHash: boolean;\n    let output: string;\n    let types: string[];\n    let names: string[];\n    if (!output_ || typeof output_ === 'boolean') {\n        // @ts-ignore\n        ignoreMethodHash = output_;\n        // @ts-ignore\n        output = types_;\n        types = names_;\n        names = [];\n    } else {\n        // @ts-ignore\n        ignoreMethodHash = ignoreMethodHash_;\n        output = output_;\n        // @ts-ignore\n        types = types_;\n        names = names_;\n    }\n\n    if (ignoreMethodHash && output.replace(/^0x/, '').length % 64 === 8)\n        output = '0x' + output.replace(/^0x/, '').substring(8);\n\n    if (output.replace(/^0x/, '').length % 64)\n        throw new Error(\n            'The encoded string is not valid. Its length must be a multiple of 64.',\n        );\n\n    // workaround for unsupported trcToken type\n    types = types.map((type) => {\n        if (/trcToken/.test(type)) type = type.replace(/trcToken/, 'uint256');\n\n        return type;\n    });\n\n    return abiCoder.decode(types, output).reduce(\n        (obj, arg, index) => {\n            if (types[index] === 'address')\n                arg = ADDRESS_PREFIX + arg.substr(2).toLowerCase();\n\n            if (names.length) obj[names[index]] = arg;\n            else obj.push(arg);\n\n            return obj;\n        },\n        names.length ? {} : [],\n    );\n}\n\nexport function encodeParams(types: string[], values: any[]): string {\n    for (let i = 0; i < types.length; i++)\n        if (types[i] === 'address')\n            values[i] = TronWeb.address\n                .toHex(values[i])\n                .replace(ADDRESS_PREFIX_REGEX, '0x');\n\n    return abiCoder.encode(types, values);\n}\n\nfunction extractSize(type: string): string {\n    const size = type.match(/([a-zA-Z0-9])(\\[.*\\])/);\n    return size ? size[2] : '';\n}\n\nfunction extractArrayDim(type: string): number {\n    const size = extractSize(type);\n    return (size.match(/\\]\\[/g) || []).length + 1;\n}\n\nexport interface IFieldABI {\n    name: string;\n    type: string;\n    components?: IFieldABI[];\n}\nexport interface IFunABI {\n    inputs?: IFieldABI[];\n    outputs?: IFieldABI[];\n}\n\nexport function encodeParamsV2ByABI(funABI: IFunABI, args: unknown[]) {\n    const types: string[] = [];\n\n    const buildFullTypeDefinition = (typeDef) => {\n        if (\n            typeDef &&\n            typeDef.type.indexOf('tuple') === 0 &&\n            typeDef.components\n        ) {\n            const innerTypes = typeDef.components.map((innerType) => {\n                return buildFullTypeDefinition(innerType);\n            });\n            return `tuple(${innerTypes.join(',')})${extractSize(typeDef.type)}`;\n        }\n\n        if (/trcToken/.test(typeDef.type))\n            return typeDef.type.replace(/trcToken/, 'uint256');\n\n        return typeDef.type;\n    };\n\n    const convertTypes = (types) => {\n        for (let i = 0; i < types.length; i++) {\n            const type = types[i];\n            if (/trcToken/.test(type))\n                types[i] = type.replace(/trcToken/, 'uint256');\n        }\n    };\n\n    const convertAddresses = (addrArr) => {\n        if (Array.isArray(addrArr)) {\n            addrArr.forEach((addrs, i) => {\n                addrArr[i] = convertAddresses(addrs);\n            });\n            return addrArr;\n        } else {\n            return _addressToHex(addrArr);\n        }\n    };\n\n    const mapTuple = (components, args, dimension) => {\n        if (dimension > 1) {\n            if (args.length)\n                args.forEach((arg) => {\n                    mapTuple(components, arg, dimension - 1);\n                });\n        } else {\n            if (args.length && dimension)\n                args.forEach((arg) => {\n                    encodeArgs(components, arg);\n                });\n        }\n    };\n\n    const encodeArgs = (inputs: IFieldABI[] = [], args: any[]) => {\n        if (inputs.length)\n            inputs.forEach((input, i) => {\n                const type = input.type;\n\n                if (args[i])\n                    if (type === 'address') args[i] = _addressToHex(args[i]);\n                    else if (\n                        type.match(/^([^\\x5b]*)(\\x5b|$)/)![0] === 'address['\n                    )\n                        convertAddresses(args[i]);\n                    else if (type.indexOf('tuple') === 0)\n                        if (extractSize(type)) {\n                            const dimension = extractArrayDim(type);\n                            mapTuple(input.components, args[i], dimension);\n                        } else {\n                            encodeArgs(input.components, args[i]);\n                        }\n            });\n    };\n\n    if (funABI.inputs && funABI.inputs.length)\n        for (let i = 0; i < funABI.inputs.length; i++) {\n            const type = funABI.inputs[i].type;\n            // \"false\" will be converting to `false` and \"true\" will be working\n            // fine as abiCoder assume anything in quotes as `true`\n            if (type === 'bool' && args[i] === 'false') args[i] = false;\n\n            types.push(\n                type.indexOf('tuple') === 0\n                    ? buildFullTypeDefinition(funABI.inputs[i])\n                    : type,\n            );\n            if (args.length < types.length) args.push('');\n        }\n\n    encodeArgs(funABI.inputs, args);\n    convertTypes(types);\n\n    return abiCoder.encode(types, args);\n}\n\nexport function decodeParamsV2ByABI(funABI: IFunABI, data) {\n    const convertTypeNames = (types) => {\n        for (let i = 0; i < types.length; i++) {\n            const type = types[i];\n            if (/^trcToken/.test(type))\n                types[i] = type.replace(/^trcToken/, 'uint256');\n        }\n    };\n\n    const convertAddresses = (addrArr) => {\n        if (Array.isArray(addrArr)) {\n            addrArr.forEach((addrs, i) => {\n                addrArr[i] = convertAddresses(addrs);\n            });\n            return addrArr;\n        } else {\n            return TronWeb.address.toHex(addrArr);\n        }\n    };\n\n    const mapTuple = (components, args, dimension) => {\n        if (dimension > 1) {\n            if (args.length)\n                args.forEach((arg) => {\n                    mapTuple(components, arg, dimension - 1);\n                });\n        } else {\n            if (args.length && dimension)\n                args.forEach((arg) => {\n                    decodeResult(components, arg);\n                });\n        }\n    };\n\n    const buildFullTypeNameDefinition = (typeDef) => {\n        const name = typeDef.name ? ` ${typeDef.name}` : '';\n        if (\n            typeDef &&\n            typeDef.type.indexOf('tuple') === 0 &&\n            typeDef.components\n        ) {\n            const innerTypes = typeDef.components.map((innerType) => {\n                return buildFullTypeNameDefinition(innerType);\n            });\n            return `tuple(${innerTypes.join(',')})${extractSize(\n                typeDef.type,\n            )}${name}`;\n        }\n        if (/trcToken/.test(typeDef.type))\n            return typeDef.type.replace(/trcToken/, 'uint256') + name;\n\n        return typeDef.type + name;\n    };\n\n    const decodeResult = (\n        outputs: IFieldABI[] = [],\n        result: {[key: number | string]: any},\n    ) => {\n        if (outputs.length)\n            outputs.forEach((output, i) => {\n                const {type, name} = output;\n\n                if (result[i])\n                    if (type === 'address') {\n                        result[i] = TronWeb.address.toHex(result[i]);\n                        if (name)\n                            result[name] = TronWeb.address.toHex(result[name]);\n                    } else if (\n                        type.match(/^([^\\x5b]*)(\\x5b|$)/)![0] === 'address['\n                    ) {\n                        convertAddresses(result[i]);\n                        if (name) convertAddresses(result[name]);\n                    } else if (type.indexOf('tuple') === 0) {\n                        if (extractSize(type)) {\n                            const dimension = extractArrayDim(type);\n                            mapTuple(output.components, result[i], dimension);\n                        } else {\n                            decodeResult(output.components, result[i]);\n                        }\n\n                        if (name) result[name] = result[i];\n                    }\n            });\n    };\n\n    // Only decode if there supposed to be fields\n    if (funABI.outputs && funABI.outputs.length > 0) {\n        const outputTypes: string[] = [];\n        for (let i = 0; i < funABI.outputs.length; i++) {\n            const type = funABI.outputs[i].type;\n            const name = funABI.outputs[i].name\n                ? ` ${funABI.outputs[i].name}`\n                : '';\n            outputTypes.push(\n                type.indexOf('tuple') === 0\n                    ? buildFullTypeNameDefinition(funABI.outputs[i])\n                    : type + name,\n            );\n        }\n        convertTypeNames(outputTypes);\n\n        // ensure the data is at least filled by 0\n        // cause `AbiCoder` throws if there's not enough data\n        if (!data || !data.length)\n            data = new Uint8Array(32 * funABI.outputs.length);\n        // decode data\n        const decodeRes = abiCoder.decode(outputTypes, data);\n        const decodeResCopy = deepCopy(decodeRes);\n        decodeResult(funABI.outputs, decodeResCopy);\n\n        return decodeResCopy;\n    }\n    return [];\n}\n","import type {SomeBytes} from './bytes';\n\n// FIXME: verify that it works after conversion\n// May need static modifiers\n\nexport class Base64 {\n    private _keyStr =\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n    encode(input: string): string {\n        let output = '';\n        let chr1;\n        let chr2;\n        let chr3;\n        let enc1;\n        let enc2;\n        let enc3;\n        let enc4;\n        let i = 0;\n\n        while (i < input.length) {\n            chr1 = input.charCodeAt(i++);\n            chr2 = input.charCodeAt(i++);\n            chr3 = input.charCodeAt(i++);\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) enc3 = enc4 = 64;\n            else if (isNaN(chr3)) enc4 = 64;\n\n            output +=\n                this._keyStr.charAt(enc1) +\n                this._keyStr.charAt(enc2) +\n                this._keyStr.charAt(enc3) +\n                this._keyStr.charAt(enc4);\n        }\n\n        return output;\n    }\n\n    encodeIgnoreUtf8(inputBytes: SomeBytes): string {\n        let output = '';\n        let chr1;\n        let chr2;\n        let chr3;\n        let enc1;\n        let enc2;\n        let enc3;\n        let enc4;\n        let i = 0;\n\n        while (i < inputBytes.length) {\n            chr1 = inputBytes[i++];\n            chr2 = inputBytes[i++];\n            chr3 = inputBytes[i++];\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) enc3 = enc4 = 64;\n            else if (isNaN(chr3)) enc4 = 64;\n\n            output =\n                output +\n                this._keyStr.charAt(enc1) +\n                this._keyStr.charAt(enc2) +\n                this._keyStr.charAt(enc3) +\n                this._keyStr.charAt(enc4);\n        }\n\n        return output;\n    }\n\n    decode(input: string): string {\n        let output = '';\n        let chr1;\n        let chr2;\n        let chr3;\n        let enc1;\n        let enc2;\n        let enc3;\n        let enc4;\n        let i = 0;\n\n        input = input.replace(/[^A-Za-z0-9+/=]/g, '');\n\n        while (i < input.length) {\n            enc1 = this._keyStr.indexOf(input.charAt(i++));\n            enc2 = this._keyStr.indexOf(input.charAt(i++));\n            enc3 = this._keyStr.indexOf(input.charAt(i++));\n            enc4 = this._keyStr.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            output = output + String.fromCharCode(chr1);\n\n            if (enc3 !== 64) output = output + String.fromCharCode(chr2);\n\n            if (enc4 !== 64) output = output + String.fromCharCode(chr3);\n        }\n\n        return this._utf8_decode(output);\n    }\n\n    decodeToByteArray(input: string): Uint8Array {\n        let output = '';\n        let chr1;\n        let chr2;\n        let chr3;\n        let enc1;\n        let enc2;\n        let enc3;\n        let enc4;\n        let i = 0;\n\n        input = input.replace(/[^A-Za-z0-9+/=]/g, '');\n\n        while (i < input.length) {\n            enc1 = this._keyStr.indexOf(input.charAt(i++));\n            enc2 = this._keyStr.indexOf(input.charAt(i++));\n            enc3 = this._keyStr.indexOf(input.charAt(i++));\n            enc4 = this._keyStr.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            output = output + String.fromCharCode(chr1);\n\n            if (enc3 !== 64) output = output + String.fromCharCode(chr2);\n\n            if (enc4 !== 64) output = output + String.fromCharCode(chr3);\n        }\n\n        return this._out2ByteArray(output);\n    }\n\n    private _out2ByteArray(utftext: string): Uint8Array {\n        const byteArray = new Uint8Array(utftext.length);\n        for (let i = 0; i < utftext.length; i++)\n            byteArray[i] = utftext.charCodeAt(i);\n\n        return byteArray;\n    }\n\n    private _utf8_encode(string: string): string {\n        string = string.replace(/\\r\\n/g, '\\n');\n        let utftext = '';\n\n        for (let n = 0; n < string.length; n++) {\n            const c = string.charCodeAt(n);\n\n            if (c < 128) {\n                utftext += String.fromCharCode(c);\n            } else if (c > 127 && c < 2048) {\n                utftext += String.fromCharCode((c >> 6) | 192);\n                utftext += String.fromCharCode((c & 63) | 128);\n            } else {\n                utftext += String.fromCharCode((c >> 12) | 224);\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n        }\n\n        return utftext;\n    }\n\n    private _utf8_decode(utftext: string): string {\n        let string = '';\n        let i = 0;\n        let c = 0;\n        let c2 = 0;\n        let c3 = 0;\n\n        while (i < utftext.length) {\n            c = utftext.charCodeAt(i);\n\n            if (c < 128) {\n                string += String.fromCharCode(c);\n                i++;\n            } else if (c > 191 && c < 224) {\n                c2 = utftext.charCodeAt(i + 1);\n                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n                i += 2;\n            } else {\n                c2 = utftext.charCodeAt(i + 1);\n                c3 = utftext.charCodeAt(i + 2);\n\n                string += String.fromCharCode(\n                    ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63),\n                );\n\n                i += 3;\n            }\n        }\n\n        return string;\n    }\n}\n","import {Base64} from './base64';\n\nexport type SomeBytes = Uint8Array | Buffer | number[];\n\nexport function byte2hexStr(byte: number) {\n    if (typeof byte !== 'number') throw new Error('Input must be a number');\n    if (byte < 0 || byte > 255) throw new Error('Input must be a byte');\n\n    const hexByteMap = '0123456789ABCDEF';\n    return hexByteMap.charAt(byte >> 4) + hexByteMap.charAt(byte & 0x0f);\n}\n\nexport function bytesToString(arr: SomeBytes | string) {\n    if (typeof arr === 'string') return arr;\n\n    let str = '';\n\n    for (let i = 0; i < arr.length; i++) {\n        const one = arr[i].toString(2);\n        const v = one.match(/^1+?(?=0)/);\n\n        if (v && one.length === 8) {\n            const bytesLength = v[0].length;\n            let store = arr[i].toString(2).slice(7 - bytesLength);\n\n            for (let st = 1; st < bytesLength; st++)\n                store += arr[st + i].toString(2).slice(2);\n\n            str += String.fromCharCode(parseInt(store, 2));\n            i += bytesLength - 1;\n        } else {\n            str += String.fromCharCode(arr[i]);\n        }\n    }\n\n    return str;\n}\n\nexport function hextoString(hex: string) {\n    const arr = hex.replace(/^0x/, '').split('');\n    let out = '';\n\n    for (let i = 0; i < arr.length / 2; i++) {\n        const tmp = `0x${arr[i * 2]}${arr[i * 2 + 1]}`;\n        out += String.fromCharCode(parseInt(tmp, 16));\n    }\n\n    return out;\n}\n\nexport function byteArray2hexStr(byteArray: SomeBytes) {\n    let str = '';\n\n    for (const b of byteArray) str += byte2hexStr(b);\n\n    return str;\n}\n\nexport function base64DecodeFromString(string64: string) {\n    return new Base64().decodeToByteArray(string64);\n}\n\nexport function base64EncodeToString(bytes: SomeBytes) {\n    const b = new Base64();\n    return b.encodeIgnoreUtf8(bytes);\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@babel/runtime/helpers/toConsumableArray\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"elliptic\");","const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nconst ALPHABET_MAP = {};\n\nfor (let i = 0; i < ALPHABET.length; i++) ALPHABET_MAP[ALPHABET.charAt(i)] = i;\n\nconst BASE = 58;\n\nexport function encode58(buffer: Buffer | Uint8Array | string) {\n    if (buffer.length === 0) return '';\n\n    let i, j;\n    // Lines below [ab]use implicit string/number conversion\n    // In fact it is `(string | number)[]`\n    const digits: any[] = [0];\n\n    for (i = 0; i < buffer.length; i++) {\n        for (j = 0; j < digits.length; j++) digits[j] <<= 8;\n\n        digits[0] += buffer[i];\n        let carry = 0;\n\n        for (j = 0; j < digits.length; ++j) {\n            digits[j] += carry;\n            carry = (digits[j] / BASE) | 0;\n            digits[j] %= BASE;\n        }\n        // Now digits is number[] strictly\n\n        while (carry) {\n            digits.push(carry % BASE);\n            carry = (carry / BASE) | 0;\n        }\n    }\n\n    for (i = 0; buffer[i] === 0 && i < buffer.length - 1; i++) digits.push(0);\n\n    return digits\n        .reverse()\n        .map((digit) => ALPHABET[digit])\n        .join('');\n}\n\nexport function decode58(string: string): Uint8Array {\n    if (string.length === 0) return new Uint8Array();\n\n    let i, j;\n    const bytes = [0];\n\n    for (i = 0; i < string.length; i++) {\n        const c = string[i];\n\n        if (!(c in ALPHABET_MAP)) throw new Error('Non-base58 character');\n\n        for (j = 0; j < bytes.length; j++) bytes[j] *= BASE;\n\n        bytes[0] += ALPHABET_MAP[c];\n        let carry = 0;\n\n        for (j = 0; j < bytes.length; ++j) {\n            bytes[j] += carry;\n            carry = bytes[j] >> 8;\n            bytes[j] &= 0xff;\n        }\n\n        while (carry) {\n            bytes.push(carry & 0xff);\n            carry >>= 8;\n        }\n    }\n\n    for (i = 0; string[i] === '1' && i < string.length - 1; i++) bytes.push(0);\n\n    return new Uint8Array(bytes.reverse());\n}\n","import {\n    base64DecodeFromString,\n    base64EncodeToString,\n    byte2hexStr,\n    byteArray2hexStr,\n    bytesToString,\n    hextoString,\n} from './bytes';\n\nexport const bin2String = bytesToString;\n\nexport function arrayEquals(\n    array1: {length: number; [key: number]: unknown},\n    array2: {length: number; [key: number]: unknown},\n    strict = false,\n): boolean {\n    if (array1.length !== array2.length) return false;\n\n    let i;\n\n    for (i = 0; i < array1.length; i++)\n        if (strict) {\n            if (array1[i] !== array2[i]) return false;\n        } else if (JSON.stringify(array1[i]) !== JSON.stringify(array2[i])) {\n            return false;\n        }\n\n    return true;\n}\n\nexport function stringToBytes(str: string): Uint8Array {\n    if (typeof str !== 'string')\n        throw new Error('The passed string is not a string');\n\n    const bytes: number[] = [];\n    const len = str.length;\n    let c;\n\n    for (let i = 0; i < len; i++) {\n        c = str.charCodeAt(i);\n\n        if (c >= 0x010000 && c <= 0x10ffff) {\n            bytes.push(((c >> 18) & 0x07) | 0xf0);\n            bytes.push(((c >> 12) & 0x3f) | 0x80);\n            bytes.push(((c >> 6) & 0x3f) | 0x80);\n            bytes.push((c & 0x3f) | 0x80);\n        } else if (c >= 0x000800 && c <= 0x00ffff) {\n            bytes.push(((c >> 12) & 0x0f) | 0xe0);\n            bytes.push(((c >> 6) & 0x3f) | 0x80);\n            bytes.push((c & 0x3f) | 0x80);\n        } else if (c >= 0x000080 && c <= 0x0007ff) {\n            bytes.push(((c >> 6) & 0x1f) | 0xc0);\n            bytes.push((c & 0x3f) | 0x80);\n        } else {\n            bytes.push(c & 0xff);\n        }\n    }\n\n    return new Uint8Array(bytes);\n}\n\nexport {\n    byte2hexStr,\n    bytesToString,\n    hextoString,\n    byteArray2hexStr,\n    base64DecodeFromString,\n    base64EncodeToString,\n};\n\nexport function hexChar2byte(c: string): number {\n    let d;\n\n    if (c >= 'A' && c <= 'F') d = c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;\n    else if (c >= 'a' && c <= 'f') d = c.charCodeAt(0) - 'a'.charCodeAt(0) + 10;\n    else if (c >= '0' && c <= '9') d = c.charCodeAt(0) - '0'.charCodeAt(0);\n\n    if (typeof d === 'number') return d;\n    else throw new Error('The passed hex char is not a valid hex char');\n}\n\nexport function isHexChar(c: string) {\n    return (\n        (c >= 'A' && c <= 'F') ||\n        (c >= 'a' && c <= 'f') ||\n        (c >= '0' && c <= '9')\n    );\n}\n\n/**\n * Convert a hex string to a byte array.\n * @param strict: if strict and the length of str is odd, pad it left with one zero\n */\nexport function hexStr2byteArray(str: string, strict = false) {\n    if (typeof str !== 'string')\n        throw new Error('The passed string is not a string');\n\n    if (strict && str.length % 2) str = `0${str}`;\n\n    const byteArray = new Uint8Array(str.length / 2);\n    let d = 0;\n    let j = 0;\n    let k = 0;\n\n    for (const c of str)\n        if (isHexChar(c)) {\n            d <<= 4;\n            d += hexChar2byte(c);\n            j++;\n\n            if (j % 2 === 0) {\n                byteArray[k++] = d;\n                d = 0;\n            }\n        } else {\n            throw new Error('The passed hex char is not a valid hex string');\n        }\n\n    return byteArray;\n}\n\n/**\n * Convert string of form `yyyy-MM-DD HH-mm-ss` to `Date`\n */\nexport function strToDate(str: string) {\n    if (!/^\\d{4}-\\d{2}-\\d{2}( \\d{2}-\\d{2}-\\d{2}|)/.test(str))\n        throw new Error('The passed date string is not valid');\n\n    const tempStrs = str.split(' ');\n    const dateStrs = tempStrs[0].split('-');\n    const year = parseInt(dateStrs[0], 10);\n    const month = parseInt(dateStrs[1], 10) - 1;\n    const day = parseInt(dateStrs[2], 10);\n\n    if (tempStrs.length > 1) {\n        const timeStrs = tempStrs[1].split('-');\n        const hour = parseInt(timeStrs[0], 10);\n        const minute = parseInt(timeStrs[1], 10);\n        const second = parseInt(timeStrs[2], 10);\n\n        return new Date(year, month, day, hour, minute, second);\n    }\n\n    return new Date(year, month, day);\n}\n\nexport function isNumber(c: string | number): boolean {\n    return c >= '0' && c <= '9';\n}\n\n/**\n * return 1: address  --- 20Bytes HexString\n * return 2: blockNumber ------ Decimal number\n * return 3: assetName ------ String\n * return other: error\n */\nexport function getStringType(str: string): 1 | 2 | 3 | -1 {\n    if (null == str) return -1;\n\n    if (typeof str != 'string') return -1;\n\n    if (!str || str.length === 0 || str === '') return -1;\n\n    let i = 0;\n\n    // TODO Should we return 1 if someone passes a full, 42-chars long address?\n    // if (str.length == 42 && /^41/.test(str)) {\n    //     for (; i < 40; i++) {\n    //         var c = str.charAt(i+2);\n    //\n    //         if (!isHexChar(c))\n    //             break;\n    //     }\n    // } else\n    if (str.length === 40)\n        for (; i < 40; i++) if (!isHexChar(str.charAt(i))) break;\n\n    if (i === 40) return 1; //40 Hex, Address\n\n    for (i = 0; i < str.length; i++) if (!isNumber(str.charAt(i))) break;\n\n    if (i === str.length) return 2; // All Decimal number, BlockNumber\n\n    // At least one visible character\n    for (i = 0; i < str.length; i++) if (str.charAt(i) > ' ') return 3;\n\n    return -1;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/bignumber\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/bytes\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/keccak256\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/logger\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/properties\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@ethersproject/strings\");","import {BigNumber} from '@ethersproject/bignumber';\nimport {arrayify, hexConcat, hexZeroPad, hexlify} from '@ethersproject/bytes';\nimport {keccak256} from '@ethersproject/keccak256';\nimport {Logger} from '@ethersproject/logger';\nimport {deepCopy, defineReadOnly, shallowCopy} from '@ethersproject/properties';\nimport {toUtf8Bytes} from '@ethersproject/strings';\n\nimport TronWeb from '..';\nimport {ADDRESS_PREFIX_REGEX} from './address';\nimport type {SomeBytes} from './bytes';\n\nconst version = 'tronweb/hash/5.4.0';\nconst logger = new Logger(version);\n\nfunction getAddress(address: string) {\n    return TronWeb.address.toHex(address).replace(ADDRESS_PREFIX_REGEX, '0x');\n}\n\nfunction getTronAddress(address: string) {\n    return TronWeb.address.toHex(address);\n}\n\nfunction id(text: string) {\n    return keccak256(toUtf8Bytes(text));\n}\n\nexport interface IField {\n    name: string;\n    type: string;\n}\nexport interface IDomain {\n    name: string;\n    version: string;\n    chainId: string;\n    verifyingContract: string;\n}\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\n    '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n);\n\nfunction hexPadRight(value: string) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) return hexConcat([bytes, padding.slice(padOffset)]);\n\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: 'string',\n    version: 'string',\n    chainId: 'uint256',\n    verifyingContract: 'address',\n    salt: 'bytes32',\n};\nconst domainFieldNames = [\n    'name',\n    'version',\n    'chainId',\n    'verifyingContract',\n    'salt',\n];\n\nfunction checkString(key: string) {\n    return function <T>(value: T): T extends string ? T : never {\n        if (typeof value !== 'string')\n            logger.throwArgumentError(\n                `invalid domain value for ${JSON.stringify(key)}`,\n                `domain.${key}`,\n                value,\n            );\n\n        return value as any;\n    };\n}\n\nconst domainChecks = {\n    name: checkString('name'),\n    version: checkString('version'),\n    chainId: function (value: unknown) {\n        try {\n            return BigNumber.from(value).toString();\n        } catch (error) {}\n        return logger.throwArgumentError(\n            'invalid domain value for \"chainId\"',\n            'domain.chainId',\n            value,\n        );\n    },\n    verifyingContract: function (value: string) {\n        try {\n            return getTronAddress(value).toLowerCase();\n        } catch (error) {}\n        return logger.throwArgumentError(\n            'invalid domain value \"verifyingContract\"',\n            'domain.verifyingContract',\n            value,\n        );\n    },\n    salt: function (value: string | number | SomeBytes) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) throw new Error('bad length');\n\n            return hexlify(bytes);\n        } catch (error) {}\n        return logger.throwArgumentError(\n            'invalid domain value \"salt\"',\n            'domain.salt',\n            value,\n        );\n    },\n};\n\nfunction getBaseEncoder(type: string): ((value: any) => string) | null {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = match[1] === '';\n            const width = parseInt(match[2] || '256');\n            if (\n                width % 8 !== 0 ||\n                width > 256 ||\n                (match[2] && match[2] !== String(width))\n            )\n                logger.throwArgumentError(\n                    'invalid numeric width',\n                    'type',\n                    type,\n                );\n\n            const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n            const boundsLower = signed\n                ? boundsUpper.add(One).mul(NegativeOne)\n                : Zero;\n            return function (value) {\n                const v = BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper))\n                    logger.throwArgumentError(\n                        `value out-of-bounds for ${type}`,\n                        'value',\n                        value,\n                    );\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width))\n                logger.throwArgumentError('invalid bytes width', 'type', type);\n\n            return function (value) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width)\n                    logger.throwArgumentError(\n                        `invalid length for ${type}`,\n                        'value',\n                        value,\n                    );\n\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case 'trcToken':\n            return getBaseEncoder('uint256');\n        case 'address':\n            return function (value) {\n                return hexZeroPad(getAddress(value), 32);\n            };\n        case 'bool':\n            return function (value) {\n                return !value ? hexFalse : hexTrue;\n            };\n        case 'bytes':\n            return function (value) {\n                return keccak256(value);\n            };\n        case 'string':\n            return function (value) {\n                return id(value);\n            };\n    }\n    return null;\n}\n\nfunction encodeType(name: string, fields: IField[]) {\n    return `${name}(${fields\n        .map(({name, type}) => type + ' ' + name)\n        .join(',')})`;\n}\n\nexport class TypedDataEncoder {\n    readonly types!: Record<string, IField[]>;\n    readonly primaryType!: string;\n    readonly _types!: Record<string, string>;\n    readonly _encoderCache!: Record<string, (__v: unknown) => string>;\n\n    constructor(types: Record<string, IField[]>) {\n        defineReadOnly(this, 'types', Object.freeze(deepCopy(types)));\n        defineReadOnly(this, '_encoderCache', {});\n        defineReadOnly(this, '_types', {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name])\n                    logger.throwArgumentError(\n                        `duplicate variable name ${JSON.stringify(\n                            field.name,\n                        )} in ${JSON.stringify(name)}`,\n                        'types',\n                        types,\n                    );\n\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)![1];\n                if (baseType === name)\n                    logger.throwArgumentError(\n                        `circular type reference to ${JSON.stringify(\n                            baseType,\n                        )}`,\n                        'types',\n                        types,\n                    );\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) return;\n\n                if (!parents[baseType])\n                    logger.throwArgumentError(\n                        `unknown type ${JSON.stringify(baseType)}`,\n                        'types',\n                        types,\n                    );\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter(\n            (n) => parents[n].length === 0,\n        );\n        if (primaryTypes.length === 0)\n            logger.throwArgumentError('missing primary type', 'types', types);\n        else if (primaryTypes.length > 1)\n            logger.throwArgumentError(\n                `ambiguous primary types or unused types: ${primaryTypes\n                    .map((t) => JSON.stringify(t))\n                    .join(', ')}`,\n                'types',\n                types,\n            );\n\n        defineReadOnly(this, 'primaryType', primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type])\n                logger.throwArgumentError(\n                    `circular type reference to ${JSON.stringify(type)}`,\n                    'types',\n                    types,\n                );\n\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) return;\n\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] =\n                encodeType(name, types[name]) +\n                st.map((t) => encodeType(t, types[t])).join('');\n        }\n    }\n    getEncoder(type: string) {\n        let encoder = this._encoderCache[type];\n        if (!encoder)\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n\n        return encoder;\n    }\n    private _getEncoder(type: string) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) return encoder;\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length)\n                    logger.throwArgumentError(\n                        'array length mismatch; expected length ${ arrayLength }',\n                        'value',\n                        value,\n                    );\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) result = result.map(keccak256);\n\n                return keccak256(hexConcat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value) => {\n                const values = fields.map(({name, type}) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) return keccak256(result);\n\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, 'type', type);\n    }\n    encodeType(name: string) {\n        const result = this._types[name];\n        if (!result)\n            logger.throwArgumentError(\n                `unknown type: ${JSON.stringify(name)}`,\n                'name',\n                name,\n            );\n\n        return result;\n    }\n    encodeData(type: string, value: unknown) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name: string, value: unknown) {\n        return keccak256(this.encodeData(name, value));\n    }\n    encode(value: unknown) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value: unknown) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    private _visit(\n        type: string,\n        value: unknown,\n        callback: (type: string, value: unknown) => any,\n    ): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) return callback(type, value);\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (\n                !Array.isArray(value) ||\n                (length >= 0 && value.length !== length)\n            )\n                logger.throwArgumentError(\n                    'array length mismatch; expected length ${ arrayLength }',\n                    'value',\n                    value,\n                );\n\n            if (Array.isArray(value))\n                return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields)\n            return fields.reduce((accum, {name, type}) => {\n                accum[name] = this._visit(type, value![name], callback);\n                return accum;\n            }, {});\n\n        return logger.throwArgumentError(`unknown type: ${type}`, 'type', type);\n    }\n    visit(value: unknown, callback: (type: string, value: unknown) => any) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types: Record<string, IField[]>) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types: Record<string, IField[]>) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(\n        name: string,\n        types: Record<string, IField[]>,\n        value: unknown,\n    ) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain: IDomain) {\n        const domainFields: IField[] = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type)\n                logger.throwArgumentError(\n                    `invalid typed-data domain key: ${JSON.stringify(name)}`,\n                    'domain',\n                    domain,\n                );\n\n            domainFields.push({name, type});\n        }\n        domainFields.sort((a, b) => {\n            return (\n                domainFieldNames.indexOf(a.name) -\n                domainFieldNames.indexOf(b.name)\n            );\n        });\n        return TypedDataEncoder.hashStruct(\n            'EIP712Domain',\n            {EIP712Domain: domainFields},\n            domain,\n        );\n    }\n    static encode(\n        domain: IDomain,\n        types: Record<string, IField[]>,\n        value: unknown,\n    ) {\n        return hexConcat([\n            '0x1901',\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value),\n        ]);\n    }\n    static hash(\n        domain: IDomain,\n        types: Record<string, IField[]>,\n        value: unknown,\n    ) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    static getPayload(\n        domain: IDomain,\n        types: Record<string, IField[]>,\n        value: unknown,\n    ) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: {[key: string]: any} = {};\n        const domainTypes: IField[] = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) return;\n\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({name, type: domainFieldTypes[name]});\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain)\n            logger.throwArgumentError(\n                'types must not contain EIP712Domain type',\n                'types.EIP712Domain',\n                types,\n            );\n        else typesWithDomain.EIP712Domain = domainTypes;\n\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/))\n                    return hexlify(arrayify(value as string));\n\n                // uint or int\n                if (type.match(/^u?int/))\n                    return BigNumber.from(value).toString();\n\n                switch (type) {\n                    case 'trcToken':\n                        return BigNumber.from(value).toString();\n                    case 'address':\n                        return getTronAddress(value as string).toLowerCase();\n                    case 'bool':\n                        return !!value;\n                    case 'string':\n                        if (typeof value !== 'string')\n                            logger.throwArgumentError(\n                                'invalid string',\n                                'value',\n                                value,\n                            );\n\n                        return value;\n                }\n                return logger.throwArgumentError(\n                    'unsupported type',\n                    'type',\n                    type,\n                );\n            }),\n        };\n    }\n}\n","import el from 'elliptic';\n\nimport type {ISignedTransaction, ITransaction} from '../lib/transactionBuilder';\nimport {ADDRESS_PREFIX, ADDRESS_PREFIX_BYTE, ADDRESS_SIZE} from './address';\nimport {decode58, encode58} from './base58';\nimport {byte2hexStr, byteArray2hexStr} from './bytes';\nimport type {SomeBytes} from './bytes';\nimport {\n    base64DecodeFromString,\n    base64EncodeToString,\n    hexStr2byteArray,\n} from './code';\nimport {SigningKey, sha256 as ethSha256, keccak256, recoverAddress, joinSignature, arrayify, splitSignature} from './ethersUtils';\nimport {TypedDataEncoder} from './typedData';\nimport type {IDomain} from './typedData';\n\nconst {ec: EC} = el;\n\n// import {TransactionExtention as ITransactionExtention} from '../proto/api/api'\n\nexport {byteArray2hexStr} from './bytes';\n\nexport type TypedDataTypes = Record<string, {name: string; type: string}[]>;\n\nexport function getBase58CheckAddress(\n    addressBytes: SomeBytes | Buffer | number[],\n) {\n    const hash = sha256(sha256(addressBytes));\n    let checkSum = hash.slice(0, 4);\n    checkSum = new Uint8Array([...addressBytes, ...checkSum]);\n\n    return encode58(checkSum);\n}\n\nexport function decodeBase58Address(base58String: string) {\n    const error_msg = 'Invalid address provided';\n\n    if (typeof base58String !== 'string' || base58String.length <= 4)\n        throw new Error(error_msg);\n\n    let address = decode58(base58String);\n\n    if (base58String.length <= 4) throw new Error(error_msg);\n\n    const checkSum = address.slice(-4);\n\n    address = address.slice(0, -4);\n\n    const hash = sha256(sha256(address));\n    const checkSum1 = hash.slice(0, 4);\n\n    if (checkSum.join() === checkSum1.join()) return address;\n\n    throw new Error(error_msg);\n}\n\nexport function signTransaction(\n    priKeyBytes: string | SomeBytes,\n    transaction: ITransaction,\n): ISignedTransaction {\n    if (typeof priKeyBytes === 'string')\n        priKeyBytes = hexStr2byteArray(priKeyBytes);\n\n    const txID = transaction.txID;\n    const signature = getECKeySig(hexStr2byteArray(txID), priKeyBytes);\n\n    if (Array.isArray(transaction.signature)) {\n        if (!transaction.signature.includes(signature))\n            transaction.signature.push(signature);\n    } else {\n        transaction.signature = [signature];\n    }\n    return transaction as ISignedTransaction;\n}\n\nexport function ecRecover(signedData, signature) {\n    signedData = '0x' + signedData.replace(/^0x/, '');\n    signature = '0x' + signature.replace(/^0x/, '');\n\n    const recovered = recoverAddress(arrayify(signedData), splitSignature(signature));\n    const tronAddress = ADDRESS_PREFIX + recovered.substring(2);\n    return tronAddress;\n}\n\nexport function arrayToBase64String(a: SomeBytes) {\n    return btoa(String.fromCharCode(...a));\n}\n\nexport function signBytes(privateKey: string | SomeBytes, contents: SomeBytes) {\n    if (typeof privateKey === 'string')\n        privateKey = hexStr2byteArray(privateKey);\n\n    const hashBytes = sha256(contents);\n    return getECKeySig(hashBytes, privateKey);\n}\n\nexport function _signTypedData(\n    domain: IDomain,\n    types: TypedDataTypes,\n    value: Record<string, unknown>,\n    privateKey: string,\n) {\n    const key = {\n        toHexString: function () {\n            return '0x' + privateKey;\n        },\n        value: privateKey,\n    };\n    const signingKey = new SigningKey(key);\n\n    const messageDigest = TypedDataEncoder.hash(domain, types, value);\n    const signature = signingKey.signDigest(messageDigest);\n    return [\n        '0x',\n        signature.r.substring(2),\n        signature.s.substring(2),\n        Number(signature.v).toString(16),\n    ].join('');\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function getRowBytesFromTransactionBase64(base64Data: string) {\n    throw new Error('Sorry, this function is not supported.');\n    // TODO: what the hell is it? Is it needed? Current impl does not work.\n    // const bytesDecode = base64DecodeFromString(base64Data);\n    // const transaction =\n    //     proto.protocol.Transaction.deserializeBinary(bytesDecode);\n    // const raw = transaction.getRawData();\n\n    // return raw.serializeBinary();\n}\n\nexport function genPriKey() {\n    const ec = new EC('secp256k1');\n    const key = ec.genKeyPair();\n    const priKey = key.getPrivate();\n\n    let priKeyHex = priKey.toString('hex');\n\n    while (priKeyHex.length < 64) priKeyHex = `0${priKeyHex}`;\n\n    return hexStr2byteArray(priKeyHex);\n}\n\nexport function computeAddress(pubBytes: SomeBytes) {\n    if (pubBytes.length === 65) pubBytes = pubBytes.slice(1);\n\n    const hash = keccak256(pubBytes).toString().substring(2);\n    const addressHex = ADDRESS_PREFIX + hash.substring(24);\n\n    return hexStr2byteArray(addressHex);\n}\n\nexport function getAddressFromPriKey(priKeyBytes: SomeBytes) {\n    const pubBytes = getPubKeyFromPriKey(priKeyBytes);\n    return computeAddress(pubBytes);\n}\n\nexport function decode58Check(addressStr: string) {\n    const decodeCheck = decode58(addressStr);\n\n    if (decodeCheck.length <= 4) return null;\n    const checkSum = decodeCheck.slice(-4);\n\n    const decodeData = decodeCheck.slice(0, decodeCheck.length - 4);\n    const hash = sha256(sha256(decodeData));\n\n    if (hash.slice(0, 4).join() === checkSum.join()) return decodeData;\n\n    return null;\n}\n\nexport function isAddressValid(base58Str: string) {\n    if (typeof base58Str !== 'string') return false;\n\n    if (base58Str.length !== ADDRESS_SIZE) return false;\n\n    let address = decode58(base58Str);\n\n    if (address.length !== 25) return false;\n\n    if (address[0] !== ADDRESS_PREFIX_BYTE) return false;\n\n    const checkSum = address.slice(21);\n    address = address.slice(0, 21);\n\n    const checkSum1 = sha256(sha256(address)).slice(0, 4);\n    return checkSum.join() === checkSum1.join();\n}\n\nexport function getBase58CheckAddressFromPriKeyBase64String(\n    priKeyBase64String: string,\n) {\n    const priKeyBytes = base64DecodeFromString(priKeyBase64String);\n    const pubBytes = getPubKeyFromPriKey(priKeyBytes);\n    const addressBytes = computeAddress(pubBytes);\n\n    return getBase58CheckAddress(addressBytes);\n}\n\nexport function getHexStrAddressFromPriKeyBase64String(\n    priKeyBase64String: string,\n) {\n    const priKeyBytes = base64DecodeFromString(priKeyBase64String);\n    const pubBytes = getPubKeyFromPriKey(priKeyBytes);\n    const addressBytes = computeAddress(pubBytes);\n    return byteArray2hexStr(addressBytes);\n}\n\nexport function getAddressFromPriKeyBase64String(priKeyBase64String: string) {\n    const priKeyBytes = base64DecodeFromString(priKeyBase64String);\n    const pubBytes = getPubKeyFromPriKey(priKeyBytes);\n    const addressBytes = computeAddress(pubBytes);\n    return base64EncodeToString(addressBytes);\n}\n\nexport function getPubKeyFromPriKey(priKeyBytes: SomeBytes) {\n    const ec = new EC('secp256k1');\n    const key = ec.keyFromPrivate(priKeyBytes, 'bytes');\n    const pubkey = key.getPublic();\n\n    const xHex = pubkey.x.toString('hex').padStart(64, '0');\n    const yHex = pubkey.y.toString('hex').padStart(64, '0');\n\n    const pubkeyHex = `04${xHex}${yHex}`;\n    return hexStr2byteArray(pubkeyHex);\n}\n\nexport function getECKeySig(hashBytes: SomeBytes, priKeyBytes: SomeBytes) {\n    const ec = new EC('secp256k1');\n    const key = ec.keyFromPrivate(priKeyBytes, 'bytes');\n    const signature = key.sign(hashBytes);\n\n    const rHex = signature.r.toString('hex').padStart(64, '0');\n    const sHex = signature.s.toString('hex').padStart(64, '0');\n    const idHex = byte2hexStr(signature.recoveryParam);\n    return rHex + sHex + idHex;\n}\nexport const ECKeySign = getECKeySig; // backwards-compatible alias\n\nexport function sha256(msgBytes: SomeBytes) {\n    const msgHex = byteArray2hexStr(msgBytes);\n    const hashHex = ethSha256('0x' + msgHex).replace(/^0x/, '');\n    return hexStr2byteArray(hashHex);\n}\n\nexport const SHA256 = sha256; // backwards-compatible alias\n\nexport function passwordToAddress(password: string) {\n    const com_priKeyBytes = base64DecodeFromString(password);\n    const com_addressBytes = getAddressFromPriKey(com_priKeyBytes);\n\n    return getBase58CheckAddress(com_addressBytes);\n}\n\nexport function pkToAddress(privateKey: string, strict = false) {\n    const com_priKeyBytes = hexStr2byteArray(privateKey, strict);\n    const com_addressBytes = getAddressFromPriKey(com_priKeyBytes);\n\n    return getBase58CheckAddress(com_addressBytes);\n}\n","import {TRON_BIP39_PATH_INDEX_0} from './address';\nimport {byteArray2hexStr} from './bytes';\nimport {\n    genPriKey,\n    getAddressFromPriKey,\n    getBase58CheckAddress,\n    getPubKeyFromPriKey,\n    pkToAddress,\n} from './crypto';\nimport type {Mnemonic, Wordlist} from './ethersUtils';\nimport {ethersWallet} from './ethersUtils';\nimport utils from './index';\n\nconst INVALID_TRON_PATH_ERROR_MSG = 'Invalid tron path provided';\n\nexport interface IAccountBase {\n    privateKey: string;\n    publicKey: string;\n}\nexport interface IAccountWithMnemonic extends IAccountBase {\n    mnemonic: Mnemonic;\n    address: string;\n}\nexport interface IAccount extends IAccountBase {\n    address: {base58: string; hex: string};\n}\n\nexport function generateAccount(): IAccount {\n    const priKeyBytes = genPriKey();\n    const pubKeyBytes = getPubKeyFromPriKey(priKeyBytes);\n    const addressBytes = getAddressFromPriKey(priKeyBytes);\n\n    const privateKey = byteArray2hexStr(priKeyBytes);\n    const publicKey = byteArray2hexStr(pubKeyBytes);\n\n    return {\n        privateKey,\n        publicKey,\n        address: {\n            base58: getBase58CheckAddress(addressBytes),\n            hex: byteArray2hexStr(addressBytes),\n        },\n    };\n}\n\nexport function generateRandom(options?: {\n    path?: string;\n}): IAccountWithMnemonic {\n    if (!utils.isObject(options)) options = {};\n    if (!options.path) options.path = TRON_BIP39_PATH_INDEX_0;\n\n    if (!String(options.path).match(/^m\\/44'\\/195'/))\n        throw new Error(INVALID_TRON_PATH_ERROR_MSG);\n\n    const account = ethersWallet.createRandom(options);\n\n    return {\n        mnemonic: account.mnemonic,\n        privateKey: account.privateKey,\n        publicKey: account.publicKey,\n        address: pkToAddress(account.privateKey.replace(/^0x/, '')),\n    };\n}\n\nexport function generateAccountWithMnemonic(\n    mnemonic: string,\n    path?: string | null,\n    wordlist: string | Wordlist = 'en',\n): IAccountWithMnemonic {\n    if (!path) path = TRON_BIP39_PATH_INDEX_0;\n\n    if (!String(path).match(/^m\\/44'\\/195'/))\n        throw new Error(INVALID_TRON_PATH_ERROR_MSG);\n\n    // FIXME: remove, if merged https://github.com/ethers-io/ethers.js/pull/3440\n    // @ts-ignore\n    const account = ethersWallet.fromMnemonic(mnemonic, path, wordlist);\n\n    return {\n        mnemonic: account.mnemonic,\n        privateKey: account.privateKey,\n        publicKey: account.publicKey,\n        address: pkToAddress(account.privateKey.replace(/^0x/, '')),\n    };\n}\n","import {ADDRESS_PREFIX} from './address';\nimport type {SomeBytes} from './bytes';\nimport {hexStr2byteArray} from './code';\nimport {getBase58CheckAddress} from './crypto';\nimport {\n    SigningKey,\n    concat,\n    joinSignature,\n    keccak256,\n    recoverAddress,\n    toUtf8Bytes,\n} from './ethersUtils';\n\nexport const TRON_MESSAGE_PREFIX = '\\x19TRON Signed Message:\\n';\n\nexport function hashMessage(message: string | SomeBytes): string {\n    if (typeof message === 'string') message = toUtf8Bytes(message);\n\n    return keccak256(\n        concat([\n            toUtf8Bytes(TRON_MESSAGE_PREFIX),\n            toUtf8Bytes(String(message.length)),\n            message,\n        ]),\n    );\n}\n\nexport function signMessage(\n    message: string | SomeBytes,\n    privateKey: string,\n): string {\n    if (!privateKey.match(/^0x/)) privateKey = '0x' + privateKey;\n\n    const signingKey = new SigningKey(privateKey);\n    const messageDigest = hashMessage(message);\n    const signature = signingKey.signDigest(messageDigest);\n\n    return joinSignature(signature);\n}\n\nexport function verifyMessage(\n    message: string | SomeBytes,\n    signature: string,\n): string {\n    if (!signature.match(/^0x/)) signature = '0x' + signature;\n\n    const recovered = recoverAddress(hashMessage(message), signature);\n    return getBase58CheckAddress(\n        hexStr2byteArray(recovered.replace(/^0x/, ADDRESS_PREFIX)),\n    );\n}\n","import BigNumber from 'bignumber.js';\nimport validator from 'validator';\n\nimport type {IAbiItem} from '../lib/contract/index';\nimport type {IEvent, IEventResponse} from '../lib/event';\nimport * as abi from './abi';\nimport * as accounts from './accounts';\nimport {ADDRESS_PREFIX} from './address';\nimport * as base58 from './base58';\nimport * as bytes from './bytes';\nimport * as code from './code';\nimport * as crypto from './crypto';\nimport * as ethersUtils from './ethersUtils';\nimport * as message from './message';\nimport {TypedDataEncoder as _TypedDataEncoder} from './typedData';\n\nconst utils = {\n    isValidURL(url: any): url is string {\n        if (typeof url !== 'string') return false;\n        return validator.isURL(url.toString(), {\n            protocols: ['http', 'https'],\n            require_tld: false,\n        });\n    },\n\n    isObject<T extends object>(obj: unknown): obj is T {\n        return (\n            obj === Object(obj) &&\n            Object.prototype.toString.call(obj) !== '[object Array]'\n        );\n    },\n\n    isArray(array: any): array is unknown[] {\n        return Array.isArray(array);\n    },\n\n    isJson(string: any): boolean {\n        try {\n            return !!JSON.parse(string);\n        } catch (ex) {\n            return false;\n        }\n    },\n\n    isBoolean(bool: any): bool is boolean {\n        return typeof bool === 'boolean';\n    },\n\n    isBigNumber(number: any): number is BigNumber {\n        return (\n            number &&\n            (number instanceof BigNumber ||\n                (number.constructor && number.constructor.name === 'BigNumber'))\n        );\n    },\n\n    isString(string: any): string is string {\n        return (\n            typeof string === 'string' ||\n            (string &&\n                string.constructor &&\n                string.constructor.name === 'String')\n        );\n    },\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    isFunction(obj: any): obj is Function {\n        return typeof obj === 'function';\n    },\n\n    isHex(string: any): string is string {\n        return (\n            typeof string === 'string' &&\n            !isNaN(parseInt(string, 16)) &&\n            /^(0x|)[a-fA-F0-9]+$/.test(string)\n        );\n    },\n\n    isInteger(number: any): number is number {\n        if (number === null) return false;\n        return Number.isInteger(Number(number));\n    },\n\n    hasProperty(obj: any, property: string): boolean {\n        return Object.prototype.hasOwnProperty.call(obj, property);\n    },\n\n    hasProperties(obj: any, ...properties: string[]): boolean {\n        return (\n            !!properties.length &&\n            !properties\n                .map((property) => {\n                    return this.hasProperty(obj, property);\n                })\n                .includes(false)\n        );\n    },\n\n    mapEvent(event: IEventResponse): IEvent {\n        const data = {\n            block: event.block_number,\n            timestamp: event.block_timestamp,\n            contract: event.contract_address,\n            name: event.event_name,\n            transaction: event.transaction_id,\n            result: event.result,\n            resourceNode:\n                event.resource_Node ||\n                (event._unconfirmed ? 'fullNode' : 'solidityNode'),\n        } as any;\n        if (event._unconfirmed) data.unconfirmed = event._unconfirmed;\n        if (event._fingerprint) data.fingerprint = event._fingerprint;\n        return data;\n    },\n\n    parseEvent(event: IEvent, {inputs: abi}: {inputs: IAbiItem[]}): IEvent {\n        if (!event.result) return event;\n\n        if (this.isArray(event.result))\n            event.result = event.result.reduce(\n                (obj: Record<string, unknown>, result, index) => {\n                    const {name, type} = abi[index];\n\n                    if (type === 'address')\n                        result =\n                            ADDRESS_PREFIX +\n                            (result as string).substr(2).toLowerCase();\n\n                    obj[name] = result;\n\n                    return obj;\n                },\n                {},\n            );\n        else if (this.isObject(event.result))\n            for (let i = 0; i < abi.length; i++) {\n                const obj = abi[i];\n                if (obj.type === 'address' && obj.name in event.result)\n                    event.result[obj.name] =\n                        ADDRESS_PREFIX +\n                        (event.result[obj.name] as string)\n                            .substr(2)\n                            .toLowerCase();\n            }\n\n        return event;\n    },\n\n    padLeft(input: any, padding: string, amount: number): string {\n        let res = input.toString();\n        while (res.length < amount) res = padding + res;\n        return res;\n    },\n\n    isNotNullOrUndefined<T>(\n        val: T,\n    ): val is Exclude<Exclude<T, null>, undefined> {\n        return val !== null && typeof val !== 'undefined';\n    },\n\n    async sleep(millis = 1000): Promise<never> {\n        return new Promise((resolve) => setTimeout(resolve, millis));\n    },\n};\n\nexport default {\n    ...utils,\n    code,\n    accounts,\n    base58,\n    bytes,\n    crypto,\n    abi,\n    message,\n    _TypedDataEncoder,\n    ethersUtils,\n};\n","import Contract from '.';\nimport type {IAbiItem, IFuncAbi} from '.';\nimport type {ContractEventOptions} from '.';\nimport utils from '../../utils';\nimport {WithTronwebAndInjectpromise} from '../../utils/_base';\nimport {decodeParamsV2ByABI, encodeParamsV2ByABI} from '../../utils/abi';\nimport type _CallbackT from '../../utils/typing';\nimport type {\n    ContractOptions,\n    ITriggerConstantContract,\n    ITriggerContractOptions,\n} from '../transactionBuilder';\nimport type {ITransactionInfo} from '../trx';\n\nexport interface IMethodSendOptions extends Partial<ContractOptions> {\n    from?: string;\n    shouldPollResponse?: boolean;\n    maxRetries?: number; // Default: 20\n    pollingInterval?: number; // Default: 3000 [ms]\n    rawResponse?: boolean;\n    keepTxID?: boolean;\n}\n\nconst MISSING_ADDRESS_MSG = 'Smart contract is missing address';\n\nconst getFunctionSelector = (abi) => {\n    abi.stateMutability = abi.stateMutability\n        ? abi.stateMutability.toLowerCase()\n        : 'nonpayable';\n    abi.type = abi.type ? abi.type.toLowerCase() : '';\n    if (abi.type === 'fallback' || abi.type === 'receive') return '0x';\n    const iface = new utils.ethersUtils.Interface([abi]);\n    if (abi.type === 'event')\n        return iface\n            .getEvent(abi.name)\n            .format(utils.ethersUtils.FormatTypes.sighash);\n\n    return iface\n        .getFunction(abi.name)\n        .format(utils.ethersUtils.FormatTypes.sighash);\n};\n\nconst decodeOutput = (abi, output) => {\n    return decodeParamsV2ByABI(abi, output);\n};\n\nexport interface IOnMethod {\n    call(options?: ITriggerContractOptions, callback?: undefined): Promise<any>;\n    call(\n        options: ITriggerContractOptions | undefined,\n        callback: _CallbackT<any>,\n    ): Promise<void>;\n\n    send(\n        options: IMethodSendOptions & {shouldPollResponse: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    send(\n        options: IMethodSendOptions & {shouldPollResponse: false},\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, any]>;\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, any]>,\n    ): Promise<void>;\n\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: false;\n            keepTxID: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<any>;\n    send(\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: false;\n            keepTxID: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<any>,\n    ): Promise<void>;\n\n    send(\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<any>,\n    ): Promise<any>;\n\n    watch(\n        options: ContractEventOptions,\n        callback: _CallbackT<any>,\n    ): Promise<{\n        start: () => void;\n        stop: () => void;\n    }>;\n}\n\nexport default class Method extends WithTronwebAndInjectpromise {\n    contract: Contract;\n    abi: IFuncAbi;\n    name: string;\n    inputs: IAbiItem[];\n    outputs: IAbiItem[];\n    functionSelector: string;\n    signature: string;\n    defaultOptions: {\n        feeLimit: number;\n        callValue: number;\n        userFeePercentage: number;\n        shouldPollResponse: boolean;\n    };\n\n    constructor(contract: Contract, abi: IFuncAbi) {\n        super(contract.tronWeb);\n\n        this.contract = contract;\n\n        this.abi = abi;\n        this.name = abi.name || (abi.name = abi.type);\n\n        this.inputs = abi.inputs || [];\n        this.outputs = abi.outputs || [];\n\n        this.functionSelector = getFunctionSelector(abi);\n        this.signature = this.tronWeb\n            .sha3(this.functionSelector, false)\n            .slice(0, 8);\n\n        this.defaultOptions = {\n            feeLimit: this.tronWeb.feeLimit,\n            callValue: 0,\n            userFeePercentage: 100,\n            shouldPollResponse: false,\n        };\n    }\n\n    decodeInput(data) {\n        return decodeOutput(this.inputs, '0x' + data);\n    }\n\n    onMethod(...args) {\n        let rawParameter = '';\n        if (this.abi && !/event/i.test(this.abi.type))\n            rawParameter = encodeParamsV2ByABI(this.abi, args);\n\n        return {\n            call: (\n                options: ITriggerContractOptions = {},\n                callback?: _CallbackT<any>,\n            ) => {\n                options = {\n                    ...options,\n                    rawParameter,\n                };\n\n                return this._call([], [], options, callback);\n            },\n\n            send: (\n                options: Partial<ContractOptions> & IMethodSendOptions = {},\n                privateKey: string = this.tronWeb.defaultPrivateKey,\n                callback?: _CallbackT<any>,\n            ) => {\n                options = {\n                    ...options,\n                    rawParameter,\n                };\n\n                return this._send([], [], options, privateKey, callback);\n            },\n            watch: (this['_watch'] = this._watch.bind(this)),\n        } as IOnMethod;\n    }\n\n    async _call(\n        types: string[],\n        args: unknown[],\n        options: ITriggerContractOptions = {},\n        callback?: _CallbackT<any>,\n    ) {\n        if (!callback)\n            return this.injectPromise(this._call, types, args, options);\n\n        if (types.length !== args.length)\n            return callback('Invalid argument count provided');\n\n        if (!this.contract.address) return callback(MISSING_ADDRESS_MSG);\n\n        if (!this.contract.deployed)\n            return callback(\n                'Calling smart contracts requires you to load the contract first',\n            );\n\n        const {stateMutability} = this.abi;\n\n        if (!['pure', 'view'].includes(stateMutability.toLowerCase()))\n            return callback(\n                `Methods with state mutability \"${stateMutability}\" must use send()`,\n            );\n\n        const final_options: ContractOptions & {\n            _isConstant: boolean;\n            from: string;\n        } = {\n            ...this.defaultOptions,\n            from: this.tronWeb.defaultAddress.hex,\n            ...options,\n            _isConstant: true,\n        } as any;\n\n        const parameters = args.map((value, index) => ({\n            type: types[index],\n            value,\n        }));\n\n        // Changed by me, was triggerSmartContract\n        this.tronWeb.transactionBuilder.triggerConstantContract(\n            this.contract.address,\n            this.functionSelector,\n            final_options,\n            parameters,\n            final_options.from\n                ? this.tronWeb.address.toHex(final_options.from)\n                : undefined,\n            (err: unknown, transaction?: ITriggerConstantContract): void => {\n                if (err) return callback(err);\n\n                if (\n                    !transaction ||\n                    !utils.hasProperty(transaction, 'constant_result')\n                )\n                    return callback('Failed to execute');\n\n                try {\n                    const len = transaction.constant_result[0].length;\n                    if (len === 0 || len % 64 === 8) {\n                        let msg =\n                            'The call has been reverted or has thrown an error.';\n                        if (len !== 0) {\n                            msg += ' Error message: ';\n                            let msg2 = '';\n                            const chunk =\n                                transaction.constant_result[0].substring(8);\n                            for (let i = 0; i < len - 8; i += 64)\n                                msg2 += this.tronWeb.toUtf8(\n                                    chunk.substring(i, i + 64),\n                                );\n\n                            msg += msg2\n                                // eslint-disable-next-line no-control-regex\n                                .replace(/(\\u0000|\\u000b|\\f)+/g, ' ')\n                                .replace(/ +/g, ' ')\n                                .replace(/\\s+$/g, '');\n                        }\n                        return callback(msg);\n                    }\n\n                    let output = decodeOutput(\n                        this.abi,\n                        '0x' + transaction.constant_result[0],\n                    );\n\n                    if (output.length === 1 && Object.keys(output).length === 1)\n                        output = output[0];\n\n                    return callback(null, output);\n                } catch (ex) {\n                    return callback(ex);\n                }\n            },\n        );\n    }\n\n    async _send(\n        types: string[],\n        args: unknown[],\n        options: IMethodSendOptions = {},\n        privateKey: string = this.tronWeb.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ) {\n        if (!callback)\n            return this.injectPromise(\n                this._send,\n                types,\n                args,\n                options,\n                privateKey,\n            );\n\n        if (types.length !== args.length)\n            throw new Error('Invalid argument count provided');\n\n        if (!this.contract.address) return callback(MISSING_ADDRESS_MSG);\n\n        if (!this.contract.deployed)\n            return callback(\n                'Calling smart contracts requires you to load the contract first',\n            );\n\n        const {stateMutability} = this.abi;\n\n        if (['pure', 'view'].includes(stateMutability.toLowerCase()))\n            return callback(\n                `Methods with state mutability \"${stateMutability}\" must use call()`,\n            );\n\n        // If a function isn't payable, dont provide a callValue.\n        if (!['payable'].includes(stateMutability.toLowerCase()))\n            options.callValue = 0;\n\n        // TODO: this intersection may be not needed after final options cleanup\n        const final_options: ContractOptions & IMethodSendOptions = {\n            ...this.defaultOptions,\n            from: this.tronWeb.defaultAddress.hex,\n            ...options,\n        } as any;\n\n        const parameters = args.map((value, index) => ({\n            type: types[index],\n            value,\n        }));\n\n        try {\n            const address = privateKey\n                ? this.tronWeb.address.fromPrivateKey(privateKey)\n                : this.tronWeb.defaultAddress.base58;\n            const transaction =\n                await this.tronWeb.transactionBuilder.triggerSmartContract(\n                    this.contract.address,\n                    this.functionSelector,\n                    final_options,\n                    parameters,\n                    this.tronWeb.address.toHex(address),\n                );\n\n            if (!transaction.result || !transaction.result.result)\n                return callback(\n                    'Unknown error: ' + JSON.stringify(transaction, null, 2),\n                );\n\n            // If privateKey is false, this won't be signed here.\n            // We assume sign functionality will be replaced.\n            const signedTransaction = await this.tronWeb.trx.sign(\n                transaction.transaction,\n                privateKey,\n            );\n\n            if (!signedTransaction.signature) {\n                if (!privateKey)\n                    return callback('Transaction was not signed properly');\n\n                return callback('Invalid private key provided');\n            }\n\n            const broadcast = await this.tronWeb.trx.sendRawTransaction(\n                signedTransaction,\n            );\n\n            if (broadcast.code) {\n                const err = {\n                    error: broadcast.code,\n                    message: broadcast.code,\n                };\n                if (broadcast.message)\n                    err.message = this.tronWeb.toUtf8(broadcast.message);\n                return callback(err);\n            }\n\n            if (!final_options.shouldPollResponse)\n                return callback(null, signedTransaction.txID);\n\n            const {maxRetries = 20, pollingInterval = 3_000} = options;\n\n            const checkResult = async (index = 0) => {\n                if (index === maxRetries - 1)\n                    return callback({\n                        error: 'Cannot find result in solidity node',\n                        transaction: signedTransaction,\n                    });\n\n                const output = await this.tronWeb.trx.getTransactionInfo(\n                    signedTransaction.txID,\n                );\n\n                if (!Object.keys(output).length)\n                    return setTimeout(() => {\n                        checkResult(index + 1);\n                    }, pollingInterval);\n\n                if ('result' in output && output.result === 'FAILED')\n                    return callback({\n                        error: this.tronWeb.toUtf8(output.resMessage!),\n                        transaction: signedTransaction,\n                        output,\n                    });\n\n                if (!utils.hasProperty(output, 'contractResult'))\n                    return callback({\n                        error:\n                            'Failed to execute: ' +\n                            JSON.stringify(output, null, 2),\n                        transaction: signedTransaction,\n                        output,\n                    });\n\n                if (final_options.rawResponse) return callback(null, output);\n\n                let decoded = decodeOutput(\n                    this.abi,\n                    '0x' + output.contractResult[0],\n                );\n\n                if (decoded.length === 1 && Object.keys(decoded).length === 1)\n                    decoded = decoded[0];\n\n                if (final_options.keepTxID)\n                    return callback(null, [signedTransaction.txID, decoded]);\n\n                return callback(null, decoded);\n            };\n\n            checkResult();\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async _watch(\n        options: Partial<ContractEventOptions> = {},\n        callback: _CallbackT<any>,\n    ) {\n        if (!utils.isFunction(callback))\n            throw new Error('Expected callback to be provided');\n\n        if (!this.contract.address) return callback(MISSING_ADDRESS_MSG);\n\n        if (!this.abi.type || !/event/i.test(this.abi.type))\n            return callback('Invalid method type for event watching');\n\n        if (!this.tronWeb.eventServer)\n            return callback('No event server configured');\n\n        let listener: NodeJS.Timer | null = null;\n        let lastBlock: number | null = null;\n        const since = Date.now() - 1000;\n\n        const getEvents = async () => {\n            if (!this.contract.address) throw new Error(MISSING_ADDRESS_MSG);\n\n            try {\n                const params = {\n                    since,\n                    eventName: this.name,\n                    sort: 'block_timestamp',\n                    blockNumber: 'latest',\n                    filters: options.filters,\n                } as Record<string, unknown>;\n\n                if (options.size) params.size = options.size;\n\n                if (options.resourceNode)\n                    if (/full/i.test(options.resourceNode))\n                        params.onlyUnconfirmed = true;\n                    else params.onlyConfirmed = true;\n\n                const events =\n                    await this.tronWeb.event.getEventsByContractAddress(\n                        this.contract.address,\n                        params,\n                    );\n                const [latestEvent] = events.sort((a, b) => b.block - a.block);\n                const newEvents = events.filter((event, index) => {\n                    if (\n                        options.resourceNode &&\n                        event.resourceNode &&\n                        options.resourceNode.toLowerCase() !==\n                            event.resourceNode.toLowerCase()\n                    )\n                        return false;\n\n                    const duplicate = events\n                        .slice(0, index)\n                        .some(\n                            (priorEvent) =>\n                                JSON.stringify(priorEvent) ===\n                                JSON.stringify(event),\n                        );\n\n                    if (duplicate) return false;\n\n                    if (!lastBlock) return true;\n\n                    return event.block > lastBlock;\n                });\n\n                if (latestEvent) lastBlock = latestEvent.block;\n\n                return newEvents;\n            } catch (ex) {\n                return Promise.reject(ex);\n            }\n        };\n\n        const bindListener = () => {\n            if (listener) clearInterval(listener);\n\n            listener = setInterval(() => {\n                getEvents()\n                    .then((events) =>\n                        events.forEach((event) => {\n                            callback(null, utils.parseEvent(event, this.abi));\n                        }),\n                    )\n                    .catch((err) => callback(err));\n            }, 3000);\n        };\n\n        await getEvents();\n        bindListener();\n\n        return {\n            start: bindListener,\n            stop: () => {\n                if (!listener) return;\n\n                clearInterval(listener);\n                listener = null;\n            },\n        };\n    }\n}\n","import TronWeb from '../..';\nimport {WithTronwebAndInjectpromise} from '../../../src/utils/_base';\nimport type {SmartContract_ABI_Entry_StateMutabilityType as IAbiStateMutability} from '../../proto/core/contract/smart_contract';\nimport utils from '../../utils';\nimport type _CallbackT from '../../utils/typing';\nimport type {IEvent} from '../event';\nimport type {ContractOptions} from '../transactionBuilder';\nimport Method from './method';\n\nexport type {IMethodSendOptions} from './method';\n\nexport interface IAbiItem {\n    name: string;\n    type: string;\n    components?: IAbiItem[];\n    internalType?: string;\n}\nexport interface IEventAbiItem extends IAbiItem {\n    indexed: boolean;\n}\nexport interface IFuncAbi {\n    name: string;\n    type: 'function' | 'constructor' | 'receive' | 'fallback';\n    stateMutability: IAbiStateMutability;\n    inputs: IAbiItem[];\n    outputs: IAbiItem[];\n    constant?: boolean;\n    payable?: boolean;\n}\nexport interface IEventAbi {\n    name: string;\n    type: 'event';\n    inputs: IEventAbiItem[];\n    anonymous: boolean;\n}\nexport interface IErrorAbi {\n    name: string;\n    type: 'error';\n    inputs: IEventAbiItem[];\n}\nexport type IAbi = IFuncAbi | IEventAbi | IErrorAbi;\n\nexport interface ContractEventOptions {\n    sinceTimestamp?: number;\n    since?: any;\n    fromTimestamp?: number;\n    eventName?: string;\n    blockNumber?: number;\n    size?: number;\n    page?: number;\n    onlyConfirmed?: any;\n    onlyUnconfirmed?: any;\n    previousLastEventFingerprint?: any;\n    previousFingerprint?: any;\n    fingerprint?: any;\n    rawResponse?: boolean;\n    sort?: string;\n    filters?: unknown | unknown[];\n    resourceNode?: string;\n}\n\nclass _Contract extends WithTronwebAndInjectpromise {\n    address: string | null;\n    abi: IAbi[];\n    eventListener: NodeJS.Timer | null | undefined;\n    eventCallback: ((event: IEvent) => void) | null | undefined;\n    bytecode: unknown;\n    deployed: boolean;\n    lastBlock: unknown;\n    methods: Record<string, MethodCallT>;\n    methodInstances: Record<string, Method>;\n    props: string[];\n\n    constructor(tronWeb: TronWeb, abi: IAbi[] = [], address?: string) {\n        super(tronWeb);\n\n        this.address = address || null;\n        this.abi = abi;\n\n        this.eventListener = null;\n        this.eventCallback = null;\n        this.bytecode = null;\n        this.deployed = false;\n        this.lastBlock = null;\n\n        this.methods = {};\n        this.methodInstances = {};\n        this.props = [];\n\n        if (this.tronWeb.isAddress(address)) this.deployed = true;\n        else this.address = null;\n\n        this.loadAbi(abi);\n\n        return this;\n    }\n\n    async _getEvents(options: ContractEventOptions = {}) {\n        if (!this.address)\n            throw new Error('Contract is not configured with an address');\n        if (options.rawResponse)\n            throw new Error('Cannot parse raw response here.');\n\n        const events = await this.tronWeb.event.getEventsByContractAddress(\n            this.address,\n            options as ContractEventOptions & {rawResponse?: false},\n        );\n        const [latestEvent] = events.sort((a, b) => b.block - a.block);\n        const newEvents = events.filter((event, index) => {\n            if (\n                options.resourceNode &&\n                event.resourceNode &&\n                options.resourceNode.toLowerCase() !==\n                    event.resourceNode.toLowerCase()\n            )\n                return false;\n\n            const duplicate = events\n                .slice(0, index)\n                .some(\n                    (priorEvent) =>\n                        JSON.stringify(priorEvent) === JSON.stringify(event),\n                );\n\n            if (duplicate) return false;\n\n            if (!this.lastBlock) return true;\n\n            return event.block > this.lastBlock;\n        });\n\n        if (latestEvent) this.lastBlock = latestEvent.block;\n\n        return newEvents;\n    }\n\n    async _startEventListener(\n        options: ContractEventOptions = {},\n        callback?: (event: IEvent) => void,\n    ) {\n        if (this.eventListener) clearInterval(this.eventListener);\n\n        if (!this.tronWeb.eventServer)\n            throw new Error('Event server is not configured');\n\n        if (!this.address)\n            throw new Error('Contract is not configured with an address');\n\n        this.eventCallback = callback;\n        await this._getEvents(options);\n\n        this.eventListener = setInterval(() => {\n            this._getEvents(options)\n                .then((newEvents) =>\n                    newEvents.forEach((event) => {\n                        this.eventCallback && this.eventCallback(event);\n                    }),\n                )\n                .catch((err) => {\n                    console.error('Failed to get event list', err);\n                });\n        }, 3000);\n    }\n\n    _stopEventListener() {\n        if (!this.eventListener) return;\n\n        clearInterval(this.eventListener);\n        this.eventListener = null;\n        this.eventCallback = null;\n    }\n\n    hasProperty(property: string): boolean {\n        return (\n            Object.prototype.hasOwnProperty.call(this, property) ||\n            // TODO: just remove this, it's very old stuff\n            (this as any).__proto__.hasOwnProperty(property) // eslint-disable-line\n        );\n    }\n\n    loadAbi(abi: IAbi[]) {\n        this.abi = abi;\n        this.methods = {};\n\n        this.props.forEach((prop) => delete this[prop]);\n\n        abi.forEach((func) => {\n            // Don't build a method for constructor function.\n            // That's handled through contract create.\n            if (\n                !func.type ||\n                /constructor/i.test(func.type) ||\n                func.type === 'event' ||\n                func.type === 'error'\n            )\n                return;\n\n            const method = new Method(this as unknown as Contract, func);\n            const methodCall = method.onMethod.bind(method);\n\n            const {name, functionSelector, signature} = method;\n\n            this.methods[name] = methodCall;\n            this.methods[functionSelector] = methodCall;\n            this.methods[signature] = methodCall;\n\n            this.methodInstances[name] = method;\n            this.methodInstances[functionSelector] = method;\n            this.methodInstances[signature] = method;\n\n            if (!this.hasProperty(name)) {\n                this[name] = methodCall;\n                this.props.push(name);\n            }\n\n            if (!this.hasProperty(functionSelector)) {\n                this[functionSelector] = methodCall;\n                this.props.push(functionSelector);\n            }\n\n            if (!this.hasProperty(signature)) {\n                this[signature] = methodCall;\n                this.props.push(signature);\n            }\n        });\n    }\n\n    decodeInput(data: string) {\n        const methodName = data.substring(0, 8);\n        const inputData = data.substring(8);\n\n        if (!this.methodInstances[methodName])\n            throw new Error('Contract method ' + methodName + ' not found');\n\n        const methodInstance = this.methodInstances[methodName];\n\n        return {\n            name: methodInstance.name,\n            params: this.methodInstances[methodName].decodeInput(inputData),\n        };\n    }\n\n    async new(\n        options: ContractOptions,\n        privateKey: string,\n        callback?: unknown,\n    ): Promise<this>;\n    async new(\n        options: ContractOptions,\n        privateKey: string,\n        callback: _CallbackT<this>,\n    ): Promise<void>;\n    async new(\n        options: ContractOptions,\n        privateKey: string = this.tronWeb.defaultPrivateKey,\n        callback?: _CallbackT<this>,\n    ): Promise<void | this> {\n        if (!callback) return this.injectPromise(this.new, options, privateKey);\n\n        try {\n            const address = this.tronWeb.address.fromPrivateKey(privateKey);\n            if (!address) return callback('Invalid privateKey provided!');\n\n            const transaction =\n                await this.tronWeb.transactionBuilder.createSmartContract(\n                    options,\n                    address,\n                );\n            const signedTransaction = await this.tronWeb.trx.sign(\n                transaction,\n                privateKey,\n            );\n            const contract = await this.tronWeb.trx.sendRawTransaction(\n                signedTransaction,\n            );\n\n            if (contract.code)\n                return callback({\n                    error: contract.code,\n                    message: this.tronWeb.toUtf8(contract.message),\n                });\n\n            await utils.sleep(3000);\n            return this.at(signedTransaction.contract_address, callback);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async at(contractAddress: string, callback?: unknown): Promise<this>;\n    async at(\n        contractAddress: string,\n        callback: _CallbackT<this>,\n    ): Promise<void>;\n    async at(\n        contractAddress: string,\n        callback?: _CallbackT<this>,\n    ): Promise<void | this> {\n        if (!callback) return this.injectPromise(this.at, contractAddress);\n\n        try {\n            const contract = await this.tronWeb.trx.getContract(\n                contractAddress,\n            );\n\n            if (!contract.contract_address)\n                return callback(\n                    'Unknown error: ' + JSON.stringify(contract, null, 2),\n                );\n\n            this.address = contract.contract_address;\n            this.bytecode = contract.bytecode;\n            this.deployed = true;\n\n            this.loadAbi(\n                contract.abi?.entrys ? (contract.abi.entrys as IAbi[]) : [],\n            );\n\n            return callback(null, this);\n        } catch (ex) {\n            if (ex?.toString && ex.toString().includes('does not exist'))\n                return callback(\n                    'Contract has not been deployed on the network',\n                );\n\n            return callback(ex);\n        }\n    }\n\n    events(options: ContractEventOptions = {}, callback: _CallbackT<any>) {\n        if (!utils.isFunction(callback))\n            throw new Error('Callback function expected');\n\n        const self = this;\n\n        return {\n            start(startCallback: (err?: unknown) => unknown) {\n                if (!startCallback) {\n                    self._startEventListener(options, callback);\n                    return this;\n                }\n\n                self._startEventListener(options, callback)\n                    .then(() => {\n                        startCallback();\n                    })\n                    .catch((err) => {\n                        startCallback(err);\n                    });\n\n                return this;\n            },\n            stop() {\n                self._stopEventListener();\n            },\n        };\n    }\n}\n\n// Hack\n// Pretend like we export class that has additional method-based properties\ntype MethodCallT = Method['onMethod'];\ntype ContractT = _Contract & {[key: string]: MethodCallT};\nconst _ContractI: {\n    new (tronWeb: TronWeb, abi: IAbi[], address?: string): ContractT;\n} = _Contract as any;\n\nexport default class Contract extends _ContractI {}\n// export default Contract;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"querystring\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"axios\");","import axios from 'axios';\nimport type {AxiosInstance, Method} from 'axios';\n\nimport type {\n    Wallet,\n    WalletExtension,\n    WalletSolidity,\n} from '../../proto/api/api';\nimport type {Transaction as ITransaction} from '../../proto/core/Tron';\nimport utils from '../../utils';\nimport type {IEventResponse} from '../event';\nimport {\n    serviceToUrl,\n    walletExtensionMethods,\n    walletMethods,\n    walletSolidityMethods,\n} from './serviceToUrl';\n\nexport class HttpProvider {\n    host: string;\n    timeout: number;\n    user: string | undefined;\n    password: string | undefined;\n    headers: Record<string, string>;\n    statusPage: string;\n    instance: AxiosInstance;\n\n    constructor(\n        host: string,\n        timeout = 30000,\n        user: string | undefined = undefined,\n        password: string | undefined = undefined,\n        headers: Record<string, string> = {},\n        statusPage = '/',\n    ) {\n        if (!utils.isValidURL(host))\n            throw new Error('Invalid URL provided to HttpProvider');\n\n        if (isNaN(timeout) || timeout < 0)\n            throw new Error('Invalid timeout duration provided');\n\n        if (!utils.isObject(headers))\n            throw new Error('Invalid headers object provided');\n\n        host = host.replace(/\\/+$/, '');\n\n        this.host = host;\n        this.timeout = timeout;\n        this.user = user;\n        this.password = password;\n        this.headers = headers;\n        this.statusPage = statusPage;\n\n        this.instance = axios.create({\n            baseURL: host,\n            timeout: timeout,\n            headers: headers,\n            // TODO: was it a typo? was `user` before, and axios refuse to accept it\n            auth:\n                user && password\n                    ? {\n                          // user,\n                          username: user,\n                          password,\n                      }\n                    : undefined,\n        });\n    }\n\n    setStatusPage(statusPage = '/') {\n        this.statusPage = statusPage;\n    }\n\n    async isConnected(statusPage = this.statusPage) {\n        return this.request(statusPage)\n            .then((data) => {\n                return utils.hasProperties(data, 'blockID', 'block_header');\n            })\n            .catch(() => false);\n    }\n\n    request<T extends string & keyof typeof walletMethods>(\n        serviceName: `wallet/${T}` | `/wallet/${T}`,\n        payload?: undefined,\n        method?: 'get' | 'GET',\n    ): ReturnType<Wallet[typeof walletMethods[T]]>;\n    request<T extends string & keyof typeof walletMethods>(\n        serviceName: `wallet/${T}` | `/wallet/${T}`,\n        payload: Parameters<Wallet[typeof walletMethods[T]]>[0],\n        method?: 'post' | 'POST',\n    ): ReturnType<Wallet[typeof walletMethods[T]]>;\n    request<T extends string & keyof typeof walletMethods>(\n        serviceName: `wallet/${T}` | `/wallet/${T}`,\n        payload?: Parameters<\n            Wallet[typeof walletMethods[T]]\n        >[0] extends ITransaction\n            ? Parameters<Wallet[typeof walletMethods[T]]>[0]\n            : never,\n        method?: Method,\n    ): ReturnType<Wallet[typeof walletMethods[T]]>;\n    request<T extends string & keyof typeof walletMethods>(\n        serviceName: `wallet/${T}` | `/wallet/${T}`,\n        payload: Parameters<Wallet[typeof walletMethods[T]]>[0],\n        method?: Method,\n    ): ReturnType<Wallet[typeof walletMethods[T]]>;\n    request<T extends string & keyof typeof walletSolidityMethods>(\n        serviceName: `walletsolidity/${T}` | `/walletsolidity/${T}`,\n        payload?: undefined,\n        method?: 'get' | 'GET',\n    ): ReturnType<WalletSolidity[typeof walletSolidityMethods[T]]>;\n    request<T extends string & keyof typeof walletSolidityMethods>(\n        serviceName: `walletsolidity/${T}` | `/walletsolidity/${T}`,\n        payload?: Parameters<\n            WalletSolidity[typeof walletSolidityMethods[T]]\n        >[0] extends ITransaction\n            ? Parameters<WalletSolidity[typeof walletSolidityMethods[T]]>[0]\n            : never,\n        method?: Method,\n    ): ReturnType<WalletSolidity[typeof walletSolidityMethods[T]]>;\n    request<T extends string & keyof typeof walletSolidityMethods>(\n        serviceName: `walletsolidity/${T}` | `/walletsolidity/${T}`,\n        payload: Parameters<WalletSolidity[typeof walletSolidityMethods[T]]>[0],\n        method?: Method,\n    ): ReturnType<WalletSolidity[typeof walletSolidityMethods[T]]>;\n    request<T extends string & keyof typeof walletExtensionMethods>(\n        serviceName: `walletextension/${T}` | `/walletextension/${T}`,\n        payload?: undefined,\n        method?: 'get' | 'GET',\n    ): ReturnType<WalletExtension[typeof walletExtensionMethods[T]]>;\n    request<T extends string & keyof typeof walletExtensionMethods>(\n        serviceName: `walletextension/${T}` | `/walletextension/${T}`,\n        payload?: Parameters<\n            WalletExtension[typeof walletExtensionMethods[T]]\n        >[0] extends ITransaction\n            ? Parameters<WalletExtension[typeof walletExtensionMethods[T]]>[0]\n            : never,\n        method?: Method,\n    ): ReturnType<WalletExtension[typeof walletExtensionMethods[T]]>;\n    request<T extends string & keyof typeof walletExtensionMethods>(\n        serviceName: `walletextension/${T}` | `/walletextension/${T}`,\n        payload: Parameters<\n            WalletExtension[typeof walletExtensionMethods[T]]\n        >[0],\n        method?: Method,\n    ): ReturnType<WalletExtension[typeof walletExtensionMethods[T]]>;\n    request<T extends string, Q extends 'transaction' | 'contract'>(\n        serviceName: `event/${Q}/${T}` | `/event/${Q}/${T}`,\n        payload?: undefined,\n        method?: 'get' | 'GET',\n    ): Promise<IEventResponse[]>;\n    request(\n        serviceName: string,\n        payload?: undefined,\n        method?: Method,\n    ): Promise<unknown>;\n    request(serviceName: string, payload = {}, method: Method = 'get') {\n        method = method.toLowerCase() as Method;\n        return this.instance\n            .request({\n                data:\n                    method === 'post' && Object.keys(payload).length\n                        ? payload\n                        : null,\n                params: method === 'get' && payload,\n                url: serviceToUrl(serviceName),\n                method,\n            })\n            .then(({data}) => data);\n    }\n}\n","import {HttpProvider} from './HttpProvider';\n\nexport {HttpProvider} from './HttpProvider';\n\nexport default {\n    HttpProvider,\n};\n","import querystring from 'querystring';\n\nimport {WithTronwebAndInjectpromise} from '../../src/utils/_base';\nimport utils from '../utils';\nimport type _CallbackT from '../utils/typing';\nimport type {ContractEventOptions} from './contract';\nimport * as providers from './providers';\n\nexport interface IEventResponse {\n    block_number: number;\n    block_timestamp: number;\n    contract_address: string;\n    event_name: string;\n    transaction_id: string;\n    result: Record<string, unknown> | unknown[];\n    resource_Node?: string;\n    _unconfirmed?: boolean;\n    _fingerprint?: string;\n}\nexport interface IEvent {\n    block: number;\n    timestamp: number;\n    contract: string;\n    name: string;\n    transaction: string;\n    result: Record<string, unknown> | unknown[];\n    resourceNode?: string;\n    unconfirmed?: boolean;\n    fingerprint?: string;\n}\n\nexport default class Event extends WithTronwebAndInjectpromise {\n    setServer(\n        eventServer: string | providers.HttpProvider | null | undefined,\n        healthcheck = 'healthcheck',\n    ): void {\n        // tronWeb instance attrs are handled in a weird way\n        // All usages do not check for undefined, but allow to set\n        // attrs to undefined regularly.\n        // FIXME: should it be allowed?\n        // @ts-ignore\n        if (!eventServer) return (this.tronWeb.eventServer = undefined);\n\n        if (utils.isString(eventServer))\n            eventServer = new providers.HttpProvider(eventServer);\n\n        if (!this.tronWeb.isValidProvider(eventServer))\n            throw new Error('Invalid event server provided');\n\n        this.tronWeb.eventServer = eventServer;\n        this.tronWeb.eventServer.isConnected = () =>\n            this.tronWeb.eventServer\n                .request(healthcheck)\n                .then(() => true)\n                .catch(() => false);\n    }\n\n    getEventsByContractAddress(\n        contractAddress: string,\n        options?: ContractEventOptions & {rawResponse: true},\n        callback?: undefined,\n    ): Promise<IEventResponse[]>;\n    getEventsByContractAddress(\n        contractAddress: string,\n        options?: ContractEventOptions & {rawResponse?: false},\n        callback?: undefined,\n    ): Promise<IEvent[]>;\n    getEventsByContractAddress(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback: _CallbackT<IEventResponse[]>,\n    ): void;\n    getEventsByContractAddress(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback: _CallbackT<IEvent[]>,\n    ): void;\n    getEventsByContractAddress(\n        contractAddress: string,\n        options: ContractEventOptions = {},\n        callback?: _CallbackT<IEventResponse[]> | _CallbackT<IEvent[]>,\n    ): void | Promise<IEventResponse[]> | Promise<IEvent[]> {\n        /* eslint-disable prefer-const */\n        let {\n            sinceTimestamp,\n            since,\n            fromTimestamp,\n            eventName,\n            blockNumber,\n            size,\n            page,\n            onlyConfirmed,\n            onlyUnconfirmed,\n            previousLastEventFingerprint,\n            previousFingerprint,\n            fingerprint,\n            rawResponse,\n            sort,\n            filters,\n        } = Object.assign(\n            {\n                sinceTimestamp: 0,\n                eventName: false,\n                blockNumber: false,\n                size: 20,\n                page: 1,\n            },\n            options,\n        ) as ContractEventOptions;\n        /* eslint-enable prefer-const */\n\n        if (!callback)\n            return this.injectPromise(\n                this.getEventsByContractAddress,\n                contractAddress,\n                options,\n            );\n\n        fromTimestamp = fromTimestamp || sinceTimestamp || since;\n\n        if (!this.tronWeb.eventServer)\n            return callback('No event server configured');\n\n        const routeParams: (string | number)[] = [];\n\n        if (!this.tronWeb.isAddress(contractAddress))\n            return callback('Invalid contract address provided');\n\n        if (eventName && !contractAddress)\n            return callback(\n                'Usage of event name filtering requires a contract address',\n            );\n\n        if (\n            typeof fromTimestamp !== 'undefined' &&\n            !utils.isInteger(fromTimestamp)\n        )\n            return callback('Invalid fromTimestamp provided');\n\n        if (!utils.isInteger(size)) return callback('Invalid size provided');\n\n        if (size > 200) {\n            console.warn('Defaulting to maximum accepted size: 200');\n            size = 200;\n        }\n\n        if (!utils.isInteger(page)) return callback('Invalid page provided');\n\n        if (blockNumber && !eventName)\n            return callback(\n                'Usage of block number filtering requires an event name',\n            );\n\n        if (contractAddress)\n            routeParams.push(this.tronWeb.address.fromHex(contractAddress));\n\n        if (eventName) routeParams.push(eventName);\n\n        if (blockNumber) routeParams.push(blockNumber);\n\n        const qs: Record<string, string | number | boolean> = {\n            size,\n            page,\n        };\n\n        if (\n            filters != null &&\n            typeof filters === 'object' &&\n            Object.keys(filters).length > 0\n        )\n            qs.filters = JSON.stringify(filters);\n\n        if (fromTimestamp) qs.fromTimestamp = qs.since = fromTimestamp;\n\n        if (onlyConfirmed) qs.only_confirmed = onlyConfirmed;\n\n        if (onlyUnconfirmed && !onlyConfirmed)\n            qs.only_unconfirmed = onlyUnconfirmed;\n\n        if (sort) qs.sort = sort;\n\n        fingerprint =\n            fingerprint || previousFingerprint || previousLastEventFingerprint;\n        if (fingerprint) qs.fingerprint = fingerprint;\n\n        return this.tronWeb.eventServer\n            .request(\n                `event/contract/${routeParams.join(\n                    '/',\n                )}?${querystring.stringify(qs)}`,\n            )\n            .then((data) => {\n                if (!data) return callback('Unknown error occurred');\n                if (!utils.isArray(data)) return callback(data);\n\n                if (rawResponse) return callback(null, data as any);\n                else\n                    return callback(\n                        null,\n                        data.map((event) => utils.mapEvent(event)) as any,\n                    );\n            })\n            .catch((err: any) =>\n                callback((err.response && err.response.data) || err),\n            ) as unknown as void;\n    }\n\n    getEventsByTransactionID(\n        transactionID: string,\n        options?: {rawResponse: true},\n        callback?: undefined,\n    ): Promise<IEventResponse[]>;\n    getEventsByTransactionID(\n        transactionID: string,\n        options?: {rawResponse?: false},\n        callback?: undefined,\n    ): Promise<IEvent[]>;\n    getEventsByTransactionID(\n        transactionID: string,\n        options: {rawResponse: true},\n        callback: _CallbackT<IEventResponse[]>,\n    ): void;\n    getEventsByTransactionID(\n        transactionID: string,\n        options: {rawResponse?: false},\n        callback: _CallbackT<IEvent[]>,\n    ): void;\n    getEventsByTransactionID(\n        transactionID: string,\n        options: {rawResponse?: boolean} = {},\n        callback?: _CallbackT<IEventResponse[]> | _CallbackT<IEvent[]>,\n    ): void | Promise<IEventResponse[]> | Promise<IEvent[]> {\n        if (!callback || !utils.isFunction(callback))\n            return this.injectPromise(\n                this.getEventsByTransactionID,\n                transactionID,\n                options,\n            );\n\n        if (!this.tronWeb.eventServer)\n            return callback('No event server configured');\n\n        return this.tronWeb.eventServer\n            .request(`event/transaction/${transactionID}`)\n            .then((data) => {\n                if (!callback) return null;\n\n                if (!data) return callback('Unknown error occurred');\n                if (!utils.isArray(data)) return callback(data);\n\n                return callback(\n                    null,\n                    options.rawResponse === true\n                        ? data\n                        : (data.map((event) => utils.mapEvent(event)) as any),\n                );\n            })\n            .catch(\n                (err: any) =>\n                    callback &&\n                    callback((err.response && err.response.data) || err),\n            ) as unknown as void;\n    }\n}\n","import semver from 'semver';\n\nimport TronWeb from '..';\nimport utils from '../utils';\n\nexport interface IPluginRegisterResult {\n    libs: string[];\n    plugged: string[];\n    skipped: string[];\n    error?: string;\n}\nexport interface IPluginDefn {\n    // TODO: it can be better\n    requires?: string;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    components?: Record<string, Record<string, Function>>;\n    fullClass?: boolean;\n}\n\nexport interface IPlugin<T extends Record<string, unknown> | null | unknown> {\n    pluginInterface?: (options?: T) => IPluginDefn;\n}\ntype Class<I, Args extends any[] = any[]> = new (...args: Args) => I;\n\nexport default class Plugin {\n    tronWeb: TronWeb;\n    pluginNoOverride: string[];\n    disablePlugins: string[] | undefined;\n\n    constructor(tronWeb: TronWeb, options: {disablePlugins?: string[]} = {}) {\n        if (!tronWeb || !(tronWeb instanceof TronWeb))\n            throw new Error('Expected instance of TronWeb');\n        this.tronWeb = tronWeb;\n        this.pluginNoOverride = ['register'];\n        this.disablePlugins = options.disablePlugins;\n    }\n\n    register<T>(PluginCls: Class<IPlugin<T>>, options?: T) {\n        let pluginInterface: IPluginDefn = {\n            requires: '0.0.0',\n            components: {},\n        };\n        const result: IPluginRegisterResult = {\n            libs: [],\n            plugged: [],\n            skipped: [],\n        };\n        if (this.disablePlugins) {\n            result.error = 'This instance of TronWeb has plugins disabled.';\n            return result;\n        }\n        const plugin = new PluginCls(this.tronWeb);\n        if (utils.isFunction(plugin.pluginInterface))\n            pluginInterface = plugin.pluginInterface(options);\n\n        if (\n            !pluginInterface.requires ||\n            semver.satisfies(TronWeb.version, pluginInterface.requires)\n        )\n            if (pluginInterface.fullClass) {\n                // plug the entire class at the same level of tronWeb.trx\n                const className = plugin.constructor.name;\n                const classInstanceName =\n                    className.substring(0, 1).toLowerCase() +\n                    className.substring(1);\n                if (className !== classInstanceName) {\n                    TronWeb[className] = PluginCls;\n                    this.tronWeb[classInstanceName] = plugin;\n                    result.libs.push(className);\n                }\n            } else {\n                // plug methods into a class, like trx\n                for (const component in pluginInterface.components) {\n                    if (\n                        !Object.prototype.hasOwnProperty.call(\n                            this.tronWeb,\n                            component,\n                        )\n                    )\n                        continue;\n\n                    const methods = pluginInterface.components[component];\n                    const pluginNoOverride =\n                        this.tronWeb[component].pluginNoOverride || [];\n                    for (const method in methods) {\n                        if (\n                            method === 'constructor' ||\n                            (this.tronWeb[component][method] &&\n                                // blacklisted methods\n                                (pluginNoOverride.includes(method) ||\n                                    // private methods\n                                    /^_/.test(method)))\n                        ) {\n                            result.skipped.push(method);\n                            continue;\n                        }\n                        this.tronWeb[component][method] = methods[method].bind(\n                            this.tronWeb[component],\n                        );\n                        result.plugged.push(method);\n                    }\n                }\n            }\n        else\n            throw new Error(\n                'The plugin is not compatible with this version of TronWeb',\n            );\n\n        return result;\n    }\n}\n","import TronWeb from '..';\nimport utils from '../utils';\n\ninterface IOperatorBase {\n    msg?: string;\n    value?: any;\n    optional?: boolean;\n}\nexport type IUnaryOperator = IOperatorBase &\n    (\n        | {\n              name: string;\n              type:\n                  | 'address'\n                  | 'positive-integer'\n                  | 'tokenId'\n                  | 'notEmptyObject'\n                  | 'resource'\n                  | 'url'\n                  | 'hex'\n                  | 'array'\n                  | 'not-empty-string'\n                  | 'boolean';\n          }\n        | {\n              name: string;\n              type: 'integer' | 'string';\n              gt?: number;\n              lt?: number;\n              gte?: number;\n              lte?: number;\n          }\n    );\nexport type IBinaryOperator = IOperatorBase & {\n    msg: string;\n    type: 'notEqual';\n    names: [string, string];\n};\nexport type IOperator = IUnaryOperator | IBinaryOperator;\n\nfunction compare(\n    value: number,\n    opts: {gt?: number; gte?: number; lt?: number; lte?: number},\n) {\n    const {gt, lt, gte, lte} = opts;\n    return !(\n        (typeof gt === 'number' && value <= gt) ||\n        (typeof lt === 'number' && value >= lt) ||\n        (typeof gte === 'number' && value < gte) ||\n        (typeof lte === 'number' && value > lte)\n    );\n}\n\nexport default class Validator {\n    tronWeb: TronWeb;\n\n    constructor(tronWeb: TronWeb) {\n        if (!tronWeb || !(tronWeb instanceof TronWeb))\n            throw new Error('Expected instance of TronWeb');\n        this.tronWeb = tronWeb;\n    }\n\n    invalid(param: IOperator): string {\n        if (!('name' in param)) return param.msg;\n\n        return (\n            param.msg ||\n            `Invalid ${param.name}${\n                param.type === 'address' ? ' address' : ''\n            } provided`\n        );\n    }\n\n    notPositive(param: IUnaryOperator): string {\n        return `${param.name} must be a positive integer`;\n    }\n\n    notEqual(param: IBinaryOperator): string {\n        return (\n            param.msg ||\n            `${param.names[0]} can not be equal to ${param.names[1]}`\n        );\n    }\n\n    notValid(params: IOperator[] = [], callback = new Function()) {\n        const normalized: {[key: string]: any} = {};\n        let no = false;\n        for (const param of params) {\n            const {value, type, optional} = param;\n            if (\n                optional &&\n                (!utils.isNotNullOrUndefined(value) ||\n                    (type !== 'boolean' && value === false))\n            )\n                continue;\n\n            if ('name' in param) normalized[param.name] = value;\n\n            switch (param.type) {\n                case 'address':\n                    if (!this.tronWeb.isAddress(value)) no = true;\n                    else\n                        normalized[param.name] =\n                            this.tronWeb.address.toHex(value);\n\n                    break;\n\n                case 'integer': {\n                    if (!utils.isInteger(value) || !compare(value, param))\n                        no = true;\n                    break;\n                }\n                case 'positive-integer':\n                    if (!utils.isInteger(value) || value <= 0) {\n                        callback(this.notPositive(param));\n                        return;\n                    }\n                    break;\n\n                case 'tokenId':\n                    if (!utils.isString(value) || !value.length) no = true;\n                    break;\n\n                case 'notEmptyObject':\n                    if (!utils.isObject(value) || !Object.keys(value).length)\n                        no = true;\n                    break;\n\n                case 'notEqual':\n                    if (\n                        normalized[param.names[0]] ===\n                        normalized[param.names[1]]\n                    ) {\n                        callback(this.notEqual(param));\n                        return true;\n                    }\n                    break;\n\n                case 'resource':\n                    if (!['BANDWIDTH', 'ENERGY'].includes(value)) no = true;\n                    break;\n\n                case 'url':\n                    if (!utils.isValidURL(value)) no = true;\n\n                    break;\n\n                case 'hex':\n                    if (!utils.isHex(value)) no = true;\n\n                    break;\n\n                case 'array':\n                    if (!Array.isArray(value)) no = true;\n                    break;\n\n                case 'not-empty-string':\n                    if (!utils.isString(value) || !value.length) no = true;\n                    break;\n\n                case 'boolean':\n                    if (!utils.isBoolean(value)) no = true;\n                    break;\n                case 'string': {\n                    if (!utils.isString(value) || !compare(value.length, param))\n                        no = true;\n                    break;\n                }\n                default: {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    const _exhaustiveCheck: never = param;\n                }\n            }\n            if (no) {\n                callback(this.invalid(param));\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","import BigNumber from 'bignumber.js';\nimport injectpromise from 'injectpromise';\n\nimport TronWeb from '..';\nimport Validator from '../paramValidator';\nimport type _CallbackT from '../utils/typing';\nimport type {IMethodSendOptions} from './contract';\nimport {HttpProvider} from './providers';\nimport type {ITransaction} from './transactionBuilder';\nimport type {ITransactionInfo, MakeSigned} from './trx';\n\n// ! This file shows [almost] proper overloads for\n// - methods accepting callback\n\nexport type IChainOptions = {\n    mainGatewayAddress: string;\n    sideGatewayAddress: string;\n    sideChainId: string;\n} & (\n    | {fullHost: string}\n    | {\n          fullNode: HttpProvider | string;\n          solidityNode: HttpProvider | string;\n          eventServer?: HttpProvider | string;\n      }\n);\n\nconst INVALID_TX_MESSAGE = 'Invalid transaction provided';\n\nexport default class SideChain<T extends TronWeb> {\n    mainchain: T;\n    sidechain: TronWeb;\n    isAddress: TronWeb['isAddress'];\n    utils: TronWeb['utils'];\n    injectPromise: injectpromise;\n    validator: Validator;\n\n    mainGatewayAddress!: string;\n    sideGatewayAddress!: string;\n    chainId!: string;\n\n    constructor(\n        sideOptions: IChainOptions,\n        TronWebCls: typeof TronWeb,\n        mainchain: T,\n        privateKey: string,\n    ) {\n        this.mainchain = mainchain;\n        const {mainGatewayAddress, sideGatewayAddress, sideChainId} =\n            sideOptions;\n        if ('fullHost' in sideOptions)\n            this.sidechain = new TronWebCls(\n                sideOptions.fullHost,\n                sideOptions.fullHost,\n                sideOptions.fullHost,\n                privateKey,\n            );\n        else\n            this.sidechain = new TronWebCls(\n                sideOptions.fullNode,\n                sideOptions.solidityNode,\n                sideOptions.eventServer,\n                privateKey,\n            );\n        this.isAddress = this.mainchain.isAddress;\n        this.utils = this.mainchain.utils;\n        this.setMainGatewayAddress(mainGatewayAddress);\n        this.setSideGatewayAddress(sideGatewayAddress);\n        this.setChainId(sideChainId);\n        this.injectPromise = injectpromise(this);\n        this.validator = new Validator(this.sidechain);\n\n        const self = this;\n        // @ts-ignore\n        this.sidechain.trx.sign = (...args) => {\n            // @ts-ignore\n            return self.sign(...args);\n        };\n        // @ts-ignore\n        this.sidechain.trx.multiSign = (...args) => {\n            // @ts-ignore\n            return self.multiSign(...args);\n        };\n    }\n\n    // TODO: this and two next must be setters\n    setMainGatewayAddress(mainGatewayAddress) {\n        if (!this.isAddress(mainGatewayAddress))\n            throw new Error('Invalid main gateway address provided');\n        this.mainGatewayAddress = mainGatewayAddress;\n    }\n\n    setSideGatewayAddress(sideGatewayAddress) {\n        if (!this.isAddress(sideGatewayAddress))\n            throw new Error('Invalid side gateway address provided');\n        this.sideGatewayAddress = sideGatewayAddress;\n    }\n\n    setChainId(sideChainId) {\n        if (!this.utils.isString(sideChainId) || !sideChainId)\n            throw new Error('Invalid side chainId provided');\n        this.chainId = sideChainId;\n    }\n\n    signTransaction<T extends ITransaction>(\n        priKeyBytes: string | Uint8Array | Buffer | number[],\n        transaction: T,\n    ): MakeSigned<T> {\n        if (typeof priKeyBytes === 'string')\n            priKeyBytes = this.utils.code.hexStr2byteArray(priKeyBytes);\n\n        const chainIdByteArr = this.utils.code.hexStr2byteArray(this.chainId);\n\n        const _byteArr = this.utils.code.hexStr2byteArray(transaction.txID);\n        // We're doing this once only, so performance effect is low\n        const byteArr = new Uint8Array([..._byteArr, ...chainIdByteArr]);\n        const byteArrHash = this.sidechain.utils.ethersUtils.sha256(byteArr);\n\n        // eslint-disable-next-line new-cap\n        const signature = this.utils.crypto.ECKeySign(\n            this.utils.code.hexStr2byteArray(byteArrHash.replace(/^0x/, '')),\n            priKeyBytes,\n        );\n\n        if (Array.isArray(transaction.signature)) {\n            if (!transaction.signature.includes(signature))\n                transaction.signature.push(signature);\n        } else {\n            transaction.signature = [signature];\n        }\n        return transaction as MakeSigned<T>;\n    }\n\n    async multiSign(\n        transaction: ITransaction,\n        privateKey?: string,\n        permissionId?: number,\n        callback?: undefined,\n    ): Promise<MakeSigned<ITransaction>>;\n    async multiSign(\n        transaction: ITransaction,\n        privateKey: string | undefined,\n        permissionId: number | undefined | null,\n        callback?: _CallbackT<MakeSigned<ITransaction>>,\n    ): Promise<void>;\n    async multiSign(\n        transaction: ITransaction,\n        privateKey: string = this.sidechain.defaultPrivateKey,\n        permissionId?: number,\n        callback?: _CallbackT<MakeSigned<ITransaction>>,\n    ): Promise<void | MakeSigned<ITransaction>> {\n        if (!callback)\n            return this.injectPromise(\n                this.multiSign,\n                transaction,\n                privateKey,\n                permissionId,\n            );\n\n        if (\n            !this.utils.isObject(transaction) ||\n            !transaction.raw_data ||\n            !transaction.raw_data.contract\n        )\n            return callback(INVALID_TX_MESSAGE);\n\n        if (\n            !transaction.raw_data.contract[0].Permission_id &&\n            permissionId &&\n            permissionId > 0\n        ) {\n            // set permission id\n            transaction.raw_data.contract[0].Permission_id = permissionId;\n\n            // check if private key insides permission list\n            const address = this.sidechain.address\n                .toHex(this.sidechain.address.fromPrivateKey(privateKey))\n                .toLowerCase();\n            const signWeight = await this.sidechain.trx.getSignWeight(\n                transaction,\n                permissionId,\n            );\n\n            if (signWeight.result.code === 'PERMISSION_ERROR')\n                return callback(signWeight.result.message);\n\n            let foundKey = false;\n            if (signWeight.permission)\n                signWeight.permission.keys.map((key) => {\n                    if (key.address === address) foundKey = true;\n                });\n\n            if (!foundKey)\n                return callback(privateKey + ' has no permission to sign');\n\n            if (\n                signWeight.approved_list &&\n                signWeight.approved_list.indexOf(address) !== -1\n            )\n                return callback(privateKey + ' already sign transaction');\n\n            // reset transaction\n            if (signWeight.transaction && signWeight.transaction.transaction) {\n                transaction = signWeight.transaction.transaction;\n                transaction.raw_data.contract[0].Permission_id = permissionId;\n            } else {\n                return callback(INVALID_TX_MESSAGE);\n            }\n        }\n        // sign\n        try {\n            return callback(\n                null,\n                this.signTransaction(privateKey, transaction),\n            );\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey?: string,\n        useTronHeader?: boolean,\n        multisig?: boolean,\n        callback?: undefined,\n    ): Promise<MakeSigned<T>>;\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey: string,\n        useTronHeader: boolean,\n        multisig: boolean,\n        callback: _CallbackT<MakeSigned<T>>,\n    ): Promise<void>;\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey: string = this.sidechain.defaultPrivateKey,\n        useTronHeader = true,\n        multisig = false,\n        callback?: _CallbackT<MakeSigned<T>>,\n    ): Promise<void | MakeSigned<T>> {\n        if (!callback)\n            return this.injectPromise(\n                this.sign,\n                transaction,\n                privateKey,\n                useTronHeader,\n                multisig,\n            );\n\n        // Message signing\n        if (this.utils.isString(transaction)) {\n            if (!this.utils.isHex(transaction))\n                return callback('Expected hex message input');\n\n            try {\n                const signatureHex = this.sidechain.trx.signString(\n                    transaction,\n                    privateKey,\n                    useTronHeader,\n                );\n                return callback(null, signatureHex as MakeSigned<T>);\n            } catch (ex) {\n                callback(ex);\n            }\n            return;\n        }\n\n        if (!this.utils.isObject(transaction))\n            return callback(INVALID_TX_MESSAGE);\n\n        if (!multisig && (transaction as ITransaction).signature)\n            return callback('Transaction is already signed');\n\n        try {\n            if (!multisig) {\n                const address = this.sidechain.address\n                    .toHex(this.sidechain.address.fromPrivateKey(privateKey))\n                    .toLowerCase();\n                if (\n                    address !==\n                    this.sidechain.address.toHex(\n                        transaction.raw_data.contract[0].parameter.value\n                            .owner_address,\n                    )\n                )\n                    return callback(\n                        'Private key does not match address in transaction',\n                    );\n            }\n            return callback(\n                null,\n                this.signTransaction(privateKey, transaction) as MakeSigned<T>,\n            );\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    /**\n     * deposit asset to sidechain\n     */\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async depositTrx(\n        callValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.depositTrx,\n                callValue,\n                depositFee,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'callValue',\n                        type: 'integer',\n                        value: callValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'depositFee',\n                        type: 'integer',\n                        value: depositFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            callValue: Number(callValue) + Number(depositFee),\n            feeLimit,\n            ...options,\n        };\n        try {\n            const contractInstance = await this.mainchain\n                .contract()\n                .at(this.mainGatewayAddress);\n            const result = await contractInstance\n                .depositTRX()\n                .send(options, privateKey);\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async depositTrc10(\n        tokenId: number,\n        tokenValue: number,\n        depositFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.depositTrc10,\n                tokenId,\n                tokenValue,\n                depositFee,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'tokenValue',\n                        type: 'integer',\n                        value: tokenValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'depositFee',\n                        type: 'integer',\n                        value: depositFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                    {\n                        name: 'tokenId',\n                        type: 'integer',\n                        value: tokenId,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            tokenId,\n            tokenValue,\n            feeLimit,\n            ...options,\n            callValue: depositFee,\n        };\n        try {\n            const contractInstance = await this.mainchain\n                .contract()\n                .at(this.mainGatewayAddress);\n            const result = await contractInstance\n                .depositTRC10(tokenId, tokenValue)\n                .send(options, privateKey);\n            callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async depositTrc(\n        functionSelector: string,\n        num: number,\n        fee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.depositTrc,\n                functionSelector,\n                num,\n                fee,\n                feeLimit,\n                contractAddress,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'functionSelector',\n                        type: 'not-empty-string',\n                        value: functionSelector,\n                    },\n                    {\n                        name: 'num',\n                        type: 'integer',\n                        value: num,\n                        gte: 0,\n                    },\n                    {\n                        name: 'fee',\n                        type: 'integer',\n                        value: fee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                    {\n                        name: 'contractAddress',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            feeLimit,\n            ...options,\n            callValue: fee,\n            tokenId: '',\n            tokenValue: 0,\n        };\n        try {\n            let result = null;\n            if (functionSelector === 'approve') {\n                const approveInstance = await this.mainchain\n                    .contract()\n                    .at(contractAddress);\n                result = await approveInstance\n                    .approve(this.mainGatewayAddress, num)\n                    .send(options, privateKey);\n            } else {\n                const contractInstance = await this.mainchain\n                    .contract()\n                    .at(this.mainGatewayAddress);\n                switch (functionSelector) {\n                    case 'depositTRC20':\n                    case 'depositTRC721':\n                        result = await contractInstance[functionSelector](\n                            contractAddress,\n                            num,\n                        ).send(options, privateKey);\n                        break;\n                    case 'retryDeposit':\n                    case 'retryMapping':\n                        result = await contractInstance[functionSelector](\n                            num,\n                        ).send(options, privateKey);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async approveTrc20(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'approve';\n        return this.depositTrc(\n            functionSelector,\n            num,\n            0,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async approveTrc721(\n        num: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async approveTrc721(\n        id: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'approve';\n        return this.depositTrc(\n            functionSelector,\n            id,\n            0,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async depositTrc20(\n        num: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'depositTRC20';\n        return this.depositTrc(\n            functionSelector,\n            num,\n            depositFee,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    depositTrc721: this['depositTrc20'] = async (\n        id: number,\n        depositFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> => {\n        const functionSelector = 'depositTRC721';\n        return this.depositTrc(\n            functionSelector,\n            id,\n            depositFee,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    };\n\n    /**\n     * mapping asset TRC20 or TRC721 to DAppChain\n     */\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async mappingTrc(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        functionSelector: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.mappingTrc,\n                trxHash,\n                mappingFee,\n                feeLimit,\n                functionSelector,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'trxHash',\n                        type: 'not-empty-string',\n                        value: trxHash,\n                    },\n                    {\n                        name: 'mappingFee',\n                        type: 'integer',\n                        value: mappingFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        trxHash = trxHash.startsWith('0x') ? trxHash : '0x' + trxHash;\n        options = {\n            feeLimit,\n            ...options,\n            callValue: mappingFee,\n        };\n        try {\n            const contractInstance = await this.mainchain\n                .contract()\n                .at(this.mainGatewayAddress);\n            let result = null;\n            if (functionSelector === 'mappingTRC20')\n                result = await contractInstance\n                    .mappingTRC20(trxHash)\n                    .send(options, privateKey);\n            else if (functionSelector === 'mappingTRC721')\n                result = await contractInstance\n                    .mappingTRC721(trxHash)\n                    .send(options, privateKey);\n            else callback(new Error('type must be trc20 or trc721'));\n\n            callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async mappingTrc20(\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'mappingTRC20';\n        return this.mappingTrc(\n            trxHash,\n            mappingFee,\n            feeLimit,\n            functionSelector,\n            options,\n            privateKey,\n            callback,\n        );\n    }\n\n    mappingTrc721: this['mappingTrc20'] = async (\n        trxHash: string,\n        mappingFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> => {\n        const functionSelector = 'mappingTRC721';\n        return this.mappingTrc(\n            trxHash,\n            mappingFee,\n            feeLimit,\n            functionSelector,\n            options,\n            privateKey,\n            callback,\n        );\n    };\n\n    /**\n     * withdraw trx from sidechain to mainchain\n     */\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrx(\n        callValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawTrx,\n                callValue,\n                withdrawFee,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'callValue',\n                        type: 'integer',\n                        value: callValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'withdrawFee',\n                        type: 'integer',\n                        value: withdrawFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            callValue: Number(callValue) + Number(withdrawFee),\n            feeLimit,\n            ...options,\n        };\n        try {\n            const contractInstance = await this.sidechain\n                .contract()\n                .at(this.sideGatewayAddress);\n            const result = await contractInstance\n                .withdrawTRX()\n                .send(options, privateKey);\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrc10(\n        tokenId: number,\n        tokenValue: number,\n        withdrawFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawTrc10,\n                tokenId,\n                tokenValue,\n                withdrawFee,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'tokenId',\n                        type: 'integer',\n                        value: tokenId,\n                        gte: 0,\n                    },\n                    {\n                        name: 'tokenValue',\n                        type: 'integer',\n                        value: tokenValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'withdrawFee',\n                        type: 'integer',\n                        value: withdrawFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            tokenValue,\n            tokenId,\n            callValue: withdrawFee,\n            feeLimit,\n            ...options,\n        };\n        try {\n            const contractInstance = await this.sidechain\n                .contract()\n                .at(this.sideGatewayAddress);\n            const result = await contractInstance\n                .withdrawTRC10(tokenId, tokenValue)\n                .send(options, privateKey);\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrc(\n        functionSelector: string,\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawTrc,\n                functionSelector,\n                numOrId,\n                withdrawFee,\n                feeLimit,\n                contractAddress,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'functionSelector',\n                        type: 'not-empty-string',\n                        value: functionSelector,\n                    },\n                    {\n                        name: 'numOrId',\n                        type: 'integer',\n                        value: numOrId,\n                        gte: 0,\n                    },\n                    {\n                        name: 'withdrawFee',\n                        type: 'integer',\n                        value: withdrawFee,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                    {\n                        name: 'contractAddress',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        options = {\n            feeLimit,\n            ...options,\n            callValue: withdrawFee,\n        };\n\n        const contract = this.sidechain.contract(\n            [\n                {\n                    name: functionSelector.split('(')[0],\n                    type: 'function',\n                    stateMutability: 'nonpayable',\n                    inputs: [{type: 'uint256', name: ''}],\n                    outputs: [],\n                },\n            ],\n            contractAddress,\n        );\n        const method = contract.methods[functionSelector];\n        return (await method(numOrId).send(\n            options,\n            privateKey,\n            callback,\n        )) as void;\n    }\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrc20(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrc20(\n        num: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        return this.withdrawTrc(\n            'withdrawal(uint256)',\n            num,\n            withdrawFee,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async withdrawTrc721(\n        numOrId: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async withdrawTrc721(\n        id: number,\n        withdrawFee: number,\n        feeLimit: number,\n        contractAddress: string,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        return this.withdrawTrc(\n            'withdrawal(uint256)',\n            id,\n            withdrawFee,\n            feeLimit,\n            contractAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    async injectFund(\n        num: number,\n        feeLimit: number,\n        options?: unknown,\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async injectFund(\n        num: number,\n        feeLimit: number,\n        options: unknown,\n        privateKey: string,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n    async injectFund(\n        num: number,\n        feeLimit: number,\n        options: unknown = 'UNUSED (LEGACY?) ARGUMENT',\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<string>,\n    ): Promise<void | string> {\n        if (!callback)\n            return this.injectPromise(\n                this.injectFund,\n                num,\n                feeLimit,\n                options,\n                privateKey,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'num',\n                        type: 'integer',\n                        value: num,\n                        gte: 0,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        try {\n            const address = this.sidechain.address.fromPrivateKey(privateKey);\n            const hexAddress = this.sidechain.address.toHex(address);\n            const transaction = await this.sidechain.fullNode.request(\n                '/wallet/fundinject',\n                {\n                    owner_address: hexAddress,\n                    amount: num,\n                },\n                'post',\n            );\n\n            const signedTransaction = await this.sidechain.trx.sign(\n                transaction,\n                privateKey,\n            );\n\n            if (!signedTransaction.signature) {\n                if (!privateKey)\n                    return callback('Transaction was not signed properly');\n\n                return callback('Invalid private key provided');\n            }\n\n            const broadcast = await this.sidechain.trx.sendRawTransaction(\n                signedTransaction,\n            );\n            if (broadcast.code) {\n                const err = {\n                    error: broadcast.code,\n                    message: broadcast.code,\n                };\n                if (broadcast.message)\n                    err.message = this.mainchain.toUtf8(broadcast.message);\n                return callback(err);\n            }\n            return callback(null, signedTransaction.txID);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions & {shouldPollResponse?: false},\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<string>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: undefined | (IMethodSendOptions & {shouldPollResponse: false}),\n        privateKey: string | undefined,\n        callback: _CallbackT<string>,\n    ): Promise<void>;\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<ITransactionInfo>,\n    ): Promise<void>;\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<[string, BigNumber]>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID: true;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<[string, BigNumber]>,\n    ): Promise<void>;\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey?: string,\n        callback?: undefined,\n    ): Promise<BigNumber>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions & {\n            shouldPollResponse: true;\n            rawResponse?: false;\n            keepTxID?: false;\n        },\n        privateKey: string | undefined,\n        callback: _CallbackT<BigNumber>,\n    ): Promise<void>;\n\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options?: IMethodSendOptions,\n        privateKey?: string,\n        callback?: _CallbackT<BigNumber>,\n    ): Promise<BigNumber>;\n    async retryWithdraw(\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> {\n        const functionSelector = 'retryWithdraw(uint256)';\n        return this.withdrawTrc(\n            functionSelector,\n            nonce,\n            retryFee,\n            feeLimit,\n            this.sideGatewayAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    }\n\n    retryDeposit: this['retryWithdraw'] = async (\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> => {\n        const functionSelector = 'retryDeposit';\n        return this.depositTrc(\n            functionSelector,\n            nonce,\n            retryFee,\n            feeLimit,\n            this.mainGatewayAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    };\n\n    retryMapping: this['retryWithdraw'] = async (\n        nonce: number,\n        retryFee: number,\n        feeLimit: number,\n        options: IMethodSendOptions = {},\n        privateKey: string = this.mainchain.defaultPrivateKey,\n        callback?: _CallbackT<any>,\n    ): Promise<void | any> => {\n        const functionSelector = 'retryMapping';\n        return this.depositTrc(\n            functionSelector,\n            nonce,\n            retryFee,\n            feeLimit,\n            this.mainGatewayAddress,\n            options,\n            privateKey,\n            callback as any,\n        );\n    };\n}\n","const google_protobuf_any_pb = require('@tronweb3/google-protobuf/google/protobuf/any_pb');\n\nconst { Transaction, Permission, Key } = require('../proto/core/Tron');\n\nconst {\n    TransferContract,\n    FreezeBalanceContract,\n    UnfreezeBalanceContract,\n    WithdrawBalanceContract,\n    FreezeBalanceV2Contract,\n    UnfreezeBalanceV2Contract,\n    WithdrawExpireUnfreezeContract,\n    DelegateResourceContract,\n    UnDelegateResourceContract,\n} = require('../proto/core/contract/balance_contract');\nconst {\n    TransferAssetContract,\n    ParticipateAssetIssueContract,\n    AssetIssueContract,\n    UpdateAssetContract\n} = require('../proto/core/contract/asset_issue_contract');\n\nconst {\n    TriggerSmartContract,\n    ClearABIContract,\n    UpdateEnergyLimitContract,\n    UpdateSettingContract,\n    CreateSmartContract,\n    SmartContract,\n} = require('../proto/core/contract/smart_contract');\n\nconst { ResourceCode } = require('../proto/core/contract/common');\n\nconst {\n    WitnessCreateContract,\n    VoteWitnessContract,\n} = require('../proto/core/contract/witness_contract');\n\nconst {\n    UpdateBrokerageContract,\n} = require('../proto/core/contract/storage_contract');\n\nconst {\n    AccountCreateContract,\n    AccountUpdateContract,\n    SetAccountIdContract,\n    AccountPermissionUpdateContract,\n} = require('../proto/core/contract/account_contract');\n\nconst {\n    ProposalCreateContract,\n    ProposalDeleteContract,\n    ProposalApproveContract,\n} = require('../proto/core/contract/proposal_contract');\n\nconst {\n    ExchangeCreateContract,\n    ExchangeInjectContract,\n    ExchangeWithdrawContract,\n    ExchangeTransactionContract,\n} = require('../proto/core/contract/exchange_contract');\n\nimport { byteArray2hexStr } from './bytes';\nimport { sha256, keccak256 } from './ethersUtils';\nimport TronWeb from '../index';\n\nconst fromHexString = (hexString) => {\n    if (!hexString || hexString.length === 0) return new Uint8Array([]);\n    return new Uint8Array(\n        // @ts-ignore\n        TronWeb.address.toHex(hexString).match(/.{1,2}/g).map((byte) => parseInt(byte, 16))\n    );\n};\n\n\nconst sha3 = (string, prefix = true) => {\n    return (\n        (prefix ? '0x' : '') +\n        keccak256(Buffer.from(string, 'utf-8')).toString().substring(2)\n    );\n};\n\nconst buildCommonTransaction = (\n    message,\n    contractType,\n    typeName,\n    permissionId\n) => {\n    let anyValue = new google_protobuf_any_pb.Any();\n    anyValue.pack(message.serializeBinary(), 'protocol.' + typeName);\n    let contract = new Transaction.Contract();\n    contract.setType(contractType);\n    contract.setParameter(anyValue);\n    if (permissionId) {\n        contract.setPermissionId(permissionId);\n    }\n    let raw = new Transaction.raw();\n    raw.addContract(contract);\n    let transaction = new Transaction();\n    transaction.setRawData(raw);\n    return transaction;\n};\n\n// wallet/createtransaction for sendTrx\nconst buildTransferContract = (value, options) => {\n    const { to_address, owner_address, amount } = value;\n    let transferContract = new TransferContract();\n    transferContract.setToAddress(fromHexString(to_address));\n    transferContract.setOwnerAddress(fromHexString(owner_address));\n    transferContract.setAmount(amount);\n    return buildCommonTransaction(\n        transferContract,\n        Transaction.Contract.ContractType.TRANSFERCONTRACT,\n        'TransferContract',\n        options.Permission_id\n    );\n};\n\n// wallet/transferasset for sendToken\nconst buildTransferAssetContract = (value, options) => {\n    const { to_address, owner_address, amount, asset_name } = value;\n    let transferContract = new TransferAssetContract();\n    transferContract.setToAddress(fromHexString(to_address));\n    transferContract.setOwnerAddress(fromHexString(owner_address));\n    transferContract.setAssetName(fromHexString(asset_name.replace(/^0x/, '')));\n    transferContract.setAmount(amount);\n    return buildCommonTransaction(\n        transferContract,\n        Transaction.Contract.ContractType.TRANSFERASSETCONTRACT,\n        'TransferAssetContract',\n        options.Permission_id\n    );\n};\n\n// wallet/participateassetissue for purchaseToken\nconst buildParticipateAssetIssueContract = (value, options) => {\n    let pbObj = new ParticipateAssetIssueContract();\n    pbObj.setToAddress(fromHexString(value.to_address));\n    pbObj.setOwnerAddress(fromHexString(value.owner_address));\n    pbObj.setAssetName(fromHexString(value.asset_name.replace(/^0x/, '')));\n    pbObj.setAmount(value.amount);\n\n    return buildCommonTransaction(\n        pbObj,\n        Transaction.Contract.ContractType.PARTICIPATEASSETISSUECONTRACT,\n        'ParticipateAssetIssueContract',\n        options.Permission_id\n    );\n};\n\nconst buildTriggerSmartContract = (value, options) => {\n    let triggerSmartContract = new TriggerSmartContract();\n    const {\n        owner_address,\n        contract_address,\n        parameter = '',\n        function_selector,\n        call_value,\n        call_token_value,\n        token_id,\n        data,\n    } = value;\n    triggerSmartContract.setOwnerAddress(fromHexString(owner_address));\n    triggerSmartContract.setContractAddress(fromHexString(contract_address));\n    triggerSmartContract.setCallValue(call_value);\n    if (data) {\n        triggerSmartContract.setData(fromHexString(data));\n    } else if (function_selector) {\n        const contractData = sha3(function_selector).substring(2, 10) + parameter;\n        triggerSmartContract.setData(fromHexString(contractData));\n    }\n\n    if (token_id) {\n        triggerSmartContract.setTokenId(token_id);\n    }\n    if (call_token_value) {\n        triggerSmartContract.setCallTokenValue(call_token_value);\n    }\n\n    return buildCommonTransaction(\n        triggerSmartContract,\n        Transaction.Contract.ContractType.TRIGGERSMARTCONTRACT,\n        'TriggerSmartContract',\n        options.Permission_id\n    );\n};\n\nconst buildFreezeBalanceContract = (value, options) => {\n    let freezeBalanceContract = new FreezeBalanceContract();\n    const {\n        owner_address,\n        frozen_balance,\n        frozen_duration,\n        resource,\n        receiver_address,\n    } = value;\n    freezeBalanceContract.setOwnerAddress(fromHexString(owner_address));\n    freezeBalanceContract.setFrozenBalance(frozen_balance);\n    freezeBalanceContract.setFrozenDuration(frozen_duration);\n    if (resource) {\n        freezeBalanceContract.setResource(ResourceCode[resource]);\n    }\n    if (receiver_address) {\n        freezeBalanceContract.setReceiverAddress(\n            fromHexString(receiver_address)\n        );\n    }\n\n    return buildCommonTransaction(\n        freezeBalanceContract,\n        Transaction.Contract.ContractType.FREEZEBALANCECONTRACT,\n        'FreezeBalanceContract',\n        options.Permission_id\n    );\n};\n\nconst buildUnfreezeBalanceContract = (value, options) => {\n    let unfreezeBalanceContract = new UnfreezeBalanceContract();\n    const { owner_address, resource, receiver_address } = value;\n    unfreezeBalanceContract.setOwnerAddress(fromHexString(owner_address));\n    if (resource) {\n        unfreezeBalanceContract.setResource(ResourceCode[resource]);\n    }\n    if (receiver_address) {\n        unfreezeBalanceContract.setReceiverAddress(\n            fromHexString(receiver_address)\n        );\n    }\n\n    return buildCommonTransaction(\n        unfreezeBalanceContract,\n        Transaction.Contract.ContractType.UNFREEZEBALANCECONTRACT,\n        'UnfreezeBalanceContract',\n        options.Permission_id\n    );\n};\n\nconst buildWithdrawBalanceContract = (value, options) => {\n    let withdrawbalanceContract = new WithdrawBalanceContract();\n    const { owner_address } = value;\n    withdrawbalanceContract.setOwnerAddress(fromHexString(owner_address));\n\n    return buildCommonTransaction(\n        withdrawbalanceContract,\n        Transaction.Contract.ContractType.WITHDRAWBALANCECONTRACT,\n        'WithdrawBalanceContract',\n        options.Permission_id\n    );\n};\n\nconst buildFreezeBalanceV2Contract = (value, options) => {\n    const freezeBalanceV2Contract = new FreezeBalanceV2Contract();\n    const {\n        owner_address,\n        frozen_balance,\n        resource,\n    } = value;\n    freezeBalanceV2Contract.setOwnerAddress(fromHexString(owner_address));\n    freezeBalanceV2Contract.setFrozenBalance(frozen_balance);\n    freezeBalanceV2Contract.setResource(ResourceCode[resource]);\n\n    return buildCommonTransaction(\n        freezeBalanceV2Contract,\n        Transaction.Contract.ContractType.FREEZEBALANCEV2CONTRACT,\n        'FreezeBalanceV2Contract',\n        options.Permission_id,\n    );\n};\n\nconst buildCancelFreezeBalanceV2Contract = (value, options) => {\n    const withdrawExpireUnfreeze = new WithdrawExpireUnfreezeContract();\n    const { owner_address } = value;\n    withdrawExpireUnfreeze.setOwnerAddress(fromHexString(owner_address));\n\n    return buildCommonTransaction(\n        withdrawExpireUnfreeze,\n        Transaction.Contract.ContractType.CANCELALLUNFREEZEV2CONTRACT,\n        'CancelAllUnfreezeV2Contract',\n        options.Permission_id,\n    );\n};\n\nconst buildUnfreezeBalanceV2Contract = (value, options) => {\n    const unfreezeBalanceV2Contract = new UnfreezeBalanceV2Contract();\n    const {\n        owner_address,\n        unfreeze_balance,\n        resource,\n    } = value;\n    unfreezeBalanceV2Contract.setOwnerAddress(fromHexString(owner_address));\n    unfreezeBalanceV2Contract.setUnfreezeBalance(unfreeze_balance);\n    unfreezeBalanceV2Contract.setResource(ResourceCode[resource]);\n\n    return buildCommonTransaction(\n        unfreezeBalanceV2Contract,\n        Transaction.Contract.ContractType.UNFREEZEBALANCEV2CONTRACT,\n        'UnfreezeBalanceV2Contract',\n        options.Permission_id,\n    );\n};\n\nconst buildDelegateResourceContract = (value, options) => {\n    const delegateResourceContract = new DelegateResourceContract();\n    const {\n        owner_address,\n        receiver_address,\n        balance,\n        resource,\n        lock = false,\n        lock_period,\n    } = value;\n    delegateResourceContract.setOwnerAddress(fromHexString(owner_address));\n    delegateResourceContract.setBalance(balance);\n    delegateResourceContract.setResource(ResourceCode[resource]);\n    delegateResourceContract.setLock(lock);\n    delegateResourceContract.setLockPeriod(lock_period);\n    delegateResourceContract.setReceiverAddress(fromHexString(receiver_address));\n\n    return buildCommonTransaction(\n        delegateResourceContract,\n        Transaction.Contract.ContractType.DELEGATERESOURCECONTRACT,\n        'DelegateResourceContract',\n        options.Permission_id,\n    );\n};\n\nconst buildUnDelegateResourceContract = (value, options) => {\n    const unDelegateResourceContract = new UnDelegateResourceContract();\n    const {\n        owner_address,\n        receiver_address,\n        balance,\n        resource,\n    } = value;\n    unDelegateResourceContract.setOwnerAddress(fromHexString(owner_address));\n    unDelegateResourceContract.setBalance(balance);\n    unDelegateResourceContract.setResource(ResourceCode[resource]);\n    unDelegateResourceContract.setReceiverAddress(fromHexString(receiver_address));\n\n    return buildCommonTransaction(\n        unDelegateResourceContract,\n        Transaction.Contract.ContractType.UNDELEGATERESOURCECONTRACT,\n        'UnDelegateResourceContract',\n        options.Permission_id,\n    );\n};\n\nconst buildWithdrawExpireUnfreezeContract = (value, options) => {\n    const withdrawExpireUnfreeze = new WithdrawExpireUnfreezeContract();\n    const { owner_address } = value;\n    withdrawExpireUnfreeze.setOwnerAddress(fromHexString(owner_address));\n\n    return buildCommonTransaction(\n        withdrawExpireUnfreeze,\n        Transaction.Contract.ContractType.WITHDRAWEXPIREUNFREEZECONTRACT,\n        'WithdrawExpireUnfreezeContract',\n        options.Permission_id,\n    );\n};\n\n// applyForSR\nconst buildCreateWitness = (value, options) => {\n    const createWitnessContract = new WitnessCreateContract();\n    const { owner_address, url } = value;\n    createWitnessContract.setOwnerAddress(fromHexString(owner_address));\n    createWitnessContract.setUrl(fromHexString(url.replace(/^0x/, '')));\n    return buildCommonTransaction(\n        createWitnessContract,\n        Transaction.Contract.ContractType.WITNESSCREATECONTRACT,\n        'WitnessCreateContract',\n        options.Permission_id\n    );\n};\n\n// vote\nconst buildVoteWitnessAccount = (value, options) => {\n    let voteWitnessContract = new VoteWitnessContract();\n    const { owner_address, votes } = value;\n    voteWitnessContract.setOwnerAddress(fromHexString(owner_address));\n\n    votes.forEach((voteItem) => {\n        let vote = new VoteWitnessContract.Vote();\n        const { vote_address, vote_count } = voteItem;\n        vote.setVoteAddress(fromHexString(vote_address));\n        let numberOfVotes = parseInt(vote_count);\n        vote.setVoteCount(numberOfVotes);\n        voteWitnessContract.addVotes(vote);\n    });\n\n    return buildCommonTransaction(\n        voteWitnessContract,\n        Transaction.Contract.ContractType.VOTEWITNESSCONTRACT,\n        'VoteWitnessContract',\n        options.Permission_id\n    );\n};\n\nconst buildCreateSmartContract = (value, options) => {\n    let params = value?.new_contract ?\n        {\n            ...{\n                owner_address: value.owner_address,\n                call_token_value: value.call_token_value,\n                token_id: value.token_id,\n            },\n            ...value.new_contract,\n        }\n        : value;\n    let {\n        owner_address,\n        consume_user_resource_percent,\n        origin_energy_limit,\n        abi,\n        bytecode = '',\n        name: contracName,\n        parameter = '',\n        call_value,\n        call_token_value,\n        token_id,\n        origin_address,\n    } = params;\n\n    let createSmartContract = new CreateSmartContract();\n    createSmartContract.setOwnerAddress(fromHexString(owner_address));\n    if (token_id) {\n        createSmartContract.setTokenId(token_id);\n    }\n    if (call_token_value) {\n        createSmartContract.setCallTokenValue(call_token_value);\n    }\n    const smartContractBuilder = new SmartContract();\n\n    if (abi) {\n        let abiJson;\n        if (typeof abi === 'string') {\n            abiJson = JSON.parse(abi);\n        } else {\n            abiJson = abi?.entrys || []; // abi could be an empty object if origin abi is `[]`;\n        }\n        const abiBuilder = new SmartContract.ABI();\n\n        const buildEntryParam = (data) => {\n            const param = new SmartContract.ABI.Entry.Param();\n            const { indexed, name, type } = data;\n            if (indexed === true) {\n                param.setIndexed(true);\n            }\n            param.setName(name);\n            param.setType(type);\n            return param;\n        };\n        const entryBuilders = abiJson.map((entry) => {\n            const {\n                anonymous,\n                constant,\n                name,\n                inputs,\n                outputs,\n                type,\n                payable,\n                stateMutability,\n            } = entry;\n            const entryBuilder = new SmartContract.ABI.Entry();\n            entryBuilder.setAnonymous(anonymous);\n            entryBuilder.setConstant(constant);\n            entryBuilder.setName(name);\n            if (inputs) {\n                entryBuilder.setInputsList(\n                    inputs.map((input) => buildEntryParam(input))\n                );\n            }\n            if (outputs) {\n                entryBuilder.setOutputsList(\n                    outputs.map((output) => buildEntryParam(output))\n                );\n            }\n            if (type) {\n                entryBuilder.setType(\n                    SmartContract.ABI.Entry.EntryType[type.toUpperCase()]\n                );\n            }\n\n            entryBuilder.setPayable(payable);\n            if(stateMutability) {\n                entryBuilder.setStatemutability(\n                    SmartContract.ABI.Entry.StateMutabilityType[\n                        stateMutability.toUpperCase()\n                    ]\n                );\n            }\n\n            return entryBuilder;\n        });\n        abiBuilder.setEntrysList(entryBuilders);\n        smartContractBuilder.setAbi(abiBuilder);\n    }\n\n\n    if (call_value) {\n        smartContractBuilder.setCallValue(call_value);\n    }\n\n    smartContractBuilder.setConsumeUserResourcePercent(\n        consume_user_resource_percent\n    );\n    smartContractBuilder.setOriginEnergyLimit(origin_energy_limit);\n\n    if (!origin_address) {\n        origin_address = owner_address;\n    }\n    smartContractBuilder.setOriginAddress(fromHexString(origin_address));\n\n    if (bytecode) {\n        const bytecodeParameter = bytecode.replace(/^0x/, '') + parameter.replace(/^0x/, '');\n        smartContractBuilder.setBytecode(fromHexString(bytecodeParameter));\n    }\n\n    smartContractBuilder.setName(contracName);\n\n    createSmartContract.setNewContract(smartContractBuilder);\n\n    return buildCommonTransaction(\n        createSmartContract,\n        Transaction.Contract.ContractType.CREATESMARTCONTRACT,\n        'CreateSmartContract',\n        options.Permission_id\n    );\n};\n\nconst buildClearABIContract = (value, options) => {\n    const { contract_address, owner_address } = value;\n    const clearABIContract = new ClearABIContract();\n    clearABIContract.setOwnerAddress(fromHexString(owner_address));\n    clearABIContract.setContractAddress(fromHexString(contract_address));\n\n    return buildCommonTransaction(\n        clearABIContract,\n        Transaction.Contract.ContractType.CLEARABICONTRACT,\n        'ClearABIContract',\n        options.Permission_id\n    );\n};\n\n// updateBrokerage\nconst buildUpdateBrokerageContract = (value, options) => {\n    const { brokerage, owner_address } = value;\n    const updateBrokerageContract = new UpdateBrokerageContract();\n    updateBrokerageContract.setOwnerAddress(fromHexString(owner_address));\n    updateBrokerageContract.setBrokerage(brokerage);\n\n    return buildCommonTransaction(\n        updateBrokerageContract,\n        Transaction.Contract.ContractType.UPDATEBROKERAGECONTRACT,\n        'UpdateBrokerageContract',\n        options.Permission_id\n    );\n};\n\n// createToken\nconst buildAssetIssueContract = (value, options) => {\n    const {\n        owner_address,\n        name,\n        abbr,\n        description,\n        url,\n        total_supply,\n        trx_num,\n        num,\n        start_time,\n        end_time,\n        precision,\n        free_asset_net_limit,\n        public_free_asset_net_limit,\n        public_free_asset_net_usage = 0,\n        public_latest_free_net_time = 0,\n        vote_score = 0,\n        frozen_supply,\n    } = value;\n    let assetIssueContract = new AssetIssueContract();\n    assetIssueContract.setOwnerAddress(fromHexString(owner_address));\n    if (name) {\n        assetIssueContract.setName(fromHexString(name.replace(/^0x/, '')));\n    }\n    if (abbr) {\n        assetIssueContract.setAbbr(fromHexString(abbr.replace(/^0x/, '')));\n    }\n    assetIssueContract.setTotalSupply(total_supply);\n    assetIssueContract.setNum(num);\n    assetIssueContract.setEndTime(end_time);\n    assetIssueContract.setStartTime(start_time);\n    assetIssueContract.setTrxNum(trx_num);\n    assetIssueContract.setVoteScore(vote_score);\n    if (precision) {\n        assetIssueContract.setPrecision(precision);\n    }\n    if (public_latest_free_net_time) {\n        assetIssueContract.setPublicLatestFreeNetTime(\n            public_latest_free_net_time\n        );\n    }\n    if (description) {\n        assetIssueContract.setDescription(\n            fromHexString(description.replace(/^0x/, ''))\n        );\n    }\n    if (url) {\n        assetIssueContract.setUrl(fromHexString(url.replace(/^0x/, '')));\n    }\n\n    assetIssueContract.setPublicFreeAssetNetUsage(public_free_asset_net_usage);\n    assetIssueContract.setFreeAssetNetLimit(free_asset_net_limit);\n    assetIssueContract.setPublicFreeAssetNetLimit(public_free_asset_net_limit);\n    if (frozen_supply) {\n        let frozenSupplyContract = new AssetIssueContract.FrozenSupply();\n        frozenSupplyContract.setFrozenAmount(frozen_supply.length ? frozen_supply[0].frozen_amount : frozen_supply.frozen_amount);\n        frozenSupplyContract.setFrozenDays(frozen_supply.length ? frozen_supply[0].frozen_days : frozen_supply.frozen_days);\n        assetIssueContract.addFrozenSupply(frozenSupplyContract);\n    }\n    return buildCommonTransaction(\n        assetIssueContract,\n        Transaction.Contract.ContractType.ASSETISSUECONTRACT,\n        'AssetIssueContract',\n        options.Permission_id\n    );\n};\n\n//createAccount\nconst buildAccountCreateContract = (value, options) => {\n    let accountCreateContract = new AccountCreateContract();\n    const { account_address, owner_address } = value;\n    accountCreateContract.setOwnerAddress(fromHexString(owner_address));\n    accountCreateContract.setAccountAddress(\n        fromHexString(account_address.replace(/^0x/, ''))\n    );\n    return buildCommonTransaction(\n        accountCreateContract,\n        Transaction.Contract.ContractType.ACCOUNTCREATECONTRACT,\n        'AccountCreateContract',\n        options.Permission_id\n    );\n}\n\n// updateAccount\nconst buildAccountUpdateContract = (value, options) => {\n    let accountUpdateContract = new AccountUpdateContract();\n    const { account_name, owner_address } = value;\n    accountUpdateContract.setOwnerAddress(fromHexString(owner_address));\n    accountUpdateContract.setAccountName(\n        fromHexString(account_name.replace(/^0x/, ''))\n    );\n    return buildCommonTransaction(\n        accountUpdateContract,\n        Transaction.Contract.ContractType.ACCOUNTUPDATECONTRACT,\n        'AccountUpdateContract',\n        options.Permission_id\n    );\n};\n\n// setAccountId\nconst buildSetAccountIdContract = (value, options) => {\n    let setAccountIdContract = new SetAccountIdContract();\n    const { account_id, owner_address } = value;\n    setAccountIdContract.setOwnerAddress(fromHexString(owner_address));\n    setAccountIdContract.setAccountId(\n        fromHexString(account_id.replace(/^0x/, ''))\n    );\n    return buildCommonTransaction(\n        setAccountIdContract,\n        Transaction.Contract.ContractType.SETACCOUNTIDCONTRACT,\n        'SetAccountIdContract',\n        options.Permission_id\n    );\n};\n\nconst buildProposalCreateContract = (value, options) => {\n    let proposalCreateContract = new ProposalCreateContract();\n    const { owner_address, parameters } = value;\n    proposalCreateContract.setOwnerAddress(fromHexString(owner_address));\n    parameters.forEach((parameter) => {\n        proposalCreateContract\n            .getParametersMap()\n            .set(parameter.key, parameter.value);\n    });\n    return buildCommonTransaction(\n        proposalCreateContract,\n        Transaction.Contract.ContractType.PROPOSALCREATECONTRACT,\n        'ProposalCreateContract',\n        options.Permission_id\n    );\n};\n\nconst buildProposalDeleteContract = (value, options) => {\n    let proposalDeleteContract = new ProposalDeleteContract();\n    const { owner_address, proposal_id } = value;\n    proposalDeleteContract.setOwnerAddress(fromHexString(owner_address));\n    proposalDeleteContract.setProposalId(proposal_id);\n    return buildCommonTransaction(\n        proposalDeleteContract,\n        Transaction.Contract.ContractType.PROPOSALDELETECONTRACT,\n        'ProposalDeleteContract',\n        options.Permission_id\n    );\n};\n\nconst buildVoteProposalContract = (value, options) => {\n    let proposalVoteContract = new ProposalApproveContract();\n    const { owner_address, proposal_id, is_add_approval } = value;\n    proposalVoteContract.setOwnerAddress(fromHexString(owner_address));\n    proposalVoteContract.setProposalId(proposal_id);\n    proposalVoteContract.setIsAddApproval(is_add_approval);\n    return buildCommonTransaction(\n        proposalVoteContract,\n        Transaction.Contract.ContractType.PROPOSALAPPROVECONTRACT,\n        'ProposalApproveContract',\n        options.Permission_id\n    );\n};\n\nconst buildExchangeCreateContract = (value, options) => {\n    const exchangeCreateContract = new ExchangeCreateContract();\n    const {\n        owner_address,\n        first_token_id,\n        first_token_balance,\n        second_token_id,\n        second_token_balance,\n    } = value;\n    exchangeCreateContract.setOwnerAddress(fromHexString(owner_address));\n    exchangeCreateContract.setFirstTokenId(\n        fromHexString(first_token_id.replace(/^0x/, ''))\n    );\n    exchangeCreateContract.setFirstTokenBalance(first_token_balance);\n    exchangeCreateContract.setSecondTokenId(\n        fromHexString(second_token_id.replace(/^0x/, ''))\n    );\n    exchangeCreateContract.setSecondTokenBalance(second_token_balance);\n    return buildCommonTransaction(\n        exchangeCreateContract,\n        Transaction.Contract.ContractType.EXCHANGECREATECONTRACT,\n        'ExchangeCreateContract',\n        options.Permission_id\n    );\n};\n\nconst buildExchangeInjectContract = (value, options) => {\n    const exchangeInjectContract = new ExchangeInjectContract();\n    const { owner_address, exchange_id, token_id, quant } = value;\n    exchangeInjectContract.setOwnerAddress(fromHexString(owner_address));\n    exchangeInjectContract.setExchangeId(exchange_id);\n    exchangeInjectContract.setTokenId(\n        fromHexString(token_id.replace(/^0x/, ''))\n    );\n    exchangeInjectContract.setQuant(quant);\n    return buildCommonTransaction(\n        exchangeInjectContract,\n        Transaction.Contract.ContractType.EXCHANGEINJECTCONTRACT,\n        'ExchangeInjectContract',\n        options.Permission_id\n    );\n};\n\nconst buildExchangeWithdrawContract = (value, options) => {\n    const exchangeWithdrawContract = new ExchangeWithdrawContract();\n    const { owner_address, exchange_id, token_id, quant } = value;\n    exchangeWithdrawContract.setOwnerAddress(fromHexString(owner_address));\n    exchangeWithdrawContract.setExchangeId(exchange_id);\n    exchangeWithdrawContract.setTokenId(\n        fromHexString(token_id.replace(/^0x/, ''))\n    );\n    exchangeWithdrawContract.setQuant(quant);\n    return buildCommonTransaction(\n        exchangeWithdrawContract,\n        Transaction.Contract.ContractType.EXCHANGEWITHDRAWCONTRACT,\n        'ExchangeWithdrawContract',\n        options.Permission_id\n    );\n};\n\nconst buildExchangeTransactionContract = (value, options) => {\n    const exchangeTransactionContract = new ExchangeTransactionContract();\n    const { owner_address, exchange_id, token_id, quant, expected } = value;\n    exchangeTransactionContract.setOwnerAddress(fromHexString(owner_address));\n    exchangeTransactionContract.setExchangeId(exchange_id);\n    exchangeTransactionContract.setTokenId(\n        fromHexString(token_id.replace(/^0x/, ''))\n    );\n    exchangeTransactionContract.setQuant(quant);\n    exchangeTransactionContract.setExpected(expected);\n    return buildCommonTransaction(\n        exchangeTransactionContract,\n        Transaction.Contract.ContractType.EXCHANGETRANSACTIONCONTRACT,\n        'ExchangeTransactionContract',\n        options.Permission_id\n    );\n};\n\nconst buildUpdateSettingContract = (value, options) => {\n    const updateSettingContract = new UpdateSettingContract();\n    const { owner_address, contract_address, consume_user_resource_percent } =\n        value;\n    updateSettingContract.setOwnerAddress(fromHexString(owner_address));\n    updateSettingContract.setContractAddress(fromHexString(contract_address));\n    updateSettingContract.setConsumeUserResourcePercent(\n        consume_user_resource_percent\n    );\n    return buildCommonTransaction(\n        updateSettingContract,\n        Transaction.Contract.ContractType.UPDATESETTINGCONTRACT,\n        'UpdateSettingContract',\n        options.Permission_id\n    );\n};\n\nconst buildUpdateEnergyLimitContract = (value, options) => {\n    const updateEnergyLimitContract = new UpdateEnergyLimitContract();\n    const { owner_address, contract_address, origin_energy_limit } = value;\n    updateEnergyLimitContract.setOwnerAddress(fromHexString(owner_address));\n    updateEnergyLimitContract.setContractAddress(\n        fromHexString(contract_address)\n    );\n    updateEnergyLimitContract.setOriginEnergyLimit(origin_energy_limit);\n    return buildCommonTransaction(\n        updateEnergyLimitContract,\n        Transaction.Contract.ContractType.UPDATEENERGYLIMITCONTRACT,\n        'UpdateEnergyLimitContract',\n        options.Permission_id\n    );\n};\n\nconst buildAccountPermissionUpdateContract = (value, options) => {\n    const accountPermissionUpdateContract =\n        new AccountPermissionUpdateContract();\n    const { owner_address, owner, witness, actives } = value;\n    accountPermissionUpdateContract.setOwnerAddress(\n        fromHexString(owner_address)\n    );\n    const getType = type => {\n        // no type when permission_name is owner\n        if (isNaN(type)) return type === 'Active' ? 2 : type === 'Witness' ? 1 : 0;\n        return type;\n    }\n    const buildPermission = (data) => {\n        // no type when permission_name is owner\n        const permission = new Permission();\n        const {\n            type,\n            id,\n            permission_name,\n            threshold,\n            parentId,\n            operations,\n            keys,\n        } = data;\n        permission.setType(getType(type));\n        permission.setId(id);\n        permission.setPermissionName(permission_name);\n        permission.setThreshold(threshold);\n        if (parentId) {\n            permission.setParentId(parentId);\n        }\n        if (operations) {\n            permission.setOperations(fromHexString(operations));\n        }\n        if (keys) {\n            permission.setKeysList(\n                keys.map((key) => {\n                    const keyBuilder = new Key();\n                    keyBuilder.setAddress(fromHexString(key.address));\n                    keyBuilder.setWeight(key.weight);\n                    return keyBuilder;\n                })\n            );\n        }\n        return permission;\n    };\n    if (owner) {\n        accountPermissionUpdateContract.setOwner(buildPermission(owner));\n    }\n    if (witness) {\n        accountPermissionUpdateContract.setWitness(buildPermission(witness));\n    }\n    if (actives) {\n        if (Array.isArray(actives)) {\n            accountPermissionUpdateContract.setActivesList(\n                actives.map(active => buildPermission(active))\n            );\n        } else {\n            accountPermissionUpdateContract.setActivesList([\n                buildPermission(actives),\n            ]);\n        }\n    }\n    return buildCommonTransaction(\n        accountPermissionUpdateContract,\n        Transaction.Contract.ContractType.ACCOUNTPERMISSIONUPDATECONTRACT,\n        'AccountPermissionUpdateContract',\n        options.Permission_id\n    );\n};\n\nconst buildUpdateAssetContract = (value, options) => {\n    const updateAssetContract = new UpdateAssetContract();\n    const { owner_address, description, url, new_limit, new_public_limit } = value;\n    updateAssetContract.setOwnerAddress(fromHexString(owner_address));\n    if (description) {\n        updateAssetContract.setDescription(fromHexString(description.replace(/^0x/, '')));\n    }\n    if (url) {\n        updateAssetContract.setUrl(fromHexString(url.replace(/^0x/, '')));\n    }\n    if(new_limit) {\n        updateAssetContract.setNewLimit(new_limit);\n    }\n    if(new_public_limit) {\n        updateAssetContract.setNewPublicLimit(new_public_limit);\n    }\n    return buildCommonTransaction(\n        updateAssetContract,\n        Transaction.Contract.ContractType.UPDATEASSETCONTRACT,\n        'UpdateAssetContract',\n        options.Permission_id\n    );\n}\n\nconst contractJsonToProtobuf = (contract, value, options) => {\n    switch (contract.type) {\n        case 'TransferContract':\n            return buildTransferContract(value, options);\n        case 'TransferAssetContract':\n            return buildTransferAssetContract(value, options);\n        case 'ParticipateAssetIssueContract':\n            return buildParticipateAssetIssueContract(value, options);\n        case 'TriggerSmartContract':\n            return buildTriggerSmartContract(value, options);\n        case 'FreezeBalanceContract':\n            return buildFreezeBalanceContract(value, options);\n        case 'UnfreezeBalanceContract':\n            return buildUnfreezeBalanceContract(value, options);\n        case 'WithdrawBalanceContract':\n            return buildWithdrawBalanceContract(value, options);\n        case 'FreezeBalanceV2Contract':\n            return buildFreezeBalanceV2Contract(value, options);\n        case 'CancelAllUnfreezeV2Contract':\n            return buildCancelFreezeBalanceV2Contract(value, options);\n        case 'UnfreezeBalanceV2Contract':\n            return buildUnfreezeBalanceV2Contract(value, options);\n        case 'DelegateResourceContract':\n            return buildDelegateResourceContract(value, options);\n        case 'UnDelegateResourceContract':\n            return buildUnDelegateResourceContract(value, options);\n        case 'WithdrawExpireUnfreezeContract':\n            return buildWithdrawExpireUnfreezeContract(value, options);\n        case 'WitnessCreateContract':\n            return buildCreateWitness(value, options);\n        case 'VoteWitnessContract':\n            return buildVoteWitnessAccount(value, options);\n        case 'CreateSmartContract':\n            return buildCreateSmartContract(value, options);\n        case 'ClearABIContract':\n            return buildClearABIContract(value, options);\n        case 'UpdateBrokerageContract':\n            return buildUpdateBrokerageContract(value, options);\n        case 'AssetIssueContract':\n            return buildAssetIssueContract(value, options);\n        case 'AccountCreateContract':\n            return buildAccountCreateContract(value, options);\n        case 'AccountUpdateContract':\n            return buildAccountUpdateContract(value, options);\n        case 'SetAccountIdContract':\n            return buildSetAccountIdContract(value, options);\n        case 'ProposalCreateContract':\n            return buildProposalCreateContract(value, options);\n        case 'ProposalDeleteContract':\n            return buildProposalDeleteContract(value, options);\n        case 'ProposalApproveContract':\n            return buildVoteProposalContract(value, options);\n        case 'ExchangeCreateContract':\n            return buildExchangeCreateContract(value, options);\n        case 'ExchangeInjectContract':\n            return buildExchangeInjectContract(value, options);\n        case 'ExchangeWithdrawContract':\n            return buildExchangeWithdrawContract(value, options);\n        case 'ExchangeTransactionContract':\n            return buildExchangeTransactionContract(value, options);\n        case 'UpdateSettingContract':\n            return buildUpdateSettingContract(value, options);\n        case 'UpdateEnergyLimitContract':\n            return buildUpdateEnergyLimitContract(value, options);\n        case 'AccountPermissionUpdateContract':\n            return buildAccountPermissionUpdateContract(value, options);\n        case 'UpdateAssetContract':\n            return buildUpdateAssetContract(value, options);\n    }\n};\n\nconst txJsonToPb = (transaction) => {\n    const rawData = transaction['raw_data'];\n    const contractJson = rawData.contract[0];\n    const data = contractJson.parameter.value;\n    const options = { Permission_id: contractJson.Permission_id };\n    const transactionObj = contractJsonToProtobuf(contractJson, data, options);\n\n    const rawDataObj = transactionObj.getRawData();\n    rawDataObj.setRefBlockBytes(fromHexString(rawData.ref_block_bytes));\n    rawDataObj.setRefBlockHash(fromHexString(rawData.ref_block_hash));\n    if (rawData.data) {\n        rawDataObj.setData(fromHexString(rawData.data));\n    }\n\n    if (rawData.fee_limit) {\n        rawDataObj.setFeeLimit(rawData.fee_limit);\n    }\n\n    if (rawData.expiration) {\n        rawDataObj.setExpiration(rawData.expiration);\n    }\n\n    if (rawData.timestamp) {\n        rawDataObj.setTimestamp(rawData.timestamp);\n    }\n\n    transactionObj.setRawData(rawDataObj);\n\n    return transactionObj;\n};\n\nconst txJsonToPbWithArgs = (\n    transaction,\n    args: any | {} = {},\n    options:any | {} = {}\n) => {\n    const rawData = transaction['raw_data'];\n    const contractJson = rawData.contract[0];\n\n    const transactionObj = contractJsonToProtobuf(contractJson, args, { Permission_id: args?.Permission_id });\n\n    const rawDataObj = transactionObj.getRawData();\n    rawDataObj.setRefBlockBytes(fromHexString(rawData.ref_block_bytes));\n    rawDataObj.setRefBlockHash(fromHexString(rawData.ref_block_hash));\n    // for memo\n    if (options.data) {\n        rawDataObj.setData(fromHexString(options.data.replace(/^0x/, '')));\n    }\n\n    if (options.fee_limit || args.fee_limit) {\n        rawDataObj.setFeeLimit(options.fee_limit || args.fee_limit);\n    }\n\n    if (rawData.expiration) {\n        rawDataObj.setExpiration(rawData.expiration);\n    }\n\n    if (rawData.timestamp) {\n        rawDataObj.setTimestamp(rawData.timestamp);\n    }\n\n    transactionObj.setRawData(rawDataObj);\n\n    return transactionObj;\n};\n\nconst compareTransaction = (transaction, transactionPb) => {\n    const rawDataBytes = transactionPb.getRawData().serializeBinary();\n    const rawDataHex = byteArray2hexStr(rawDataBytes);\n    const txID = sha256(rawDataBytes);\n    return (\n        rawDataHex.toLowerCase() === transaction.raw_data_hex.toLowerCase() &&\n        txID.replace(/^0x/, '').toLowerCase() ===\n            transaction.txID.replace(/^0x/, '').toLowerCase()\n    );\n\n};\n\nconst txPbToRawDataHex = (pb) => {\n    return byteArray2hexStr(pb.getRawData().serializeBinary());\n};\n\nconst txCheck = (transaction) => {\n    const transactionPb = txJsonToPb(transaction);\n    return compareTransaction(transaction, transactionPb);\n};\n\nconst txCheckWithArgs = (transaction, args, options) => {\n    const transactionPb = txJsonToPbWithArgs(\n        transaction,\n        args,\n        options\n    );\n    return compareTransaction(transaction, transactionPb);\n};\n\nconst txPbToTxID = (transactionPb) => {\n    const rawDataBytes = transactionPb.getRawData().serializeBinary();\n    const txID = sha256(rawDataBytes);\n    return txID;\n}\n\nexport {\n    txJsonToPb,\n    txPbToTxID,\n    txPbToRawDataHex,\n    txJsonToPbWithArgs,\n    txCheckWithArgs,\n    txCheck,\n};\n","import TronWeb from '..';\nimport {WithTronwebAndInjectpromise} from '../../src/utils/_base';\nimport Validator from '../paramValidator';\nimport type {\n    AccountResourceMessage as IAccountResource,\n    BlockExtention as IBlockExtention,\n    TransactionSignWeight as ISignWeight,\n    TransactionApprovedList as ITransactionApprovedList,\n    TransactionExtention as ITransactionExtention,\n} from '../proto/api/api';\nimport type {\n    Account as IAccount,\n    ChainParameters_ChainParameter as IChainParameter,\n    Exchange as IExchange,\n    NodeInfo as INodeInfo,\n    Proposal as IProposal,\n    TransactionInfo as ITransactionInfo,\n    Witness as IWitness,\n} from '../proto/core/Tron';\nimport type {AssetIssueContract as IToken} from '../proto/core/contract/asset_issue_contract';\nimport {ResourceCode as ResourceT} from '../proto/core/contract/common';\nimport type {SmartContract as ISmartContract} from '../proto/core/contract/smart_contract';\nimport utils from '../utils';\nimport {ADDRESS_PREFIX} from '../utils/address';\nimport type {SomeBytes} from '../utils/bytes';\nimport {ecRecover, type TypedDataTypes} from '../utils/crypto';\nimport {\n    SigningKey,\n    keccak256,\n    recoverAddress,\n    toUtf8Bytes,\n} from '../utils/ethersUtils';\nimport {txCheck} from \"../utils/transaction\"\nimport type {IDomain} from '../utils/typedData';\nimport type _CallbackT from '../utils/typing';\nimport type {\n    ISignedTransaction,\n    Transaction as ITransaction,\n} from './transactionBuilder';\n\nexport {ResourceCode as ResourceT} from '../proto/core/contract/common';\n\nconst TRX_MESSAGE_HEADER = '\\x19TRON Signed Message:\\n32';\n// it should be: '\\x15TRON Signed Message:\\n32';\nconst ETH_MESSAGE_HEADER = '\\x19Ethereum Signed Message:\\n32';\n\nexport type BlockT = number | 'latest' | 'earliest' | string;\n\nexport type {\n    Block as IBlock,\n    TransactionInfo_Log as ILog,\n    TransactionInfo as ITransactionInfo,\n    Account as IAccount,\n    Proposal as IProposal,\n    Exchange as IExchange,\n    Witness as IWitness,\n    ChainParameters_ChainParameter as IChainParameter,\n    NodeInfo as INodeInfo,\n} from '../proto/core/Tron';\n\nexport type {\n    TransactionExtention as ITransactionExtention,\n    TransactionSignWeight as ISignWeight,\n    BlockExtention as IBlockExtention,\n    TransactionApprovedList as ITransactionApprovedList,\n    AccountResourceMessage as IAccountResource,\n} from '../proto/api/api';\nexport type {SmartContract as ISmartContract} from '../proto/core/contract/smart_contract';\nexport type {AssetIssueContract as IToken} from '../proto/core/contract/asset_issue_contract';\n\nexport type MakeSigned<T> = T extends string ? T : T & {signature: string[]};\n\nexport type IBroadcastResult = {\n    code: string;\n    message: string;\n} & (\n    | {result: true; transaction: ISignedTransaction; txid: string}\n    | {result: false}\n);\nexport type IBroadcastHexResult = {\n    code: string;\n    message: string;\n} & (\n    | {result: true; transaction: ISignedTransaction; hexTransaction: string}\n    | {result: false}\n);\n\nexport interface IAddressOrPk {\n    privateKey?: string;\n    address?: string;\n}\n\nfunction toHex(value: string): string {\n    return TronWeb.address.toHex(value);\n}\n\nconst INVALID_ADDRESS_MSG = 'Invalid address provided';\nconst INVALID_TOKEN_ID_MSG = 'Invalid token ID provided';\nconst TOKEN_DOES_NOT_EXIST_MSG = 'Token does not exist';\nconst INVALID_TRANSACTION_MSG = 'Invalid transaction provided';\nconst INVALID_AMOUNT_MSG = 'Invalid amount provided';\nconst NEED_PK_OR_ADDRESS_MSG =\n    'Function requires either a private key or address to be set';\n\nexport default class Trx extends WithTronwebAndInjectpromise {\n    cache: {contracts: Record<string, ISmartContract>};\n    validator: Validator;\n\n    constructor(tronWeb: TronWeb) {\n        super(tronWeb);\n        this.cache = {\n            contracts: {},\n        };\n        this.validator = new Validator(tronWeb);\n    }\n\n    _parseToken(token: IToken): IToken {\n        return {\n            ...token,\n            name: this.tronWeb.toUtf8(token.name),\n            abbr: token.abbr && this.tronWeb.toUtf8(token.abbr),\n            description:\n                token.description && this.tronWeb.toUtf8(token.description),\n            url: token.url && this.tronWeb.toUtf8(token.url),\n        };\n    }\n\n    getCurrentBlock(callback?: undefined): Promise<IBlockExtention>;\n    getCurrentBlock(callback: _CallbackT<IBlockExtention>): void;\n    getCurrentBlock(\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback) return this.injectPromise(this.getCurrentBlock);\n        this.tronWeb.fullNode\n            .request('wallet/getnowblock')\n            .then((block) => {\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getConfirmedCurrentBlock(callback?: undefined): Promise<IBlockExtention>;\n    getConfirmedCurrentBlock(callback: _CallbackT<IBlockExtention>): void;\n    getConfirmedCurrentBlock(\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback) return this.injectPromise(this.getConfirmedCurrentBlock);\n        this.tronWeb.solidityNode\n            .request('walletsolidity/getnowblock')\n            .then((block) => {\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBlock(\n        block?: BlockT | null,\n        callback?: undefined,\n    ): Promise<IBlockExtention>;\n    getBlock(\n        block: BlockT | null | undefined,\n        callback: _CallbackT<IBlockExtention>,\n    ): void;\n    getBlock(\n        block: BlockT | null = this.tronWeb.defaultBlock,\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback) return this.injectPromise(this.getBlock, block);\n\n        if (block === null) return callback('No block identifier provided');\n\n        if (block === 'earliest') block = 0;\n        if (block === 'latest') return this.getCurrentBlock(callback);\n\n        // TODO: can we drop this weird isNaN for string?..\n        // if (isNaN(block as any as number) && utils.isHex(block))\n        if (utils.isHex(block)) return this.getBlockByHash(block, callback);\n\n        this.getBlockByNumber(block, callback);\n    }\n\n    getBlockByHash(\n        blockHash: string,\n        callback?: undefined,\n    ): Promise<IBlockExtention>;\n    getBlockByHash(\n        blockHash: string,\n        callback: _CallbackT<IBlockExtention>,\n    ): void;\n    getBlockByHash(\n        blockHash: string,\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback)\n            return this.injectPromise(this.getBlockByHash, blockHash);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getblockbyid',\n                {\n                    value: blockHash,\n                },\n                'post',\n            )\n            .then((block) => {\n                if (!Object.keys(block).length)\n                    return callback('Block not found');\n\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBlockByNumber(\n        blockID: number,\n        callback?: undefined,\n    ): Promise<IBlockExtention>;\n    getBlockByNumber(\n        blockID: number,\n        callback: _CallbackT<IBlockExtention>,\n    ): void;\n    getBlockByNumber(\n        blockID: number,\n        callback?: _CallbackT<IBlockExtention>,\n    ): void | Promise<IBlockExtention> {\n        if (!callback)\n            return this.injectPromise(this.getBlockByNumber, blockID);\n\n        if (!utils.isInteger(blockID) || blockID < 0)\n            return callback('Invalid block number provided');\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getblockbynum',\n                {num: parseInt(blockID.toString())},\n                'post',\n            )\n            .then((block) => {\n                if (!Object.keys(block).length)\n                    return callback('Block not found');\n\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBlockTransactionCount(\n        block?: BlockT | null | undefined,\n    ): Promise<number>;\n    getBlockTransactionCount(\n        block: BlockT | null | undefined,\n        callback: _CallbackT<number>,\n    ): void;\n    getBlockTransactionCount(\n        block: BlockT | null = this.tronWeb.defaultBlock,\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback)\n            return this.injectPromise(this.getBlockTransactionCount, block);\n\n        this.getBlock(block)\n            .then(({transactions = []}) => {\n                callback(null, transactions.length);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTransactionFromBlock(block?: BlockT | null): Promise<ITransaction[]>;\n    getTransactionFromBlock(\n        block: BlockT | null | undefined,\n        index: number,\n    ): Promise<ITransaction>;\n    getTransactionFromBlock(\n        block: BlockT | null | undefined,\n        index: null | undefined,\n        callback: _CallbackT<ITransaction[]>,\n    ): void;\n    getTransactionFromBlock(\n        block: BlockT | null | undefined,\n        index: number,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    getTransactionFromBlock(\n        block: BlockT | null = this.tronWeb.defaultBlock,\n        index?: number | null,\n        callback?: _CallbackT<ITransaction> | _CallbackT<ITransaction[]>,\n    ): void | Promise<ITransaction> | Promise<ITransaction[]> {\n        if (!callback)\n            return this.injectPromise(\n                this.getTransactionFromBlock,\n                block,\n                index,\n            );\n\n        this.getBlock(block)\n            .then(({transactions}) => {\n                if (!transactions) callback('Transaction not found in block');\n                else if (typeof index === 'number')\n                    if (index >= 0 && index < transactions.length)\n                        callback(null, transactions[index] as any);\n                    else callback('Invalid transaction index provided');\n                else callback(null, transactions as any);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTransaction(\n        transactionID: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    getTransaction(\n        transactionID: string,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    getTransaction(\n        transactionID: string,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.getTransaction, transactionID);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/gettransactionbyid',\n                {value: transactionID},\n                'post',\n            )\n            .then((transaction) => {\n                if (!Object.keys(transaction).length)\n                    return callback('Transaction not found');\n\n                callback(null, transaction);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getConfirmedTransaction(\n        transactionID: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    getConfirmedTransaction(\n        transactionID: string,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    getConfirmedTransaction(\n        transactionID: string,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.getConfirmedTransaction,\n                transactionID,\n            );\n\n        this.tronWeb.solidityNode\n            .request(\n                'walletsolidity/gettransactionbyid',\n                {value: transactionID},\n                'post',\n            )\n            .then((transaction) => {\n                if (!Object.keys(transaction).length)\n                    return callback('Transaction not found');\n\n                callback(null, transaction);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getUnconfirmedTransaction(\n        transactionID: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    getUnconfirmedTransaction(\n        transactionID: string,\n        callback: _CallbackT<ITransactionInfo>,\n    ): void;\n    getUnconfirmedTransaction(\n        transactionID: string,\n        callback?: _CallbackT<ITransactionInfo>,\n    ): void | Promise<ITransactionInfo> {\n        return this._getTransactionInfoById(\n            transactionID,\n            {confirmed: false},\n            callback as any,\n        );\n    }\n\n    getTransactionInfo(\n        transactionID: string,\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    getTransactionInfo(\n        transactionID: string,\n        callback: _CallbackT<ITransactionInfo>,\n    ): void;\n    getTransactionInfo(\n        transactionID: string,\n        callback?: _CallbackT<ITransactionInfo>,\n    ): void | Promise<ITransactionInfo> {\n        return this._getTransactionInfoById(\n            transactionID,\n            {confirmed: true},\n            callback as any,\n        );\n    }\n\n    _getTransactionInfoById(\n        transactionID: string,\n        options: {confirmed: boolean},\n        callback?: undefined,\n    ): Promise<ITransactionInfo>;\n    _getTransactionInfoById(\n        transactionID: string,\n        options: {confirmed: boolean},\n        callback: _CallbackT<ITransactionInfo>,\n    ): void;\n    _getTransactionInfoById(\n        transactionID: string,\n        options: {confirmed: boolean},\n        callback?: _CallbackT<ITransactionInfo>,\n    ): void | Promise<ITransactionInfo> {\n        if (!callback)\n            return this.injectPromise(\n                this._getTransactionInfoById,\n                transactionID,\n                options,\n            );\n\n        if (options.confirmed)\n            this.tronWeb.solidityNode\n                .request(\n                    'wallet/gettransactioninfobyid',\n                    {value: transactionID},\n                    'post',\n                )\n                .then((transaction) => {\n                    callback(null, transaction);\n                })\n                .catch((err) => callback(err));\n        else\n            this.tronWeb.fullNode\n                .request(\n                    'walletsolidity/gettransactioninfobyid',\n                    {value: transactionID},\n                    'post',\n                )\n                .then((transaction) => {\n                    callback(null, transaction);\n                })\n                .catch((err) => callback(err));\n    }\n\n    /**\n     * @deprecated This api is no longer supported in the latest version\n     * You can use the central node api: 47.90.247.237:8091/walletextension/gettransactionsfromthis\n     */\n    async getTransactionsToAddress(\n        address?: string,\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<ITransactionExtention[]>;\n    async getTransactionsToAddress(\n        address: string | undefined,\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void>;\n    async getTransactionsToAddress(\n        address: string = this.tronWeb.defaultAddress.hex,\n        limit = 30,\n        offset = 0,\n        callback?: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void | ITransactionExtention[]> {\n        return this.getTransactionsRelated(\n            address,\n            'to',\n            limit,\n            offset,\n            callback as any,\n        );\n    }\n\n    /**\n     * @deprecated This api is no longer supported in the latest version\n     * You can use the central node api: 47.90.247.237:8091/walletextension/gettransactionsfromthis\n     */\n    async getTransactionsFromAddress(\n        address?: string,\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<ITransactionExtention[]>;\n    async getTransactionsFromAddress(\n        address: string | undefined,\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void>;\n    async getTransactionsFromAddress(\n        address: string = this.tronWeb.defaultAddress.hex,\n        limit = 30,\n        offset = 0,\n        callback?: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void | ITransactionExtention[]> {\n        return this.getTransactionsRelated(\n            address,\n            'from',\n            limit,\n            offset,\n            callback as any,\n        );\n    }\n\n    /**\n     * @deprecated This api is no longer supported in the latest version\n     * You can use the central node api: 47.90.247.237:8091/walletextension/gettransactionsfromthis\n     */\n    async getTransactionsRelated(\n        address?: string,\n        direction?: 'all',\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<(ITransactionExtention & {direction: 'to' | 'from'})[]>;\n    async getTransactionsRelated(\n        address?: string,\n        direction?: 'to' | 'from',\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<ITransactionExtention[]>;\n    async getTransactionsRelated(\n        address: string | undefined,\n        direction: 'all' | undefined,\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<\n            (ITransactionExtention & {direction: 'to' | 'from'})[]\n        >,\n    ): Promise<void>;\n    async getTransactionsRelated(\n        address: string | undefined,\n        direction: 'to' | 'from',\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<ITransactionExtention[]>,\n    ): Promise<void>;\n    async getTransactionsRelated(\n        address: string = this.tronWeb.defaultAddress.hex,\n        direction: 'all' | 'to' | 'from' = 'all',\n        limit = 30,\n        offset = 0,\n        callback?:\n            | _CallbackT<(ITransactionExtention & {direction: 'to' | 'from'})[]>\n            | _CallbackT<ITransactionExtention[]>,\n    ): Promise<\n        | void\n        | (ITransactionExtention & {direction: 'to' | 'from'})[]\n        | ITransactionExtention[]\n    > {\n        if (!callback)\n            return this.injectPromise(\n                this.getTransactionsRelated,\n                address,\n                direction,\n                limit,\n                offset,\n            );\n\n        if (!['to', 'from', 'all'].includes(direction))\n            return callback(\n                'Invalid direction provided: Expected \"to\", \"from\" or \"all\"',\n            );\n\n        if (direction === 'all')\n            try {\n                const [from, to] = await Promise.all([\n                    this.getTransactionsRelated(address, 'from', limit, offset),\n                    this.getTransactionsRelated(address, 'to', limit, offset),\n                ]);\n\n                return callback(\n                    null,\n                    [\n                        ...from.map((tx: any) => ((tx.direction = 'from'), tx)),\n                        ...to.map((tx: any) => ((tx.direction = 'to'), tx)),\n                    ].sort((a, b) => {\n                        return b.raw_data.timestamp - a.raw_data.timestamp;\n                    }),\n                );\n            } catch (ex) {\n                return callback(ex);\n            }\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        if (!utils.isInteger(limit) || limit < 0 || (offset && limit < 1))\n            return callback('Invalid limit provided');\n\n        if (!utils.isInteger(offset) || offset < 0)\n            return callback('Invalid offset provided');\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.solidityNode\n            .request(\n                `walletextension/gettransactions${direction}this`,\n                {\n                    account: {\n                        address,\n                    } as IAccount,\n                    offset,\n                    limit,\n                },\n                'post',\n            )\n            .then(({transaction}) => {\n                callback(null, transaction as any);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getAccount(address?: string, callback?: undefined): Promise<IAccount>;\n    getAccount(\n        address: string | undefined,\n        callback: _CallbackT<IAccount>,\n    ): void;\n    getAccount(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<IAccount>,\n    ): void | Promise<IAccount> {\n        if (!callback) return this.injectPromise(this.getAccount, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.solidityNode\n            .request('walletsolidity/getaccount', {address} as IAccount, 'post')\n            .then((account) => {\n                callback(null, account);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getAccountById(id: string, callback?: undefined): Promise<IAccount>;\n    getAccountById(id: string, callback: _CallbackT<IAccount>): void;\n    getAccountById(\n        id: string,\n        callback?: _CallbackT<IAccount>,\n    ): void | Promise<IAccount> {\n        if (!callback) return this.injectPromise(this.getAccountById, id);\n        this.getAccountInfoById(id, {confirmed: true}, callback);\n    }\n\n    getAccountInfoById(\n        id: string,\n        options: {confirmed?: boolean} | undefined,\n        callback: _CallbackT<IAccount>,\n    ): void {\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'accountId',\n                        type: 'hex',\n                        value: id,\n                    },\n                    {\n                        name: 'accountId',\n                        type: 'string',\n                        lte: 32,\n                        gte: 8,\n                        value: id,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        if (id.startsWith('0x')) id = id.slice(2);\n\n        if (options && options.confirmed)\n            this.tronWeb.solidityNode\n                .request(\n                    'walletsolidity/getaccountbyid',\n                    {account_id: id} as IAccount,\n                    'post',\n                )\n                .then((account) => {\n                    callback(null, account);\n                })\n                .catch((err) => callback(err));\n        else\n            this.tronWeb.fullNode\n                .request(\n                    'wallet/getaccountbyid',\n                    {account_id: id} as IAccount,\n                    'post',\n                )\n                .then((account) => {\n                    callback(null, account);\n                })\n                .catch((err) => callback(err));\n    }\n\n    getBalance(address?: string, callback?: undefined): Promise<number>;\n    getBalance(address: string, callback: _CallbackT<number>): void;\n    getBalance(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback) return this.injectPromise(this.getBalance, address);\n\n        this.getAccount(address)\n            .then(({balance = 0}) => {\n                callback(null, balance);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getUnconfirmedAccount(\n        address?: string,\n        callback?: undefined,\n    ): Promise<IAccount>;\n    getUnconfirmedAccount(\n        address: string,\n        callback: _CallbackT<IAccount>,\n    ): void;\n    getUnconfirmedAccount(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<IAccount>,\n    ): void | Promise<IAccount> {\n        if (!callback)\n            return this.injectPromise(this.getUnconfirmedAccount, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.fullNode\n            .request('wallet/getaccount', {address} as IAccount, 'post')\n            .then((account) => {\n                callback(null, account);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getUnconfirmedAccountById(\n        id: string,\n        callback?: undefined,\n    ): Promise<IAccount>;\n    getUnconfirmedAccountById(id: string, callback: _CallbackT<IAccount>): void;\n    getUnconfirmedAccountById(\n        id: string,\n        callback?: _CallbackT<IAccount>,\n    ): void | Promise<IAccount> {\n        if (!callback)\n            return this.injectPromise(this.getUnconfirmedAccountById, id);\n        this.getAccountInfoById(id, {confirmed: false}, callback);\n    }\n\n    getUnconfirmedBalance(\n        address?: string,\n        callback?: undefined,\n    ): Promise<number>;\n    getUnconfirmedBalance(address: string, callback: _CallbackT<number>): void;\n    getUnconfirmedBalance(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback)\n            return this.injectPromise(this.getUnconfirmedBalance, address);\n\n        this.getUnconfirmedAccount(address)\n            .then(({balance = 0}) => {\n                callback(null, balance);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBandwidth(address?: string, callback?: undefined): Promise<number>;\n    getBandwidth(address: string, callback: _CallbackT<number>): void;\n    getBandwidth(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback) return this.injectPromise(this.getBandwidth, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.fullNode\n            .request('wallet/getaccountnet', {address} as IAccount, 'post')\n            .then(\n                ({\n                    freeNetUsed = 0,\n                    freeNetLimit = 0,\n                    NetUsed = 0,\n                    NetLimit = 0,\n                }) => {\n                    callback(\n                        null,\n                        freeNetLimit - freeNetUsed + (NetLimit - NetUsed),\n                    );\n                },\n            )\n            .catch((err) => callback(err));\n    }\n\n    getTokensIssuedByAddress(\n        address?: string,\n        callback?: undefined,\n    ): Promise<Record<string, IToken>>;\n    getTokensIssuedByAddress(\n        address: string,\n        callback: _CallbackT<Record<string, IToken>>,\n    ): void;\n    getTokensIssuedByAddress(\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<Record<string, IToken>>,\n    ): void | Promise<Record<string, IToken>> {\n        if (!callback)\n            return this.injectPromise(this.getTokensIssuedByAddress, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        address = this.tronWeb.address.toHex(address);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getassetissuebyaccount',\n                {address} as IAccount,\n                'post',\n            )\n            .then(({assetIssue}) => {\n                if (!assetIssue) return callback(null, {});\n\n                const tokens = assetIssue\n                    .map((token) => this._parseToken(token))\n                    .reduce((tokens, token) => {\n                        return (tokens[token.name] = token), tokens;\n                    }, {} as Record<string, IToken>);\n\n                callback(null, tokens);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTokenFromID(\n        tokenID: string | number,\n        callback?: undefined,\n    ): Promise<IToken>;\n    getTokenFromID(\n        tokenID: string | number,\n        callback: _CallbackT<IToken>,\n    ): void;\n    getTokenFromID(\n        tokenID: string | number,\n        callback?: _CallbackT<IToken>,\n    ): void | Promise<IToken> {\n        if (!callback) return this.injectPromise(this.getTokenFromID, tokenID);\n\n        if (utils.isInteger(tokenID)) tokenID = tokenID.toString();\n\n        if (!utils.isString(tokenID) || !tokenID.length)\n            return callback(INVALID_TOKEN_ID_MSG);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getassetissuebyname',\n                {value: this.tronWeb.fromUtf8(tokenID)},\n                'post',\n            )\n            .then((token) => {\n                if (!token.name) return callback(TOKEN_DOES_NOT_EXIST_MSG);\n\n                callback(null, this._parseToken(token));\n            })\n            .catch((err) => callback(err));\n    }\n\n    listNodes(callback?: undefined): Promise<string[]>;\n    listNodes(callback: _CallbackT<string[]>): void;\n    listNodes(callback?: _CallbackT<string[]>): void | Promise<string[]> {\n        if (!callback) return this.injectPromise(this.listNodes);\n\n        this.tronWeb.fullNode\n            .request('wallet/listnodes')\n            .then(({nodes = []}) => {\n                callback(\n                    null,\n                    nodes.map(\n                        ({address: a}) =>\n                            `${this.tronWeb.toUtf8(a!.host)}:${a!.port}`,\n                    ),\n                );\n            })\n            .catch((err) => callback(err));\n    }\n\n    getBlockRange(\n        start?: number,\n        end?: number,\n        callback?: undefined,\n    ): Promise<IBlockExtention[]>;\n    getBlockRange(\n        start: number | undefined,\n        end: number | undefined,\n        callback: _CallbackT<IBlockExtention[]>,\n    ): void;\n    getBlockRange(\n        start = 0,\n        end = 30,\n        callback?: _CallbackT<IBlockExtention[]>,\n    ): void | Promise<IBlockExtention[]> {\n        if (!callback)\n            return this.injectPromise(this.getBlockRange, start, end);\n\n        if (!utils.isInteger(start) || start < 0)\n            return callback('Invalid start of range provided');\n\n        if (!utils.isInteger(end) || end <= start)\n            return callback('Invalid end of range provided');\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getblockbylimitnext',\n                {\n                    startNum: parseInt(start.toString()),\n                    endNum: parseInt(end.toString()) + 1,\n                },\n                'post',\n            )\n            .then(({block = []}) => {\n                callback(null, block);\n            })\n            .catch((err) => callback(err));\n    }\n\n    listSuperRepresentatives(callback?: undefined): Promise<IWitness[]>;\n    listSuperRepresentatives(callback: _CallbackT<IWitness[]>): void;\n    listSuperRepresentatives(\n        callback?: _CallbackT<IWitness[]>,\n    ): void | Promise<IWitness[]> {\n        if (!callback) return this.injectPromise(this.listSuperRepresentatives);\n\n        this.tronWeb.fullNode\n            .request('wallet/listwitnesses')\n            .then(({witnesses = []}) => {\n                callback(null, witnesses);\n            })\n            .catch((err) => callback(err));\n    }\n\n    listTokens(\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<IToken[]>;\n    listTokens(\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<IToken[]>,\n    ): void;\n    listTokens(\n        limit = 0,\n        offset = 0,\n        callback?: _CallbackT<IToken[]>,\n    ): void | Promise<IToken[]> {\n        if (!callback)\n            return this.injectPromise(this.listTokens, limit, offset);\n\n        if (!utils.isInteger(limit) || limit < 0 || (offset && limit < 1))\n            return callback('Invalid limit provided');\n\n        if (!utils.isInteger(offset) || offset < 0)\n            return callback('Invalid offset provided');\n\n        if (!limit)\n            return this.tronWeb.fullNode\n                .request('wallet/getassetissuelist')\n                .then(({assetIssue = [] as IToken[]}) => {\n                    callback(\n                        null,\n                        assetIssue.map((token) => this._parseToken(token)),\n                    );\n                })\n                .catch((err) => callback(err)) as unknown as void;\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getpaginatedassetissuelist',\n                {\n                    offset: parseInt(offset.toString()),\n                    limit: parseInt(limit.toString()),\n                },\n                'post',\n            )\n            .then(({assetIssue = []}) => {\n                callback(\n                    null,\n                    assetIssue.map((token) => this._parseToken(token)),\n                );\n            })\n            .catch((err) => callback(err));\n    }\n\n    timeUntilNextVoteCycle(callback?: undefined): Promise<number>;\n    timeUntilNextVoteCycle(callback: _CallbackT<number>): void;\n    timeUntilNextVoteCycle(\n        callback?: _CallbackT<number>,\n    ): void | Promise<number> {\n        if (!callback) return this.injectPromise(this.timeUntilNextVoteCycle);\n\n        this.tronWeb.fullNode\n            .request('wallet/getnextmaintenancetime')\n            .then(({num = -1}) => {\n                if (num === -1)\n                    return callback('Failed to get time until next vote cycle');\n\n                callback(null, Math.floor(num / 1000));\n            })\n            .catch((err) => callback(err));\n    }\n\n    getContract(\n        contractAddress: string,\n        callback?: undefined,\n    ): Promise<ISmartContract>;\n    getContract(\n        contractAddress: string,\n        callback: _CallbackT<ISmartContract>,\n    ): void;\n    getContract(\n        contractAddress: string,\n        callback?: _CallbackT<ISmartContract>,\n    ): void | Promise<ISmartContract> {\n        if (!callback)\n            return this.injectPromise(this.getContract, contractAddress);\n\n        if (!this.tronWeb.isAddress(contractAddress))\n            return callback('Invalid contract address provided');\n\n        if (this.cache.contracts[contractAddress]) {\n            callback(null, this.cache.contracts[contractAddress]);\n            return undefined;\n        }\n\n        contractAddress = this.tronWeb.address.toHex(contractAddress);\n\n        this.tronWeb.fullNode\n            .request('wallet/getcontract', {value: contractAddress})\n            .then((contract) => {\n                if ('Error' in contract)\n                    return callback('Contract does not exist');\n                this.cache.contracts[contractAddress] = contract;\n                callback(null, contract);\n            })\n            .catch((err) => callback(err));\n    }\n\n    ecRecover(transaction) {\n        return Trx.ecRecover(transaction);\n    }\n\n    static ecRecover(transaction) {\n        if (!txCheck(transaction)) {\n            throw new Error('Invalid transaction');\n        }\n        if (!transaction.signature?.length) {\n            throw new Error('Transaction is not signed');\n        }\n        if (transaction.signature.length === 1) {\n            const tronAddress = ecRecover(transaction.txID, transaction.signature[0]);\n            return TronWeb.address.fromHex(tronAddress);\n        }\n        return transaction.signature.map((sig) => {\n            const tronAddress = ecRecover(transaction.txID, sig);\n            return TronWeb.address.fromHex(tronAddress);\n        });\n    }\n\n    async verifyMessage(\n        message: string,\n        signature: string,\n        address?: string,\n        useTronHeader?: boolean,\n        callback?: undefined,\n    ): Promise<boolean>;\n    async verifyMessage(\n        message: string,\n        signature: string,\n        address: string | undefined,\n        useTronHeader: boolean | undefined,\n        callback: _CallbackT<boolean>,\n    ): Promise<void>;\n    async verifyMessage(\n        message: string,\n        signature: string,\n        address: string = this.tronWeb.defaultAddress.base58,\n        useTronHeader: boolean | undefined = true,\n        callback?: _CallbackT<boolean>,\n    ): Promise<void | boolean> {\n        if (!callback)\n            return this.injectPromise(\n                this.verifyMessage,\n                message,\n                signature,\n                address,\n                useTronHeader,\n            );\n\n        if (!utils.isHex(message))\n            return callback('Expected hex message input');\n\n        if (Trx.verifySignature(message, address, signature, useTronHeader))\n            return callback(null, true);\n\n        callback('Signature does not match');\n    }\n\n    static verifySignature(\n        message: string,\n        address: string,\n        signature: string,\n        useTronHeader: boolean | undefined = true,\n    ): boolean {\n        message = message.replace(/^0x/, '');\n        signature = signature.replace(/^0x/, '');\n        const messageBytes = [\n            ...toUtf8Bytes(\n                useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER,\n            ),\n            ...utils.code.hexStr2byteArray(message),\n        ];\n\n        const messageDigest = keccak256(messageBytes);\n        const recovered = recoverAddress(messageDigest, {\n            recoveryParam: signature.substring(128, 130) === '1c' ? 1 : 0,\n            r: '0x' + signature.substring(0, 64),\n            s: '0x' + signature.substring(64, 128),\n        });\n\n        const tronAddress = ADDRESS_PREFIX + recovered.substr(2);\n        const base58Address = TronWeb.address.fromHex(tronAddress);\n\n        return base58Address === TronWeb.address.fromHex(address);\n    }\n\n    verifyMessageV2(\n        message: string,\n        signature: string,\n        options: _CallbackT<string>,\n        callback?: undefined,\n    ): void;\n    verifyMessageV2(\n        message: string,\n        signature: string,\n        options: undefined,\n        callback?: undefined,\n    ): Promise<string>;\n    verifyMessageV2(\n        message: string,\n        signature: string,\n        options: undefined,\n        callback: _CallbackT<string>,\n    ): void;\n    verifyMessageV2(\n        message: string,\n        signature: string,\n        options?: undefined | _CallbackT<string>,\n        callback?: _CallbackT<string>,\n    ): void | Promise<string> {\n        if (utils.isFunction(options))\n            return this.verifyMessageV2(message, signature, undefined, options);\n\n        if (!callback)\n            return this.injectPromise(\n                this.verifyMessageV2,\n                message,\n                signature,\n                options,\n            );\n\n        try {\n            const base58Address = Trx.verifyMessageV2(message, signature);\n            callback(null, base58Address);\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    static verifyMessageV2(message: string, signature: string): string {\n        return utils.message.verifyMessage(message, signature);\n    }\n\n    verifyTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        signature: string,\n        address?: string,\n        callback?: undefined,\n    ): Promise<boolean>;\n    verifyTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        signature: string,\n        address: string | undefined,\n        callback: _CallbackT<boolean>,\n    ): void;\n    verifyTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        signature: string,\n        address: string = this.tronWeb.defaultAddress.base58,\n        callback?: _CallbackT<boolean>,\n    ): void | Promise<boolean> {\n        if (!callback)\n            return this.injectPromise(\n                this.verifyTypedData,\n                domain,\n                types,\n                value,\n                signature,\n                address,\n            );\n\n        if (Trx.verifyTypedData(domain, types, value, signature, address))\n            return callback(null, true);\n\n        callback('Signature does not match');\n    }\n\n    static verifyTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        signature: string,\n        address: string,\n    ): boolean {\n        signature = signature.replace(/^0x/, '');\n\n        const messageDigest = utils._TypedDataEncoder.hash(\n            domain,\n            types,\n            value,\n        );\n        const recovered = recoverAddress(messageDigest, {\n            recoveryParam: signature.substring(128, 130) === '1c' ? 1 : 0,\n            r: '0x' + signature.substring(0, 64),\n            s: '0x' + signature.substring(64, 128),\n        });\n\n        const tronAddress = ADDRESS_PREFIX + recovered.substr(2);\n        const base58Address = TronWeb.address.fromHex(tronAddress);\n\n        return base58Address === TronWeb.address.fromHex(address);\n    }\n\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey?: string,\n        useTronHeader?: boolean,\n        multisig?: boolean,\n        callback?: undefined,\n    ): Promise<MakeSigned<T>>;\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey: string | undefined,\n        useTronHeader: boolean | undefined,\n        multisig: boolean | undefined,\n        callback: _CallbackT<MakeSigned<T>>,\n    ): Promise<void>;\n    async sign<T extends string | ITransaction>(\n        transaction: T,\n        privateKey: string = this.tronWeb.defaultAddress.hex,\n        useTronHeader: boolean | undefined = false,\n        multisig = false,\n        callback?: _CallbackT<MakeSigned<T>>,\n    ): Promise<void | MakeSigned<T>> {\n        if (!callback)\n            return this.injectPromise(\n                this.sign,\n                transaction,\n                privateKey,\n                useTronHeader,\n                multisig,\n            );\n\n        // Message signing\n        if (utils.isString(transaction)) {\n            if (!utils.isHex(transaction))\n                return callback('Expected hex message input');\n\n            try {\n                const signatureHex = Trx.signString(\n                    transaction,\n                    privateKey,\n                    useTronHeader,\n                );\n                return callback(null, signatureHex as MakeSigned<T>);\n            } catch (ex) {\n                callback(ex);\n            }\n        }\n\n        if (!utils.isObject(transaction))\n            return callback(INVALID_TRANSACTION_MSG);\n\n        if (!multisig && transaction.signature)\n            return callback('Transaction is already signed');\n\n        try {\n            if (!multisig) {\n                const address = this.tronWeb.address\n                    .toHex(this.tronWeb.address.fromPrivateKey(privateKey))\n                    .toLowerCase();\n\n                if (\n                    address !==\n                    this.tronWeb.address.toHex(\n                        transaction.raw_data.contract[0].parameter.value\n                            .owner_address,\n                    )\n                )\n                    return callback(\n                        'Private key does not match address in transaction',\n                    );\n            }\n            return callback(\n                null,\n                utils.crypto.signTransaction(\n                    privateKey,\n                    transaction,\n                ) as unknown as MakeSigned<T>,\n            );\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    static signString(\n        message: string,\n        privateKey: string,\n        useTronHeader: boolean | undefined = true,\n    ): string {\n        message = message.replace(/^0x/, '');\n        const value = {\n            toHexString: function () {\n                return '0x' + privateKey;\n            },\n            value: privateKey,\n        };\n        const signingKey = new SigningKey(value);\n        const messageBytes = [\n            ...toUtf8Bytes(\n                useTronHeader ? TRX_MESSAGE_HEADER : ETH_MESSAGE_HEADER,\n            ),\n            ...utils.code.hexStr2byteArray(message),\n        ];\n        const messageDigest = keccak256(messageBytes);\n        const signature = signingKey.signDigest(messageDigest);\n        return [\n            '0x',\n            signature.r.substring(2),\n            signature.s.substring(2),\n            Number(signature.v).toString(16),\n        ].join('');\n    }\n\n    signString(\n        message: string,\n        privateKey: string,\n        useTronHeader: boolean | undefined = true,\n    ): string {\n        return Trx.signString(message, privateKey, useTronHeader);\n    }\n\n    /**\n     * Sign message v2 for verified header length.\n     *\n     * @param {message to be signed, should be Bytes or string} message\n     * @param {privateKey for signature} privateKey\n     * @param {reserved} options\n     * @param {callback function} callback\n     */\n    signMessageV2(\n        message: SomeBytes | string,\n        privateKey?: string,\n        options?: undefined,\n        callback?: undefined,\n    ): Promise<string>;\n    signMessageV2(\n        message: SomeBytes | string,\n        privateKey: string | undefined,\n        options: undefined,\n        callback: _CallbackT<string>,\n    ): void;\n    signMessageV2(\n        message: SomeBytes | string,\n        privateKey: string = this.tronWeb.defaultPrivateKey,\n        options?: undefined | _CallbackT<string>,\n        callback?: _CallbackT<string>,\n    ): void | Promise<string> {\n        if (!callback)\n            return this.injectPromise(this.signMessageV2, message, privateKey);\n\n        try {\n            const signatureHex = Trx.signMessageV2(message, privateKey);\n            return callback(null, signatureHex);\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    static signMessageV2(\n        message: SomeBytes | string,\n        privateKey: string,\n    ): string {\n        return utils.message.signMessage(message, privateKey);\n    }\n\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n    ): Promise<string>;\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: _CallbackT<string>,\n    ): void;\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: string,\n        callback?: undefined,\n    ): Promise<string>;\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: string,\n        callback: _CallbackT<string>,\n    ): void;\n    _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: string | _CallbackT<string> = this.tronWeb\n            .defaultPrivateKey,\n        callback?: _CallbackT<string>,\n    ): void | Promise<string> {\n        if (utils.isFunction(privateKey))\n            return this._signTypedData(\n                domain,\n                types,\n                value,\n                this.tronWeb.defaultPrivateKey,\n                privateKey,\n            );\n\n        if (!callback)\n            return this.injectPromise(\n                this._signTypedData,\n                domain,\n                types,\n                value,\n                privateKey,\n            );\n\n        try {\n            const signatureHex = Trx._signTypedData(\n                domain,\n                types,\n                value,\n                privateKey,\n            );\n            return callback(null, signatureHex);\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    static _signTypedData(\n        domain: IDomain,\n        types: TypedDataTypes,\n        value: Record<string, unknown>,\n        privateKey: string,\n    ): string {\n        return utils.crypto._signTypedData(domain, types, value, privateKey);\n    }\n\n    async multiSign(\n        transaction: ITransaction,\n        privateKey?: string,\n        permissionId?: number,\n        callback?: undefined,\n    ): Promise<ISignedTransaction>;\n    async multiSign(\n        transaction: ITransaction,\n        privateKey: string | undefined,\n        permissionId: number | undefined,\n        callback: _CallbackT<ISignedTransaction>,\n    ): Promise<void>;\n    async multiSign(\n        transaction: ITransaction,\n        privateKey: string = this.tronWeb.defaultPrivateKey,\n        permissionId = 0,\n        callback?: _CallbackT<ISignedTransaction>,\n    ): Promise<void | ISignedTransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.multiSign,\n                transaction,\n                privateKey,\n                permissionId,\n            );\n\n        if (\n            !utils.isObject(transaction) ||\n            !transaction.raw_data ||\n            !transaction.raw_data.contract\n        )\n            return callback(INVALID_TRANSACTION_MSG);\n\n        // If owner permission or permission id exists in transaction, do sign directly\n        // If no permission id inside transaction or user passes permission id,\n        // use old way to reset permission id\n        if (\n            !transaction.raw_data.contract[0].Permission_id &&\n            permissionId > 0\n        ) {\n            // set permission id\n            transaction.raw_data.contract[0].Permission_id = permissionId;\n\n            // check if private key insides permission list\n            const address = this.tronWeb.address\n                .toHex(this.tronWeb.address.fromPrivateKey(privateKey))\n                .toLowerCase();\n            const signWeight = await this.getSignWeight(\n                transaction,\n                permissionId,\n            );\n\n            let foundKey = false;\n            signWeight.permission &&\n                signWeight.permission.keys.map((key) => {\n                    if (key.address === address) foundKey = true;\n                });\n\n            if (!foundKey)\n                return callback(privateKey + ' has no permission to sign');\n\n            if (\n                signWeight.approved_list &&\n                signWeight.approved_list.indexOf(address) !== -1\n            )\n                return callback(privateKey + ' already sign transaction');\n\n            // reset transaction\n            if (signWeight.transaction && signWeight.transaction.transaction) {\n                transaction = signWeight.transaction.transaction;\n                if (permissionId > 0)\n                    transaction.raw_data.contract[0].Permission_id =\n                        permissionId;\n            } else {\n                return callback(INVALID_TRANSACTION_MSG);\n            }\n        }\n\n        // sign\n        try {\n            return callback(\n                null,\n                utils.crypto.signTransaction(privateKey, transaction),\n            );\n        } catch (ex) {\n            callback(ex);\n        }\n    }\n\n    async getApprovedList(\n        transaction: ITransaction,\n        callback?: undefined,\n    ): Promise<any>;\n    async getApprovedList(\n        transaction: ITransaction,\n        callback: _CallbackT<ITransactionApprovedList>,\n    ): Promise<void>;\n    async getApprovedList(\n        transaction: ITransaction,\n        callback?: _CallbackT<ITransactionApprovedList>,\n    ): Promise<void | ITransactionApprovedList> {\n        if (!callback)\n            return this.injectPromise(this.getApprovedList, transaction);\n\n        if (!utils.isObject(transaction))\n            return callback(INVALID_TRANSACTION_MSG);\n\n        this.tronWeb.fullNode\n            .request('wallet/getapprovedlist', transaction, 'post')\n            .then((result) => {\n                callback(null, result);\n            })\n            .catch((err) => callback(err));\n    }\n\n    async getSignWeight(\n        transaction: ITransaction,\n        permissionId?: number,\n        callback?: undefined,\n    ): Promise<ISignWeight>;\n    async getSignWeight(\n        transaction: ITransaction,\n        permissionId: number | undefined,\n        callback?: _CallbackT<ISignWeight>,\n    ): Promise<void>;\n    async getSignWeight(\n        transaction: ITransaction,\n        permissionId?: number,\n        callback?: _CallbackT<ISignWeight>,\n    ): Promise<void | ISignWeight> {\n        if (!callback)\n            return this.injectPromise(\n                this.getSignWeight,\n                transaction,\n                permissionId,\n            );\n\n        if (\n            !utils.isObject(transaction) ||\n            !transaction.raw_data ||\n            !transaction.raw_data.contract\n        )\n            return callback(INVALID_TRANSACTION_MSG);\n\n        if (utils.isInteger(permissionId))\n            transaction.raw_data.contract[0].Permission_id = parseInt(\n                permissionId.toString(),\n            );\n        else if (\n            typeof transaction.raw_data.contract[0].Permission_id !== 'number'\n        )\n            transaction.raw_data.contract[0].Permission_id = 0;\n\n        if (!utils.isObject(transaction))\n            return callback(INVALID_TRANSACTION_MSG);\n\n        this.tronWeb.fullNode\n            .request('wallet/getsignweight', transaction, 'post')\n            .then((result) => {\n                callback(null, result);\n            })\n            .catch((err) => callback(err));\n    }\n\n    sendRawTransaction(\n        signedTransaction: ITransaction,\n        options?: undefined,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    sendRawTransaction(\n        signedTransaction: ITransaction,\n        options: undefined,\n        callback: _CallbackT<IBroadcastResult>,\n    ): void;\n    sendRawTransaction(\n        signedTransaction: ITransaction,\n        options?: undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): void | Promise<IBroadcastResult> {\n        if (!callback)\n            return this.injectPromise(\n                this.sendRawTransaction,\n                signedTransaction,\n                options,\n            );\n\n        if (!utils.isObject(signedTransaction))\n            return callback(INVALID_TRANSACTION_MSG);\n\n        if (\n            !signedTransaction.signature ||\n            !utils.isArray(signedTransaction.signature)\n        )\n            return callback('Transaction is not signed');\n\n        this.tronWeb.fullNode\n            .request('wallet/broadcasttransaction', signedTransaction, 'post')\n            .then((result) => {\n                const r = result as IBroadcastResult;\n                if (r.result) r.transaction = signedTransaction;\n                callback(null, r);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Broadcast a transaction in hex form\n     *  Warning: This method is missing in .proto and absent in docker test node\n     */\n    sendHexTransaction(\n        signedHexTransaction: string,\n        options?: undefined,\n        callback?: undefined,\n    ): Promise<IBroadcastHexResult>;\n    sendHexTransaction(\n        signedHexTransaction: string,\n        options: undefined,\n        callback: _CallbackT<IBroadcastHexResult>,\n    ): void;\n    sendHexTransaction(\n        signedHexTransaction: string,\n        options?: undefined,\n        callback?: _CallbackT<IBroadcastHexResult>,\n    ): void | Promise<IBroadcastHexResult> {\n        if (!callback)\n            return this.injectPromise(\n                this.sendHexTransaction,\n                signedHexTransaction,\n                options,\n            );\n\n        if (!utils.isHex(signedHexTransaction))\n            return callback('Invalid hex transaction provided');\n\n        const params = {\n            transaction: signedHexTransaction,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/broadcasthex' as any, params, 'post')\n            .then((result) => {\n                if (result.result) {\n                    result.transaction = JSON.parse(result.transaction);\n                    result.hexTransaction = signedHexTransaction;\n                }\n                callback(null, result);\n            })\n            .catch((err) => callback(err));\n    }\n\n    async sendTransaction(\n        to: string,\n        amount: number,\n        options?: string | IAddressOrPk,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async sendTransaction(\n        to: string,\n        amount: number,\n        options: string | IAddressOrPk | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async sendTransaction(\n        to: string,\n        amount: number,\n        options?: string | IAddressOrPk,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(\n                this.sendTransaction,\n                to,\n                amount,\n                options,\n            );\n\n        if (!this.tronWeb.isAddress(to))\n            return callback('Invalid recipient provided');\n\n        if (!utils.isInteger(amount) || amount <= 0)\n            return callback(INVALID_AMOUNT_MSG);\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const transaction = await this.tronWeb.transactionBuilder.sendTrx(\n                to,\n                amount,\n                address,\n            );\n            const signedTransaction = await this.sign(\n                transaction,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    async sendToken(\n        to: string,\n        amount: number,\n        tokenID: string | number,\n        options?: string | IAddressOrPk,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async sendToken(\n        to: string,\n        amount: number,\n        tokenID: string | number,\n        options: string | IAddressOrPk | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async sendToken(\n        to: string,\n        amount: number,\n        tokenID: string | number,\n        options?: string | IAddressOrPk | _CallbackT<IBroadcastResult>,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(\n                this.sendToken,\n                to,\n                amount,\n                tokenID,\n                options,\n            );\n\n        if (!this.tronWeb.isAddress(to))\n            return callback('Invalid recipient provided');\n\n        if (!utils.isInteger(amount) || amount <= 0)\n            return callback(INVALID_AMOUNT_MSG);\n\n        if (utils.isInteger(tokenID)) tokenID = tokenID.toString();\n\n        if (!utils.isString(tokenID)) return callback(INVALID_TOKEN_ID_MSG);\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const transaction = await this.tronWeb.transactionBuilder.sendToken(\n                to,\n                amount,\n                tokenID,\n                address,\n            );\n            const signedTransaction = await this.sign(\n                transaction,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    /**\n     * Freezes an amount of TRX.\n     * Will give bandwidth OR Energy and TRON Power(voting rights)\n     * to the owner of the frozen tokens.\n     *\n     * @param amount - is the number of frozen trx\n     * @param duration - is the duration in days to be frozen\n     * @param resource - is the type, must be either \"ENERGY\" or \"BANDWIDTH\"\n     * @param options\n     * @param callback\n     */\n    async freezeBalance(\n        amount: number,\n        duration?: number,\n        resource?: ResourceT,\n        options?: IAddressOrPk | string,\n        receiverAddress?: string,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async freezeBalance(\n        amount: number,\n        duration: number | undefined,\n        resource: ResourceT | undefined,\n        options: IAddressOrPk | string | undefined,\n        receiverAddress: string | undefined,\n        callback: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async freezeBalance(\n        amount: number,\n        duration = 3,\n        resource: ResourceT = 'BANDWIDTH',\n        options: IAddressOrPk | string = {},\n        receiverAddress?: string | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(\n                this.freezeBalance,\n                amount,\n                duration,\n                resource,\n                options,\n                receiverAddress,\n            );\n\n        if (!['BANDWIDTH', 'ENERGY'].includes(resource))\n            return callback(\n                'Invalid resource provided: Expected \"BANDWIDTH\" or \"ENERGY\"',\n            );\n\n        if (!utils.isInteger(amount) || amount <= 0)\n            return callback(INVALID_AMOUNT_MSG);\n\n        if (!utils.isInteger(duration) || duration < 3)\n            return callback('Invalid duration provided, minimum of 3 days');\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const freezeBalance =\n                await this.tronWeb.transactionBuilder.freezeBalance(\n                    amount,\n                    duration,\n                    resource,\n                    address,\n                    receiverAddress,\n                );\n            const signedTransaction = await this.sign(\n                freezeBalance,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    /**\n     * Unfreeze TRX that has passed the minimum freeze duration.\n     * Unfreezing will remove bandwidth and TRON Power.\n     *\n     * @param resource - is the type, must be either \"ENERGY\" or \"BANDWIDTH\"\n     * @param options\n     * @param callback\n     */\n    async unfreezeBalance(\n        resource?: ResourceT,\n        options?: IAddressOrPk,\n        receiverAddress?: string,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async unfreezeBalance(\n        resource: ResourceT | undefined,\n        options: IAddressOrPk | undefined,\n        receiverAddress: string | undefined,\n        callback: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async unfreezeBalance(\n        resource: ResourceT = 'BANDWIDTH',\n        options: IAddressOrPk = {},\n        receiverAddress?: string | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(\n                this.unfreezeBalance,\n                resource,\n                options,\n                receiverAddress,\n            );\n\n        if (!['BANDWIDTH', 'ENERGY'].includes(resource))\n            return callback(\n                'Invalid resource provided: Expected \"BANDWIDTH\" or \"ENERGY\"',\n            );\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const unfreezeBalance =\n                await this.tronWeb.transactionBuilder.unfreezeBalance(\n                    resource,\n                    address,\n                    receiverAddress,\n                );\n            const signedTransaction = await this.sign(\n                unfreezeBalance,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    /**\n     * Modify account name\n     * Note: Username is allowed to edit only once.\n     *\n     * @param privateKey - Account private Key\n     * @param accountName - name of the account\n     * @param callback\n     *\n     * @return modified Transaction Object\n     */\n    async updateAccount(\n        accountName: string,\n        options?: IAddressOrPk,\n        callback?: undefined,\n    ): Promise<IBroadcastResult>;\n    async updateAccount(\n        accountName: string,\n        options: IAddressOrPk | undefined,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void>;\n    async updateAccount(\n        accountName: string,\n        options?: IAddressOrPk,\n        callback?: _CallbackT<IBroadcastResult>,\n    ): Promise<void | IBroadcastResult> {\n        if (typeof options === 'string') options = {privateKey: options};\n\n        if (!callback)\n            return this.injectPromise(this.updateAccount, accountName, options);\n\n        if (!utils.isString(accountName) || !accountName.length)\n            return callback('Name must be a string');\n\n        options = {\n            privateKey: this.tronWeb.defaultPrivateKey,\n            address: this.tronWeb.defaultAddress.hex,\n            ...options,\n        };\n\n        if (!options.privateKey && !options.address)\n            return callback(NEED_PK_OR_ADDRESS_MSG);\n\n        try {\n            const address = (\n                options.privateKey\n                    ? this.tronWeb.address.fromPrivateKey(options.privateKey)\n                    : options.address\n            ) as string;\n            const updateAccount =\n                await this.tronWeb.transactionBuilder.updateAccount(\n                    accountName,\n                    address,\n                );\n            const signedTransaction = await this.sign(\n                updateAccount,\n                options.privateKey || undefined,\n            );\n            const result = await this.sendRawTransaction(signedTransaction);\n\n            return callback(null, result);\n        } catch (ex) {\n            return callback(ex);\n        }\n    }\n\n    signMessage: Trx['sign'] = this.sign.bind(this);\n    sendAsset: Trx['sendToken'] = this.sendToken.bind(this);\n    send: Trx['sendTransaction'] = this.sendTransaction.bind(this);\n    sendTrx: Trx['sendTransaction'] = this.sendTransaction.bind(this);\n    broadcast: Trx['sendRawTransaction'] = this.sendRawTransaction.bind(this);\n    broadcastHex: Trx['sendHexTransaction'] =\n        this.sendHexTransaction.bind(this);\n    signTransaction: Trx['sign'] = this.sign.bind(this);\n    getUnconfirmedTransactionInfo: Trx['getUnconfirmedTransaction'] =\n        this.getUnconfirmedTransaction.bind(this);\n\n    /**\n     * Gets a network modification proposal by ID.\n     */\n    getProposal(proposalID: number, callback?: undefined): Promise<IProposal>;\n    getProposal(proposalID: number, callback: _CallbackT<IProposal>): void;\n    getProposal(\n        proposalID: number,\n        callback?: _CallbackT<IProposal>,\n    ): void | Promise<IProposal> {\n        if (!callback) return this.injectPromise(this.getProposal, proposalID);\n\n        if (!utils.isInteger(proposalID) || proposalID < 0)\n            return callback('Invalid proposalID provided');\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getproposalbyid',\n                {id: parseInt(proposalID.toString())},\n                'post',\n            )\n            .then((proposal) => {\n                callback(null, proposal);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Lists all network modification proposals.\n     */\n    listProposals(callback?: undefined): Promise<IProposal[]>;\n    listProposals(callback: _CallbackT<IProposal[]>): void;\n    listProposals(\n        callback?: _CallbackT<IProposal[]>,\n    ): void | Promise<IProposal[]> {\n        if (!callback) return this.injectPromise(this.listProposals);\n\n        this.tronWeb.fullNode\n            .request('wallet/listproposals', {}, 'post')\n            .then(({proposals = []}) => {\n                callback(null, proposals);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Lists all parameters available for network modification proposals.\n     */\n    getChainParameters(callback?: undefined): Promise<IChainParameter[]>;\n    getChainParameters(callback: _CallbackT<IChainParameter[]>): void;\n    getChainParameters(\n        callback?: _CallbackT<IChainParameter[]>,\n    ): void | Promise<IChainParameter[]> {\n        if (!callback) return this.injectPromise(this.getChainParameters);\n\n        this.tronWeb.fullNode\n            .request('wallet/getchainparameters', {}, 'post')\n            .then(({chainParameter = []}) => {\n                callback(null, chainParameter);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Get the account resources\n     */\n    getAccountResources(\n        address: string,\n        callback?: undefined,\n    ): Promise<IAccountResource>;\n    getAccountResources(\n        address: string,\n        callback: _CallbackT<IAccountResource>,\n    ): void;\n    getAccountResources(\n        address: string,\n        callback?: _CallbackT<IAccountResource>,\n    ): void | Promise<IAccountResource> {\n        if (!callback)\n            return this.injectPromise(this.getAccountResources, address);\n\n        if (!this.tronWeb.isAddress(address))\n            return callback(INVALID_ADDRESS_MSG);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getaccountresource',\n                {address: this.tronWeb.address.toHex(address)} as IAccount,\n                'post',\n            )\n            .then((resources) => {\n                callback(null, resources);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Get the exchange ID.\n     */\n    getExchangeByID(\n        exchangeID: number,\n        callback?: undefined,\n    ): Promise<IExchange>;\n    getExchangeByID(exchangeID: number, callback: _CallbackT<IExchange>): void;\n    getExchangeByID(\n        exchangeID: number,\n        callback?: _CallbackT<IExchange>,\n    ): void | Promise<IExchange> {\n        if (!callback)\n            return this.injectPromise(this.getExchangeByID, exchangeID);\n\n        if (!utils.isInteger(exchangeID) || exchangeID < 0)\n            return callback('Invalid exchangeID provided');\n\n        this.tronWeb.fullNode\n            .request('wallet/getexchangebyid', {id: exchangeID}, 'post')\n            .then((exchange) => {\n                callback(null, exchange);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Lists the exchanges\n     */\n    listExchanges(callback?: undefined): Promise<IExchange[]>;\n    listExchanges(callback: _CallbackT<IExchange[]>): void;\n    listExchanges(\n        callback?: _CallbackT<IExchange[]>,\n    ): void | Promise<IExchange[]> {\n        if (!callback) return this.injectPromise(this.listExchanges);\n\n        this.tronWeb.fullNode\n            .request('wallet/listexchanges', {}, 'post')\n            .then(({exchanges = []}) => {\n                callback(null, exchanges);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Lists all network modification proposals.\n     */\n    listExchangesPaginated(\n        limit?: number,\n        offset?: number,\n        callback?: undefined,\n    ): Promise<IExchange[]>;\n    listExchangesPaginated(\n        limit: number | undefined,\n        offset: number | undefined,\n        callback: _CallbackT<IExchange[]>,\n    ): void;\n    listExchangesPaginated(\n        limit = 0,\n        offset = 0,\n        callback?: _CallbackT<IExchange[]>,\n    ): void | Promise<IExchange[]> {\n        if (!callback)\n            return this.injectPromise(\n                this.listExchangesPaginated,\n                limit,\n                offset,\n            );\n\n        this.tronWeb.fullNode\n            .request('wallet/getpaginatedexchangelist', {limit, offset}, 'post')\n            .then(({exchanges = []}) => {\n                callback(null, exchanges);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Get info about the node\n     */\n    getNodeInfo(callback?: undefined): Promise<INodeInfo>;\n    getNodeInfo(callback: _CallbackT<INodeInfo>): void;\n    getNodeInfo(callback?: _CallbackT<INodeInfo>): void | Promise<INodeInfo> {\n        if (!callback) return this.injectPromise(this.getNodeInfo);\n\n        this.tronWeb.fullNode\n            .request('wallet/getnodeinfo', {}, 'post')\n            .then((info) => {\n                callback(null, info);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTokenListByName(\n        tokenID: string | number,\n        callback?: undefined,\n    ): Promise<IToken[]>;\n    getTokenListByName(\n        tokenID: string | number,\n        callback: _CallbackT<IToken[]>,\n    ): void;\n    getTokenListByName(\n        tokenID: string | number,\n        callback?: _CallbackT<IToken[]>,\n    ): void | Promise<IToken[]> {\n        if (!callback)\n            return this.injectPromise(this.getTokenListByName, tokenID);\n\n        if (utils.isInteger(tokenID)) tokenID = tokenID.toString();\n\n        if (!utils.isString(tokenID) || !tokenID.length)\n            return callback(INVALID_TOKEN_ID_MSG);\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/getassetissuelistbyname',\n                {value: this.tronWeb.fromUtf8(tokenID)},\n                'post',\n            )\n            .then((token) => {\n                if (Array.isArray(token.assetIssue))\n                    return callback(\n                        null,\n                        token.assetIssue.map((t) => this._parseToken(t)),\n                    );\n                else if (!('name' in token) || !(token as any).name)\n                    return callback(TOKEN_DOES_NOT_EXIST_MSG);\n                // TODO: borrowed from old impl. This should never happen\n                else return callback(null, [this._parseToken(token as any)]);\n            })\n            .catch((err) => callback(err));\n    }\n\n    getTokenByID(\n        tokenID: string | number,\n        callback?: undefined,\n    ): Promise<IToken>;\n    getTokenByID(tokenID: string | number, callback: _CallbackT<IToken>): void;\n    getTokenByID(\n        tokenID: string | number,\n        callback?: _CallbackT<IToken>,\n    ): void | Promise<IToken> {\n        if (!callback) return this.injectPromise(this.getTokenByID, tokenID);\n\n        if (utils.isInteger(tokenID)) tokenID = tokenID.toString();\n\n        if (!utils.isString(tokenID) || !tokenID.length)\n            return callback(INVALID_TOKEN_ID_MSG);\n\n        this.tronWeb.fullNode\n            .request('wallet/getassetissuebyid', {value: tokenID}, 'post')\n            .then((token) => {\n                if (!token.name) return callback(TOKEN_DOES_NOT_EXIST_MSG);\n\n                callback(null, this._parseToken(token));\n            })\n            .catch((err) => callback(err));\n    }\n\n    async getReward(\n        address: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async getReward(\n        address: string,\n        options: {confirmed?: boolean},\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async getReward(\n        address: string,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        options.confirmed = true;\n        return this._getReward(address, options, callback as any);\n    }\n\n    async getUnconfirmedReward(\n        address: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async getUnconfirmedReward(\n        address: string,\n        options: {confirmed?: boolean},\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async getUnconfirmedReward(\n        address: string,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        options.confirmed = false;\n        return this._getReward(address, options, callback as any);\n    }\n\n    async getBrokerage(\n        address: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async getBrokerage(\n        address: string,\n        options: {confirmed?: boolean},\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async getBrokerage(\n        address: string,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        options.confirmed = true;\n        return this._getBrokerage(address, options, callback as any);\n    }\n\n    async getUnconfirmedBrokerage(\n        address: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async getUnconfirmedBrokerage(\n        address: string,\n        options: {confirmed?: boolean},\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async getUnconfirmedBrokerage(\n        address: string,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        options.confirmed = false;\n        return this._getBrokerage(address, options, callback as any);\n    }\n\n    async _getReward(\n        address?: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async _getReward(\n        address: string | undefined,\n        options: {confirmed?: boolean} | undefined,\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async _getReward(\n        address: string = this.tronWeb.defaultAddress.hex,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        if (!callback)\n            return this.injectPromise(this._getReward, address, options);\n        if (!utils.isString(address)) return callback('Invalid address.');\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {address: toHex(address)};\n\n        (options.confirmed\n            ? this.tronWeb.solidityNode.request(\n                  'walletsolidity/getReward',\n                  data,\n                  'post',\n              )\n            : this.tronWeb.fullNode.request('wallet/getReward', data, 'post')\n        )\n            .then((result = {}) => {\n                if (typeof result.reward === 'undefined')\n                    return callback('Not found.');\n\n                callback(null, result.reward);\n            })\n            .catch((err) => callback(err));\n    }\n\n    async _getBrokerage(\n        address?: string,\n        options?: {confirmed?: boolean},\n        callback?: undefined,\n    ): Promise<number>;\n    async _getBrokerage(\n        address: string | undefined,\n        options: {confirmed?: boolean} | undefined,\n        callback: _CallbackT<number>,\n    ): Promise<void>;\n    async _getBrokerage(\n        address: string = this.tronWeb.defaultAddress.hex,\n        options: {confirmed?: boolean} = {},\n        callback?: _CallbackT<number>,\n    ): Promise<void | number> {\n        if (!callback)\n            return this.injectPromise(this._getBrokerage, address, options);\n        if (!utils.isString(address))\n            return callback(`Invalid address: ${address}.`);\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {address: toHex(address)};\n\n        (options.confirmed\n            ? this.tronWeb.solidityNode.request(\n                  'walletsolidity/getBrokerage',\n                  data,\n                  'post',\n              )\n            : this.tronWeb.fullNode.request('wallet/getBrokerage', data, 'post')\n        )\n            .then((result) => {\n                if (typeof result.brokerage === 'undefined')\n                    return callback('Not found.');\n\n                callback(null, result.brokerage);\n            })\n            .catch((err) => callback(err));\n    }\n\n    async getBandwidthPrices() {\n        return this.tronWeb.fullNode.request('wallet/getbandwidthprices', {}, 'get')\n            .then((result: any) => {\n                if (typeof result.prices === 'undefined') {\n                    throw new Error('Not found.');\n                }\n\n                return result.prices;\n            });\n    }\n\n    async getEnergyPrices() {\n        return this.tronWeb.fullNode.request('wallet/getenergyprices', {}, 'get')\n            .then((result: any) => {\n                if (typeof result.prices === 'undefined') {\n                    throw new Error('Not found.');\n                }\n\n                return result.prices;\n            });\n    }\n}\n","import TronWeb from '..';\nimport Validator from '../paramValidator';\nimport type {Permission as IPermissions, Transaction, EstimateEnergyResponse} from '../proto/core/Tron';\nimport { EnergyEstimateContract } from '../proto/core/contract/asset_issue_contract';\nimport utils from '../utils';\nimport {WithTronwebAndInjectpromise} from '../utils/_base';\nimport {encodeParamsV2ByABI} from '../utils/abi';\nimport {ADDRESS_PREFIX_REGEX} from '../utils/address';\nimport {AbiCoder} from '../utils/ethersUtils';\nimport type _CallbackT from '../utils/typing';\nimport type {IAbi} from './contract';\nimport type {ILog} from './trx';\nimport {ResourceT} from './trx';\n\nexport type {Transaction, Permission as IPermissions} from '../proto/core/Tron';\n\nconst INVALID_RESOURCE_MESSAGE =\n    'Invalid resource provided: Expected \"BANDWIDTH\" or \"ENERGY';\nlet self;\n\n// @ts-ignore\nexport interface IPermissionsMinimal extends IPermissions {\n    // making some fields optional without importing all that stuff\n    id?: number;\n    parent_id?: number;\n    operations?: string;\n}\nexport type ITransaction = Transaction;\n\nexport interface ISignedTransaction extends ITransaction {\n    signature: string[];\n}\nexport interface BaseOptions {\n    feeLimit?: number;\n    userFeePercentage?: number;\n    originEnergyLimit?: number;\n    callValue?: any;\n    tokenValue?: number;\n    tokenId?: number | string;\n    token_id?: number;\n    funcABIV2?: any;\n    parametersV2?: any;\n    permissionId?: number;\n    rawParameter?: string;\n    shieldedParameter?: string;\n    confirmed?: boolean;\n    estimateEnergy?: boolean;\n}\nexport interface ContractOptions extends BaseOptions {\n    abi: string | {entrys: IAbi[]} | IAbi[];\n    bytecode: string;\n    parameters?: any[] | string;\n    shouldPollResponse?: boolean;\n    name?: string;\n}\nexport interface ITriggerContractOptions extends BaseOptions {\n    _isConstant?: boolean;\n}\nexport interface ITriggerContractEnergyOptions extends BaseOptions {\n    estimateEnergy?: boolean;\n}\n\ninterface IPermissionId {\n    permissionId?: number;\n}\nexport interface IUpdateTokenOptions extends IPermissionId {\n    description: string;\n    url: string;\n    // The creator's \"donated\" bandwidth for use by token holders\n    freeBandwidth?: number | string;\n    // Out of `totalFreeBandwidth`, the amount each token holder get\n    freeBandwidthLimit?: number | string;\n}\nexport interface ICreateTokenOptions extends IUpdateTokenOptions {\n    name: string;\n    abbreviation: string;\n    totalSupply: number | string;\n    voteScore?: number | string;\n    precision?: number | string;\n\n    // Timestamps\n    saleStart?: number | string;\n    saleEnd: number | string;\n\n    // How much TRX will `tokenRatio` cost?\n    trxRatio?: number | string;\n    // How many tokens will `trxRatio` afford?\n    tokenRatio?: number | string;\n    frozenAmount?: number | string;\n    frozenDuration?: number | string;\n    // for now there is no default for the following values\n}\ntype IResources = any;\n\nexport interface ITriggerSmartContract {\n    transaction: ITransaction;\n    result: {result: boolean};\n}\nexport interface ITriggerConstantContract extends ITriggerSmartContract {\n    energy_used: number;\n    constant_result: string[];\n    logs: ILog[];\n}\n\n//helpers\n\nfunction toHex(value: string): string {\n    return TronWeb.address.toHex(value);\n}\n\nfunction fromUtf8(value: string): string {\n    return self.tronWeb.fromUtf8(value);\n}\n\nfunction resultManager(transaction, callback) {\n    if (transaction.Error) return callback(transaction.Error);\n\n    if (transaction.result && transaction.result.message)\n        return callback(self.tronWeb.toUtf8(transaction.result.message));\n\n    return callback(null, transaction);\n}\n\nexport default class TransactionBuilder extends WithTronwebAndInjectpromise {\n    validator: Validator;\n\n    constructor(tronWeb: TronWeb) {\n        super(tronWeb);\n        self = this;\n        this.validator = new Validator(tronWeb);\n    }\n\n    sendTrx(\n        to: string,\n        amount?: string | number,\n        from?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    sendTrx(\n        to: string,\n        amount: string | number | undefined,\n        from: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    sendTrx(\n        to: string,\n        amount: string | number = 0,\n        from: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.sendTrx, to, amount, from, options);\n\n        // accept amounts passed as strings\n        amount = parseInt(amount.toString());\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'recipient',\n                        type: 'address',\n                        value: to,\n                    },\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: from,\n                    },\n                    {\n                        names: ['recipient', 'origin'],\n                        type: 'notEqual',\n                        msg: 'Cannot transfer TRX to the same account',\n                    },\n                    {\n                        name: 'amount',\n                        type: 'integer',\n                        gt: 0,\n                        value: amount,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            to_address: toHex(to),\n            owner_address: toHex(from),\n            amount: amount,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/createtransaction', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    sendToken(\n        to: string,\n        amount: number | string | undefined,\n        tokenID: string,\n        from?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    sendToken(\n        to: string,\n        amount: number | string | undefined,\n        tokenID: string,\n        from: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    sendToken(\n        to: string,\n        amount: number | string = 0,\n        tokenID: string,\n        from: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.sendToken,\n                to,\n                amount,\n                tokenID,\n                from,\n                options,\n            );\n\n        amount = parseInt(amount.toString());\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'recipient',\n                        type: 'address',\n                        value: to,\n                    },\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: from,\n                    },\n                    {\n                        names: ['recipient', 'origin'],\n                        type: 'notEqual',\n                        msg: 'Cannot transfer tokens to the same account',\n                    },\n                    {\n                        name: 'amount',\n                        type: 'integer',\n                        gt: 0,\n                        value: amount,\n                    },\n                    {\n                        name: 'token ID',\n                        type: 'tokenId',\n                        value: tokenID,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            to_address: toHex(to),\n            owner_address: toHex(from),\n            asset_name: fromUtf8(tokenID),\n            amount: parseInt(amount.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/transferasset', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    purchaseToken(\n        issuerAddress: string,\n        tokenID: string,\n        amount?: number,\n        buyer?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    purchaseToken(\n        issuerAddress: string,\n        tokenID: string,\n        amount: number | undefined,\n        buyer: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    purchaseToken(\n        issuerAddress: string,\n        tokenID: string,\n        amount: number | string = 0,\n        buyer: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.purchaseToken,\n                issuerAddress,\n                tokenID,\n                amount,\n                buyer,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'buyer',\n                        type: 'address',\n                        value: buyer,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        names: ['buyer', 'issuer'],\n                        type: 'notEqual',\n                        msg: 'Cannot purchase tokens from same account',\n                    },\n                    {\n                        name: 'amount',\n                        type: 'integer',\n                        gt: 0,\n                        value: amount,\n                    },\n                    {\n                        name: 'token ID',\n                        type: 'tokenId',\n                        value: tokenID,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            to_address: toHex(issuerAddress),\n            owner_address: toHex(buyer),\n            asset_name: fromUtf8(tokenID),\n            amount: parseInt(amount.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/participateassetissue', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    freezeBalance(\n        amount: number,\n        duration: number,\n        resource?: ResourceT,\n        address?: string,\n        receiverAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    freezeBalance(\n        amount: number,\n        duration: number,\n        resource: ResourceT | undefined,\n        address: string | undefined,\n        receiverAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    freezeBalance(\n        amount = 0,\n        duration = 3,\n        resource: ResourceT = ResourceT.BANDWIDTH,\n        address: string = this.tronWeb.defaultAddress.hex,\n        receiverAddress?: string,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.freezeBalance,\n                amount,\n                duration,\n                resource,\n                address,\n                receiverAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                    {\n                        name: 'receiver',\n                        type: 'address',\n                        value: receiverAddress,\n                        optional: true,\n                    },\n                    {\n                        name: 'amount',\n                        type: 'integer',\n                        gt: 0,\n                        value: amount,\n                    },\n                    {\n                        name: 'duration',\n                        type: 'integer',\n                        gte: 3,\n                        value: duration,\n                    },\n                    {\n                        name: 'resource',\n                        type: 'resource',\n                        value: resource,\n                        msg: INVALID_RESOURCE_MESSAGE,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(address),\n            frozen_balance: parseInt(amount.toString()),\n            frozen_duration: parseInt(duration.toString()),\n            resource: resource,\n            receiver_address:\n                receiverAddress != null &&\n                toHex(receiverAddress) !== toHex(address)\n                    ? toHex(receiverAddress)\n                    : undefined,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/freezebalance', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    unfreezeBalance(\n        resource?: ResourceT,\n        address?: string,\n        receiverAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    unfreezeBalance(\n        resource: ResourceT | undefined,\n        address: string | undefined,\n        receiverAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    unfreezeBalance(\n        resource: ResourceT = ResourceT.BANDWIDTH,\n        address: string = this.tronWeb.defaultAddress.hex,\n        receiverAddress: string | undefined,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.unfreezeBalance,\n                resource,\n                address,\n                receiverAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                    {\n                        name: 'receiver',\n                        type: 'address',\n                        value: receiverAddress,\n                        optional: true,\n                    },\n                    {\n                        name: 'resource',\n                        type: 'resource',\n                        value: resource,\n                        msg: INVALID_RESOURCE_MESSAGE,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(address),\n            resource: resource,\n            receiver_address:\n                receiverAddress != null &&\n                toHex(receiverAddress) !== toHex(address)\n                    ? toHex(receiverAddress)\n                    : undefined,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/unfreezebalance', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    withdrawBlockRewards(\n        address?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    withdrawBlockRewards(\n        address: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    withdrawBlockRewards(\n        address: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawBlockRewards,\n                address,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(address),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/withdrawbalance', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    applyForSR(\n        address: string | undefined,\n        url: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    applyForSR(\n        address: string | undefined,\n        url: string,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    applyForSR(\n        address: string = this.tronWeb.defaultAddress.hex,\n        url: string,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.applyForSR, address, url, options);\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                    {\n                        name: 'url',\n                        type: 'url',\n                        value: url,\n                        msg: 'Invalid url provided',\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(address),\n            url: fromUtf8(url),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/createwitness', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    vote(\n        votes: Record<string, number>,\n        voterAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    vote(\n        votes: Record<string, number>,\n        voterAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    vote(\n        votes: Record<string, number>,\n        voterAddress: string = this.tronWeb.defaultAddress.hex,\n        options: IPermissionId = {},\n        callback?: _CallbackT<ITransaction>,\n    ) {\n        if (!callback)\n            return this.injectPromise(this.vote, votes, voterAddress, options);\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'voter',\n                        type: 'address',\n                        value: voterAddress,\n                    },\n                    {\n                        name: 'votes',\n                        type: 'notEmptyObject',\n                        value: votes,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        let invalid = false;\n        const votesArr = Object.entries(votes).map(([srAddress, voteCount]) => {\n            if (invalid) return;\n\n            if (\n                this.validator.notValid([\n                    {\n                        name: 'SR',\n                        type: 'address',\n                        value: srAddress,\n                    },\n                    {\n                        name: 'vote count',\n                        type: 'integer',\n                        gt: 0,\n                        value: voteCount,\n                        msg: 'Invalid vote count provided for SR: ' + srAddress,\n                    },\n                ])\n            )\n                return (invalid = true);\n\n            return {\n                vote_address: toHex(srAddress),\n                vote_count: parseInt(voteCount.toString()),\n            };\n        }) as {vote_address: string; vote_count: number}[];\n        // Casting, because we'll return immediately otherwise\n        // It doesn't affect typechecking anyway\n\n        if (invalid) return;\n\n        const data = {\n            owner_address: toHex(voterAddress),\n            votes: votesArr,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/votewitnessaccount', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    createSmartContract(\n        options: ContractOptions,\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITransaction & {contract_address: string}>;\n    createSmartContract(\n        options: ContractOptions,\n        issuerAddress: string | undefined,\n        callback?: _CallbackT<ITransaction & {contract_address: string}>,\n    ): void;\n    createSmartContract(\n        options: ContractOptions,\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction & {contract_address: string}>,\n    ): void | Promise<ITransaction & {contract_address: string}> {\n        if (!callback)\n            return this.injectPromise(\n                this.createSmartContract,\n                options,\n                issuerAddress,\n            );\n\n        const feeLimit = options.feeLimit || this.tronWeb.feeLimit;\n        let userFeePercentage = options.userFeePercentage;\n        if (typeof userFeePercentage !== 'number' && !userFeePercentage)\n            userFeePercentage = 100;\n\n        const originEnergyLimit = options.originEnergyLimit || 10_000_000;\n        const callValue = options.callValue || 0;\n        const tokenValue = options.tokenValue;\n        const tokenId = options.tokenId || options.token_id;\n\n        // eslint-disable-next-line prefer-const\n        let {abi = '', bytecode, parameters = [], name = ''} = options;\n\n        if (abi && utils.isString(abi))\n            try {\n                abi = JSON.parse(abi);\n            } catch {\n                return callback('Invalid options.abi provided');\n            }\n\n        if (utils.isString(abi)) throw new Error('Impossible!');\n\n        const abi_arr = 'entrys' in abi ? abi.entrys : abi;\n\n        if (!utils.isArray(abi_arr))\n            return callback('Invalid options.abi provided');\n\n        const payable = abi_arr.some((func) => {\n            return (\n                func.type === 'constructor' &&\n                'payable' === func.stateMutability.toLowerCase()\n            );\n        });\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'bytecode',\n                        type: 'hex',\n                        value: bytecode,\n                    },\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gt: 0,\n                    },\n                    {\n                        name: 'callValue',\n                        type: 'integer',\n                        value: callValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'userFeePercentage',\n                        type: 'integer',\n                        value: userFeePercentage,\n                        gte: 0,\n                        lte: 100,\n                    },\n                    {\n                        name: 'originEnergyLimit',\n                        type: 'integer',\n                        value: originEnergyLimit,\n                        gte: 0,\n                        lte: 10_000_000,\n                    },\n                    {\n                        name: 'parameters',\n                        type: 'array',\n                        value: parameters,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        name: 'tokenValue',\n                        type: 'integer',\n                        value: tokenValue,\n                        gte: 0,\n                        optional: true,\n                    },\n                    {\n                        name: 'tokenId',\n                        type: 'integer',\n                        value: tokenId,\n                        gte: 0,\n                        optional: true,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        if (payable && callValue === 0 && tokenValue === 0)\n            return callback(\n                'When contract is payable, options.callValue or options.tokenValue' +\n                    ' must be a positive integer',\n            );\n\n        if (!payable && (callValue > 0 || (tokenValue && tokenValue > 0)))\n            return callback(\n                'When contract is not payable, options.callValue' +\n                    ' and options.tokenValue must be 0',\n            );\n\n        if (options.rawParameter && utils.isString(options.rawParameter)) {\n            parameters = options.rawParameter.replace(/^(0x)/, '');\n        } else if (options.funcABIV2) {\n            parameters = encodeParamsV2ByABI(\n                options.funcABIV2,\n                options.parametersV2,\n            ).replace(/^(0x)/, '');\n        } else {\n            const constructorParams = abi_arr.find((it) => {\n                return it.type === 'constructor';\n            });\n\n            if (typeof constructorParams !== 'undefined' && constructorParams) {\n                const abiCoder = new AbiCoder();\n                const types: string[] = [];\n                const values: unknown[] = [];\n                const constructorParams2: {type?: string}[] =\n                    constructorParams.inputs;\n\n                if (parameters.length !== constructorParams2.length)\n                    return callback(\n                        `constructor needs ${constructorParams2.length}` +\n                            ` but ${parameters.length} provided`,\n                    );\n\n                for (let i = 0; i < parameters.length; i++) {\n                    let type = constructorParams2[i].type;\n                    let value = parameters[i];\n\n                    if (!type || !utils.isString(type) || !type.length)\n                        return callback(\n                            'Invalid parameter type provided: ' + type,\n                        );\n\n                    if (type === 'address')\n                        value = toHex(value).replace(\n                            ADDRESS_PREFIX_REGEX,\n                            '0x',\n                        );\n                    else if (\n                        type.match(/^([^\\x5b]*)(\\x5b|$)/)![0] === 'address['\n                    )\n                        value = value.map((v) =>\n                            toHex(v).replace(ADDRESS_PREFIX_REGEX, '0x'),\n                        );\n                    else if (/trcToken/.test(type))\n                        type = type.replace(/trcToken/, 'uint256');\n\n                    types.push(type);\n                    values.push(value);\n                }\n\n                try {\n                    parameters = abiCoder\n                        .encode(types, values)\n                        .replace(/^(0x)/, '');\n                } catch (ex) {\n                    return callback(ex);\n                }\n            } else {\n                parameters = '';\n            }\n        }\n\n        const args = {\n            owner_address: toHex(issuerAddress),\n            fee_limit: parseInt(feeLimit.toString()),\n            call_value: parseInt(callValue),\n            consume_user_resource_percent: userFeePercentage,\n            origin_energy_limit: originEnergyLimit,\n            abi: JSON.stringify(abi_arr) as any,\n            bytecode,\n            parameter: parameters,\n            name,\n            token_id:\n                tokenId != null ? parseInt(tokenId.toString()) : undefined,\n            call_token_value:\n                tokenValue != null\n                    ? parseInt(tokenValue.toString())\n                    : undefined,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        // tokenValue and tokenId can cause errors if provided\n        // when the trx10 proposal has not been approved yet.\n        // So we set them only if they are passed to the method.\n\n        this.tronWeb.fullNode\n            .request('wallet/deploycontract', args, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters?: {type: string; value: any}[] | undefined,\n        issuerAddress?: string | undefined,\n        callback?: undefined,\n    ): Promise<ITriggerSmartContract>;\n    triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] | undefined,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITriggerSmartContract>,\n    ): void;\n    triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] = [],\n        issuerAddress: string | undefined = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITriggerSmartContract>,\n    ): void | Promise<ITriggerSmartContract> {\n        return this._triggerSmartContract(\n            contractAddress,\n            functionSelector,\n            options,\n            parameters,\n            issuerAddress,\n            callback as any,\n        );\n    }\n\n    triggerConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters?: {type: string; value: any}[],\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITriggerConstantContract>;\n    triggerConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] | undefined,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITriggerConstantContract>,\n    ): void;\n    triggerConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] = [],\n        issuerAddress: string | undefined = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITriggerConstantContract>,\n    ): void | Promise<ITriggerConstantContract> {\n        options._isConstant = true;\n        return this.triggerSmartContract(\n            contractAddress,\n            functionSelector,\n            options,\n            parameters,\n            issuerAddress,\n            callback as any,\n        ) as any;\n    }\n\n    triggerConfirmedConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters?: {type: string; value: any}[],\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITriggerConstantContract>;\n    triggerConfirmedConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] | undefined,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITriggerConstantContract>,\n    ): void;\n    triggerConfirmedConstantContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] = [],\n        issuerAddress: string | undefined = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITriggerConstantContract>,\n    ): void | Promise<ITriggerConstantContract> {\n        options._isConstant = true;\n        options.confirmed = true;\n        return this.triggerSmartContract(\n            contractAddress,\n            functionSelector,\n            options,\n            parameters,\n            issuerAddress,\n            callback as any,\n        ) as any;\n    }\n\n    estimateEnergy(...params) {\n        params[2].estimateEnergy = true;\n        return this._estimateEnergyCall(params[0], params[1], params[2], params[3], params[4], params[5])\n    }\n\n    _triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters?: {type: string; value: any}[],\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITriggerSmartContract>;\n    _triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] | undefined,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITriggerSmartContract>,\n    ): void;\n    _triggerSmartContract(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractOptions,\n        parameters: {type: string; value: any}[] = [],\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITriggerSmartContract>,\n    ): void | Promise<ITriggerSmartContract> {\n        if (!callback)\n            return this.injectPromise(\n                this._triggerSmartContract,\n                contractAddress,\n                functionSelector,\n                options,\n                parameters,\n                issuerAddress,\n            );\n\n        const {tokenValue, tokenId, callValue, feeLimit} = Object.assign(\n            {\n                callValue: 0,\n                feeLimit: this.tronWeb.feeLimit,\n            },\n            options,\n        );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gt: 0,\n                    },\n                    {\n                        name: 'callValue',\n                        type: 'integer',\n                        value: callValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'parameters',\n                        type: 'array',\n                        value: parameters,\n                    },\n                    {\n                        name: 'contract',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                        optional: true,\n                    },\n                    {\n                        name: 'tokenValue',\n                        type: 'integer',\n                        value: tokenValue,\n                        gte: 0,\n                        optional: true,\n                    },\n                    {\n                        name: 'tokenId',\n                        type: 'integer',\n                        value: tokenId,\n                        gte: 0,\n                        optional: true,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const args = {\n            contract_address: toHex(contractAddress),\n            owner_address: toHex(issuerAddress),\n        } as {\n            owner_address: string;\n            contract_address: string;\n            call_value: number;\n            data: string;\n            call_token_value: number;\n            token_id: number;\n            fee_limit?: number;\n            function_selector: string;\n            parameter: string;\n            Permission_id?: undefined | number;\n        };\n\n        let param_str: string;\n        if (functionSelector && utils.isString(functionSelector)) {\n            functionSelector = functionSelector.replace('/s*/g', '');\n            if (parameters.length) {\n                const abiCoder = new AbiCoder();\n                let types: string[] = [];\n                const values: unknown[] = [];\n\n                for (let i = 0; i < parameters.length; i++) {\n                    // eslint-disable-next-line prefer-const\n                    let {type, value} = parameters[i];\n\n                    if (!type || !utils.isString(type) || !type.length)\n                        return callback(\n                            'Invalid parameter type provided: ' + type,\n                        ) as any as void;\n\n                    if (type === 'address')\n                        value = toHex(value).replace(\n                            ADDRESS_PREFIX_REGEX,\n                            '0x',\n                        );\n                    else if (\n                        type.match(/^([^\\x5b]*)(\\x5b|$)/)![0] === 'address['\n                    )\n                        value = value.map((v) =>\n                            toHex(v).replace(ADDRESS_PREFIX_REGEX, '0x'),\n                        );\n\n                    types.push(type);\n                    values.push(value);\n                }\n\n                try {\n                    // workaround for unsupported trcToken type\n                    types = types.map((type) => {\n                        if (/trcToken/.test(type))\n                            type = type.replace(/trcToken/, 'uint256');\n\n                        return type;\n                    });\n\n                    param_str = abiCoder\n                        .encode(types, values)\n                        .replace(/^(0x)/, '');\n                } catch (ex) {\n                    return callback(ex) as any as void;\n                }\n            } else {\n                param_str = '';\n            }\n\n            // work for abiv2 if passed the function abi in options\n            if (options.funcABIV2)\n                param_str = encodeParamsV2ByABI(\n                    options.funcABIV2,\n                    options.parametersV2,\n                ).replace(/^(0x)/, '');\n\n            if (\n                options.shieldedParameter &&\n                utils.isString(options.shieldedParameter)\n            )\n                param_str = options.shieldedParameter.replace(/^(0x)/, '');\n\n            if (options.rawParameter && utils.isString(options.rawParameter))\n                param_str = options.rawParameter.replace(/^(0x)/, '');\n\n            args.function_selector = functionSelector;\n            args.parameter = param_str;\n        }\n\n        args.call_value = parseInt(callValue);\n        if (tokenValue != null)\n            args.call_token_value = parseInt(tokenValue.toString());\n        if (tokenId != null) args.token_id = parseInt(tokenId.toString());\n\n        if (!(options._isConstant || options.estimateEnergy))\n            args.fee_limit = parseInt(feeLimit.toString());\n\n        if (options.permissionId) args.Permission_id = options.permissionId;\n\n        let pathInfo = 'triggesmartcontract';\n        if(options._isConstant) {\n            pathInfo = 'triggerconstantcontract';\n        } else if (options.estimateEnergy) {\n            pathInfo = 'estimateenergy';\n        }\n        pathInfo = `wallet${options.confirmed ? 'solidity' : ''}/${pathInfo}`\n\n        this.tronWeb[options.confirmed ? 'solidityNode' : 'fullNode']\n            // An error occurs here we need to fix it\n            .request(\n                pathInfo as any as 'wallet/triggersmartcontract',\n                args,\n                'post',\n            )\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    _estimateEnergyCall(\n        contractAddress: string,\n        functionSelector: string,\n        options: ITriggerContractEnergyOptions,\n        parameters: {type: string; value: any}[],\n        issuerAddress: string,\n        callback?: _CallbackT<EstimateEnergyResponse>,\n    ): void | Promise<EstimateEnergyResponse> {\n        if (!callback)\n            return this.injectPromise(\n                this._estimateEnergyCall,\n                contractAddress,\n                functionSelector,\n                options,\n                parameters,\n                issuerAddress,\n            );\n\n        const {tokenValue, tokenId, callValue, feeLimit} = Object.assign(\n            {\n                callValue: 0,\n                feeLimit: this.tronWeb.feeLimit,\n            },\n            options,\n        );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'feeLimit',\n                        type: 'integer',\n                        value: feeLimit,\n                        gt: 0,\n                    },\n                    {\n                        name: 'callValue',\n                        type: 'integer',\n                        value: callValue,\n                        gte: 0,\n                    },\n                    {\n                        name: 'parameters',\n                        type: 'array',\n                        value: parameters,\n                    },\n                    {\n                        name: 'contract',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                        optional: true,\n                    },\n                    {\n                        name: 'tokenValue',\n                        type: 'integer',\n                        value: tokenValue,\n                        gte: 0,\n                        optional: true,\n                    },\n                    {\n                        name: 'tokenId',\n                        type: 'integer',\n                        value: tokenId,\n                        gte: 0,\n                        optional: true,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const args = {\n            // contract_address: toHex(contractAddress),\n            // owner_address: toHex(issuerAddress),\n            contract_address: contractAddress,\n            owner_address: issuerAddress,\n        } as EnergyEstimateContract\n\n        let param_str: string;\n        if (functionSelector && utils.isString(functionSelector)) {\n            functionSelector = functionSelector.replace('/s*/g', '');\n            if (parameters.length) {\n                const abiCoder = new AbiCoder();\n                let types: string[] = [];\n                const values: unknown[] = [];\n\n                for (let i = 0; i < parameters.length; i++) {\n                    // eslint-disable-next-line prefer-const\n                    let {type, value} = parameters[i];\n\n                    if (!type || !utils.isString(type) || !type.length)\n                        return callback(\n                            'Invalid parameter type provided: ' + type,\n                        ) as any as void;\n\n                    if (type === 'address')\n                        value = toHex(value).replace(\n                            ADDRESS_PREFIX_REGEX,\n                            '0x',\n                        );\n                    else if (\n                        type.match(/^([^\\x5b]*)(\\x5b|$)/)![0] === 'address['\n                    )\n                        value = value.map((v) =>\n                            toHex(v).replace(ADDRESS_PREFIX_REGEX, '0x'),\n                        );\n\n                    types.push(type);\n                    values.push(value);\n                }\n\n                try {\n                    // workaround for unsupported trcToken type\n                    types = types.map((type) => {\n                        if (/trcToken/.test(type))\n                            type = type.replace(/trcToken/, 'uint256');\n\n                        return type;\n                    });\n\n                    param_str = abiCoder\n                        .encode(types, values)\n                        .replace(/^(0x)/, '');\n                } catch (ex) {\n                    return callback(ex) as any as void;\n                }\n            } else {\n                param_str = '';\n            }\n\n            // work for abiv2 if passed the function abi in options\n            if (options.funcABIV2)\n                param_str = encodeParamsV2ByABI(\n                    options.funcABIV2,\n                    options.parametersV2,\n                ).replace(/^(0x)/, '');\n\n            if (\n                options.shieldedParameter &&\n                utils.isString(options.shieldedParameter)\n            )\n                param_str = options.shieldedParameter.replace(/^(0x)/, '');\n\n            if (options.rawParameter && utils.isString(options.rawParameter))\n                param_str = options.rawParameter.replace(/^(0x)/, '');\n\n            args.function_selector = functionSelector;\n            args.parameter = param_str;\n            args.visible = true\n        }\n\n        this.tronWeb[options.confirmed ? 'solidityNode' : 'fullNode']\n        .request(\"wallet/estimateenergy\", args, 'post').then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    clearABI(\n        contractAddress: string,\n        ownerAddress?: string,\n        callback?: undefined,\n    ): void | Promise<ITransaction>;\n    clearABI(\n        contractAddress: string,\n        ownerAddress: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction>;\n    clearABI(\n        contractAddress: string,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.clearABI,\n                contractAddress,\n                ownerAddress,\n            );\n\n        if (!this.tronWeb.isAddress(contractAddress))\n            return callback('Invalid contract address provided');\n\n        if (!this.tronWeb.isAddress(ownerAddress))\n            return callback('Invalid owner address provided');\n\n        const data = {\n            contract_address: toHex(contractAddress),\n            owner_address: toHex(ownerAddress),\n        };\n\n        if (this.tronWeb.trx.cache.contracts[contractAddress])\n            delete this.tronWeb.trx.cache.contracts[contractAddress];\n\n        this.tronWeb.fullNode\n            .request('wallet/clearabi', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    updateBrokerage(\n        brokerage: number,\n        ownerAddress?: string,\n        callback?: undefined,\n    ): void | Promise<ITransaction>;\n    updateBrokerage(\n        brokerage: number,\n        ownerAddress: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction>;\n    updateBrokerage(\n        brokerage: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateBrokerage,\n                brokerage,\n                ownerAddress,\n            );\n\n        if (!utils.isNotNullOrUndefined(brokerage))\n            return callback('Invalid brokerage provided');\n\n        if (!utils.isInteger(brokerage) || brokerage < 0 || brokerage > 100)\n            return callback('Brokerage must be an integer between 0 and 100');\n\n        if (!this.tronWeb.isAddress(ownerAddress))\n            return callback('Invalid owner address provided');\n\n        const data = {\n            brokerage: parseInt(brokerage.toString()),\n            owner_address: toHex(ownerAddress),\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updateBrokerage', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    createToken(\n        options: ICreateTokenOptions,\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    createToken(\n        options: ICreateTokenOptions,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    createToken(\n        options: ICreateTokenOptions,\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.createToken, options, issuerAddress);\n\n        const {\n            name,\n            abbreviation,\n            description,\n            url,\n            totalSupply,\n            voteScore,\n            precision,\n            saleStart = Date.now(),\n            saleEnd,\n\n            // How much TRX will `tokenRatio` cost?\n            trxRatio = 1,\n            // How many tokens will `trxRatio` afford?\n            tokenRatio = 1,\n            // The creator's \"donated\" bandwidth for use by token holders\n            freeBandwidth = 0,\n            // Out of `totalFreeBandwidth`, the amount each token holder get\n            freeBandwidthLimit = 0,\n            frozenAmount = 0,\n            frozenDuration = 0,\n            // for now there is no default for the following values\n        } = options;\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'Supply amount',\n                        type: 'positive-integer',\n                        value: totalSupply,\n                    },\n                    {\n                        name: 'TRX ratio',\n                        type: 'positive-integer',\n                        value: trxRatio,\n                    },\n                    {\n                        name: 'Token ratio',\n                        type: 'positive-integer',\n                        value: tokenRatio,\n                    },\n                    {\n                        name: 'token abbreviation',\n                        type: 'not-empty-string',\n                        value: abbreviation,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: name,\n                    },\n                    {\n                        name: 'token description',\n                        type: 'not-empty-string',\n                        value: description,\n                    },\n                    {\n                        name: 'token url',\n                        type: 'url',\n                        value: url,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        name: 'sale start timestamp',\n                        type: 'integer',\n                        value: saleStart,\n                        gte: Date.now(),\n                    },\n                    {\n                        name: 'sale end timestamp',\n                        type: 'integer',\n                        value: saleEnd,\n                        gt: parseInt(saleStart.toString()),\n                    },\n                    {\n                        name: 'Free bandwidth amount',\n                        type: 'integer',\n                        value: freeBandwidth,\n                        gte: 0,\n                    },\n                    {\n                        name: 'Free bandwidth limit',\n                        type: 'integer',\n                        value: freeBandwidthLimit,\n                        gte: 0,\n                    },\n                    {\n                        name: 'Frozen supply',\n                        type: 'integer',\n                        value: frozenAmount,\n                        gte: 0,\n                    },\n                    {\n                        name: 'Frozen duration',\n                        type: 'integer',\n                        value: frozenDuration,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        if (\n            utils.isNotNullOrUndefined(voteScore) &&\n            (!utils.isInteger(voteScore) || voteScore <= 0)\n        )\n            return callback(\n                'voteScore must be a positive integer greater than 0',\n            );\n\n        if (\n            utils.isNotNullOrUndefined(precision) &&\n            (!utils.isInteger(precision) || precision < 0 || precision > 6)\n        )\n            return callback(\n                'precision must be a positive integer >= 0 and <= 6',\n            );\n\n        const data = {\n            owner_address: toHex(issuerAddress),\n            name: fromUtf8(name),\n            abbr: fromUtf8(abbreviation),\n            description: fromUtf8(description),\n            url: fromUtf8(url),\n            total_supply: parseInt(totalSupply.toString()),\n            trx_num: parseInt(trxRatio.toString()),\n            num: parseInt(tokenRatio.toString()),\n            start_time: parseInt(saleStart.toString()),\n            end_time: parseInt(saleEnd.toString()),\n            free_asset_net_limit: parseInt(freeBandwidth.toString()),\n            public_free_asset_net_limit: parseInt(\n                freeBandwidthLimit.toString(),\n            ),\n            frozen_supply: {\n                frozen_amount: parseInt(frozenAmount.toString()),\n                frozen_days: parseInt(frozenDuration.toString()),\n            },\n            // precision: undefined as undefined | number,\n            // vote_score: undefined as undefined | number,\n            // Permission_id: undefined as undefined | number,\n        } as any;\n        // Can never happen, we validated before!\n        // if (!(parseInt(frozenAmount) > 0)) delete data.frozen_supply;\n\n        // TODO: refactor this to `else` of checking branch\n        if (precision && !isNaN(parseInt(precision.toString())))\n            data.precision = parseInt(precision.toString());\n\n        if (voteScore && !isNaN(parseInt(voteScore.toString())))\n            data.vote_score = parseInt(voteScore.toString());\n\n        if (options && options.permissionId)\n            data.Permission_id = options.permissionId;\n\n        this.tronWeb.fullNode\n            .request('wallet/createassetissue', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    updateAccount(\n        accountName: string,\n        address?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    updateAccount(\n        accountName: string,\n        address: string | undefined,\n        options: IPermissionId,\n        callback: _CallbackT<ITransaction>,\n    ): Promise<ITransaction>;\n    updateAccount(\n        accountName: string,\n        address: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateAccount,\n                accountName,\n                address,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'Name',\n                        type: 'not-empty-string',\n                        value: accountName,\n                    },\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            account_name: fromUtf8(accountName),\n            owner_address: toHex(address),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updateaccount', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    setAccountId(\n        accountId: string,\n        address?: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    setAccountId(\n        accountId: string,\n        address: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    setAccountId(\n        accountId: string,\n        address: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.setAccountId, accountId, address);\n\n        if (\n            accountId &&\n            utils.isString(accountId) &&\n            accountId.startsWith('0x')\n        )\n            accountId = accountId.slice(2);\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'accountId',\n                        type: 'hex',\n                        value: accountId,\n                    },\n                    {\n                        name: 'accountId',\n                        type: 'string',\n                        lte: 32,\n                        gte: 8,\n                        value: accountId,\n                    },\n                    {\n                        name: 'origin',\n                        type: 'address',\n                        value: address,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        this.tronWeb.fullNode\n            .request(\n                'wallet/setaccountid',\n                {\n                    account_id: accountId,\n                    owner_address: toHex(address),\n                },\n                'post',\n            )\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    updateToken(\n        options: IUpdateTokenOptions & IPermissionId,\n        issuerAddress?: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    updateToken(\n        options: IUpdateTokenOptions & IPermissionId,\n        issuerAddress: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    updateToken(\n        options: IUpdateTokenOptions & IPermissionId,\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(this.updateToken, options, issuerAddress);\n\n        const {\n            description,\n            url,\n            // The creator's \"donated\" bandwidth for use by token holders\n            freeBandwidth = 0,\n            // Out of `totalFreeBandwidth`, the amount each token holder get\n            freeBandwidthLimit = 0,\n        } = options;\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'token description',\n                        type: 'not-empty-string',\n                        value: description,\n                    },\n                    {\n                        name: 'token url',\n                        type: 'url',\n                        value: url,\n                    },\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        name: 'Free bandwidth amount',\n                        type: 'positive-integer',\n                        value: freeBandwidth,\n                    },\n                    {\n                        name: 'Free bandwidth limit',\n                        type: 'positive-integer',\n                        value: freeBandwidthLimit,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(issuerAddress),\n            description: fromUtf8(description),\n            url: fromUtf8(url),\n            new_limit: parseInt(freeBandwidth.toString()),\n            new_public_limit: parseInt(freeBandwidthLimit.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updateasset', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    sendAsset: TransactionBuilder['sendToken'] = this.sendToken.bind(this);\n    purchaseAsset: TransactionBuilder['purchaseToken'] =\n        this.purchaseToken.bind(this);\n    createAsset: TransactionBuilder['createToken'] =\n        this.createToken.bind(this);\n    updateAsset: TransactionBuilder['updateToken'] =\n        this.updateToken.bind(this);\n\n    /**\n     * Creates a proposal to modify the network.\n     * Can only be created by a current Super Representative.\n     */\n    createProposal(\n        parameters:\n            | {key: number; value: number}\n            | {key: number; value: number}[],\n        issuerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    createProposal(\n        parameters:\n            | {key: number; value: number}\n            | {key: number; value: number}[],\n        issuerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    createProposal(\n        parameters:\n            | {key: number; value: number}\n            | {key: number; value: number}[],\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.createProposal,\n                parameters,\n                issuerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const invalid = 'Invalid proposal parameters provided';\n\n        if (!parameters) return callback(invalid);\n\n        if (!utils.isArray(parameters)) parameters = [parameters];\n\n        for (const parameter of parameters)\n            if (!utils.isObject(parameter)) return callback(invalid);\n\n        const data = {\n            owner_address: toHex(issuerAddress),\n            parameters: parameters,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/proposalcreate', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Deletes a network modification proposal that the owner issued.\n     * Only current Super Representative can vote on a proposal.\n     */\n    deleteProposal(\n        proposalID: number,\n        issuerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    deleteProposal(\n        proposalID: number,\n        issuerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    deleteProposal(\n        proposalID: number,\n        issuerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.deleteProposal,\n                proposalID,\n                issuerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'issuer',\n                        type: 'address',\n                        value: issuerAddress,\n                    },\n                    {\n                        name: 'proposalID',\n                        type: 'integer',\n                        value: proposalID,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(issuerAddress),\n            proposal_id: parseInt(proposalID.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/proposaldelete', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Adds a vote to an issued network modification proposal.\n     * Only current Super Representative can vote on a proposal.\n     */\n    voteProposal(\n        proposalID: number,\n        isApproval: boolean,\n        voterAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    voteProposal(\n        proposalID: number,\n        isApproval: boolean,\n        voterAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    voteProposal(\n        proposalID: number,\n        isApproval: boolean,\n        voterAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.voteProposal,\n                proposalID,\n                isApproval,\n                voterAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'voter',\n                        type: 'address',\n                        value: voterAddress,\n                    },\n                    {\n                        name: 'proposalID',\n                        type: 'integer',\n                        value: proposalID,\n                        gte: 0,\n                    },\n                    {\n                        name: 'has approval',\n                        type: 'boolean',\n                        value: isApproval,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(voterAddress),\n            proposal_id: parseInt(proposalID.toString()),\n            is_add_approval: isApproval,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/proposalapprove', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Create an exchange between a token and TRX.\n     * Token Name should be a CASE SENSITIVE string.\n     * PLEASE VERIFY THIS ON TRONSCAN.\n     */\n    createTRXExchange(\n        tokenName: string,\n        tokenBalance: number,\n        trxBalance: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<IResources>;\n    createTRXExchange(\n        tokenName: string,\n        tokenBalance: number,\n        trxBalance: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<IResources>,\n    ): void;\n    createTRXExchange(\n        tokenName: string,\n        tokenBalance: number,\n        trxBalance: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<IResources>,\n    ): void | Promise<IResources> {\n        if (!callback)\n            return this.injectPromise(\n                this.createTRXExchange,\n                tokenName,\n                tokenBalance,\n                trxBalance,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: tokenName,\n                    },\n                    {\n                        name: 'token balance',\n                        type: 'positive-integer',\n                        value: tokenBalance,\n                    },\n                    {\n                        name: 'trx balance',\n                        type: 'positive-integer',\n                        value: trxBalance,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            first_token_id: fromUtf8(tokenName),\n            first_token_balance: tokenBalance,\n            second_token_id: '5f', // Constant for TRX.\n            second_token_balance: trxBalance,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangecreate', data, 'post')\n            .then((resources) => {\n                callback(null, resources);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Create an exchange between a token and another token.\n     * DO NOT USE THIS FOR TRX.\n     * Token Names should be a CASE SENSITIVE string.\n     * PLEASE VERIFY THIS ON TRONSCAN.\n     */\n    createTokenExchange(\n        firstTokenName: string,\n        firstTokenBalance: number,\n        secondTokenName: string,\n        secondTokenBalance: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<IResources>;\n    createTokenExchange(\n        firstTokenName: string,\n        firstTokenBalance: number,\n        secondTokenName: string,\n        secondTokenBalance: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<IResources>,\n    ): void;\n    createTokenExchange(\n        firstTokenName: string,\n        firstTokenBalance: number,\n        secondTokenName: string,\n        secondTokenBalance: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<IResources>,\n    ): void | Promise<IResources> {\n        if (!callback)\n            return this.injectPromise(\n                this.createTokenExchange,\n                firstTokenName,\n                firstTokenBalance,\n                secondTokenName,\n                secondTokenBalance,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'first token name',\n                        type: 'not-empty-string',\n                        value: firstTokenName,\n                    },\n                    {\n                        name: 'second token name',\n                        type: 'not-empty-string',\n                        value: secondTokenName,\n                    },\n                    {\n                        name: 'first token balance',\n                        type: 'positive-integer',\n                        value: firstTokenBalance,\n                    },\n                    {\n                        name: 'second token balance',\n                        type: 'positive-integer',\n                        value: secondTokenBalance,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            first_token_id: fromUtf8(firstTokenName),\n            first_token_balance: firstTokenBalance,\n            second_token_id: fromUtf8(secondTokenName),\n            second_token_balance: secondTokenBalance,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangecreate', data, 'post')\n            .then((resources) => {\n                callback(null, resources);\n            })\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Adds tokens into a bancor style exchange.\n     * Will add both tokens at market rate.\n     * Use \"_\" for the constant value for TRX.\n     */\n    injectExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    injectExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    injectExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount = 0,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.injectExchangeTokens,\n                exchangeID,\n                tokenName,\n                tokenAmount,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: tokenName,\n                    },\n                    {\n                        name: 'token amount',\n                        type: 'integer',\n                        value: tokenAmount,\n                        gte: 1,\n                    },\n                    {\n                        name: 'exchangeID',\n                        type: 'integer',\n                        value: exchangeID,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            exchange_id: parseInt(exchangeID.toString()),\n            token_id: fromUtf8(tokenName),\n            quant: parseInt(tokenAmount.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangeinject', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Withdraws tokens from a bancor style exchange.\n     * Will withdraw at market rate both tokens.\n     * Use \"_\" for the constant value for TRX.\n     */\n    withdrawExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    withdrawExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    withdrawExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmount = 0,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.withdrawExchangeTokens,\n                exchangeID,\n                tokenName,\n                tokenAmount,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: tokenName,\n                    },\n                    {\n                        name: 'token amount',\n                        type: 'integer',\n                        value: tokenAmount,\n                        gte: 1,\n                    },\n                    {\n                        name: 'exchangeID',\n                        type: 'integer',\n                        value: exchangeID,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            exchange_id: parseInt(exchangeID.toString()),\n            token_id: fromUtf8(tokenName),\n            quant: parseInt(tokenAmount.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangewithdraw', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Trade tokens on a bancor style exchange.\n     * Expected value is a validation and used to cap the total amt of token 2 spent.\n     * Use \"_\" for the constant value for TRX.\n     */\n    tradeExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmountSold: number,\n        tokenAmountExpected: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    tradeExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmountSold: number,\n        tokenAmountExpected: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    tradeExchangeTokens(\n        exchangeID: number,\n        tokenName: string,\n        tokenAmountSold = 0,\n        tokenAmountExpected = 0,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        // if (utils.isFunction(options)) {\n        //     callback = options;\n        //     options = {};\n        // }\n\n        // if (utils.isFunction(ownerAddress)) {\n        //     callback = ownerAddress;\n        //     ownerAddress = this.tronWeb.defaultAddress.hex;\n        // } else if (utils.isObject(ownerAddress)) {\n        //     options = ownerAddress;\n        //     ownerAddress = this.tronWeb.defaultAddress.hex;\n        // }\n\n        if (!callback)\n            return this.injectPromise(\n                this.tradeExchangeTokens,\n                exchangeID,\n                tokenName,\n                tokenAmountSold,\n                tokenAmountExpected,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'token name',\n                        type: 'not-empty-string',\n                        value: tokenName,\n                    },\n                    {\n                        name: 'tokenAmountSold',\n                        type: 'integer',\n                        value: tokenAmountSold,\n                        gte: 1,\n                    },\n                    {\n                        name: 'tokenAmountExpected',\n                        type: 'integer',\n                        value: tokenAmountExpected,\n                        gte: 1,\n                    },\n                    {\n                        name: 'exchangeID',\n                        type: 'integer',\n                        value: exchangeID,\n                        gte: 0,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            exchange_id: parseInt(exchangeID.toString()),\n            token_id: this.tronWeb.fromAscii(tokenName),\n            quant: parseInt(tokenAmountSold.toString()),\n            expected: parseInt(tokenAmountExpected.toString()),\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/exchangetransaction', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Update userFeePercentage.\n     */\n    updateSetting(\n        contractAddress: string,\n        userFeePercentage: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    updateSetting(\n        contractAddress: string,\n        userFeePercentage: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    updateSetting(\n        contractAddress: string,\n        userFeePercentage: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateSetting,\n                contractAddress,\n                userFeePercentage,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'contract',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                    {\n                        name: 'userFeePercentage',\n                        type: 'integer',\n                        value: userFeePercentage,\n                        gte: 0,\n                        lte: 100,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            contract_address: toHex(contractAddress),\n            consume_user_resource_percent: userFeePercentage,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updatesetting', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    /**\n     * Update energy limit.\n     */\n    updateEnergyLimit(\n        contractAddress: string,\n        originEnergyLimit: number,\n        ownerAddress?: string,\n        options?: IPermissionId,\n        callback?: unknown,\n    ): Promise<ITransaction>;\n    updateEnergyLimit(\n        contractAddress: string,\n        originEnergyLimit: number,\n        ownerAddress: string | undefined,\n        options: IPermissionId | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    updateEnergyLimit(\n        contractAddress: string,\n        originEnergyLimit: number,\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        options?: IPermissionId,\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateEnergyLimit,\n                contractAddress,\n                originEnergyLimit,\n                ownerAddress,\n                options,\n            );\n\n        if (\n            this.validator.notValid(\n                [\n                    {\n                        name: 'owner',\n                        type: 'address',\n                        value: ownerAddress,\n                    },\n                    {\n                        name: 'contract',\n                        type: 'address',\n                        value: contractAddress,\n                    },\n                    {\n                        name: 'originEnergyLimit',\n                        type: 'integer',\n                        value: originEnergyLimit,\n                        gte: 0,\n                        lte: 10_000_000,\n                    },\n                ],\n                callback,\n            )\n        )\n            return;\n\n        const data = {\n            owner_address: toHex(ownerAddress),\n            contract_address: toHex(contractAddress),\n            origin_energy_limit: originEnergyLimit,\n            Permission_id:\n                options && options.permissionId\n                    ? options.permissionId\n                    : undefined,\n        };\n\n        this.tronWeb.fullNode\n            .request('wallet/updateenergylimit', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    checkPermissions(\n        permissions: IPermissionsMinimal | null | undefined,\n        type: number,\n    ): boolean {\n        if (permissions) {\n            if (\n                permissions.type !== type ||\n                !permissions.permission_name ||\n                !utils.isString(permissions.permission_name) ||\n                !utils.isInteger(permissions.threshold) ||\n                permissions.threshold < 1 ||\n                !permissions.keys\n            )\n                return false;\n\n            for (const key of permissions.keys)\n                if (\n                    !this.tronWeb.isAddress(key.address) ||\n                    !utils.isInteger(key.weight) ||\n                    key.weight > permissions.threshold ||\n                    key.weight < 1 ||\n                    (type === 2 && !permissions.operations)\n                )\n                    return false;\n        }\n        return true;\n    }\n\n    updateAccountPermissions(\n        ownerAddress?: string,\n        ownerPermissions?: IPermissionsMinimal,\n        witnessPermissions?: IPermissionsMinimal,\n        activesPermissions?:\n            | IPermissionsMinimal\n            | (IPermissionsMinimal | undefined)[],\n        callback?: unknown,\n    ): Promise<ITransaction>;\n    updateAccountPermissions(\n        ownerAddress: string | undefined,\n        ownerPermissions: IPermissionsMinimal | undefined,\n        witnessPermissions: IPermissionsMinimal | undefined,\n        activesPermissions:\n            | IPermissionsMinimal\n            | (IPermissionsMinimal | undefined)[]\n            | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): void;\n    updateAccountPermissions(\n        ownerAddress: string = this.tronWeb.defaultAddress.hex,\n        ownerPermissions?: IPermissionsMinimal,\n        witnessPermissions?: IPermissionsMinimal,\n        activesPermissions?:\n            | IPermissionsMinimal\n            | (IPermissionsMinimal | undefined)[],\n        callback?: _CallbackT<ITransaction>,\n    ): void | Promise<ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.updateAccountPermissions,\n                ownerAddress,\n                ownerPermissions,\n                witnessPermissions,\n                activesPermissions,\n            );\n\n        if (!this.tronWeb.isAddress(ownerAddress))\n            return callback('Invalid ownerAddress provided');\n\n        if (!this.checkPermissions(ownerPermissions, 0))\n            return callback('Invalid ownerPermissions provided');\n\n        if (!this.checkPermissions(witnessPermissions, 1))\n            return callback('Invalid witnessPermissions provided');\n\n        if (!Array.isArray(activesPermissions))\n            activesPermissions = [activesPermissions];\n\n        for (const activesPermission of activesPermissions)\n            if (!this.checkPermissions(activesPermission, 2))\n                return callback('Invalid activesPermissions provided');\n\n        const data = {\n            owner_address: ownerAddress,\n            owner: undefined as undefined | IPermissions,\n            witness: undefined as undefined | IPermissions,\n            actives: [] as IPermissions[],\n        };\n        if (ownerPermissions) data.owner = ownerPermissions as IPermissions;\n\n        if (witnessPermissions)\n            data.witness = witnessPermissions as IPermissions;\n\n        if (activesPermissions)\n            data.actives = activesPermissions as IPermissions[];\n\n        this.tronWeb.fullNode\n            .request('wallet/accountpermissionupdate', data, 'post')\n            .then((transaction) => resultManager(transaction, callback))\n            .catch((err) => callback(err));\n    }\n\n    async newTxID(\n        transaction: ITransaction,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    async newTxID(\n        transaction: ITransaction,\n        callback: _CallbackT<ITransaction>,\n    ): Promise<void>;\n    async newTxID(\n        transaction: ITransaction,\n        callback?: _CallbackT<ITransaction>,\n    ): Promise<void | ITransaction> {\n        if (!callback) return this.injectPromise(this.newTxID, transaction);\n\n        this.tronWeb.fullNode\n            .request('wallet/getsignweight', transaction, 'post')\n            .then((newTransaction) => {\n                const inner = newTransaction.transaction?.transaction;\n                if (inner && typeof transaction.visible === 'boolean')\n                    inner.visible = transaction.visible;\n\n                callback(null, inner);\n            })\n            .catch(() => callback('Error generating a new transaction id.'));\n    }\n\n    async alterTransaction(\n        transaction: ITransaction,\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        options: ({} | {data: unknown; dataFormat?: string}) & {\n            extension?: number;\n        },\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    async alterTransaction(\n        transaction: ITransaction,\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        options: ({} | {data: unknown; dataFormat?: string}) & {\n            extension?: number;\n        },\n        callback: _CallbackT<ITransaction>,\n    ): Promise<void>;\n    async alterTransaction(\n        transaction: ITransaction,\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        options: ({} | {data: unknown; dataFormat?: string}) & {\n            extension?: number;\n        },\n        callback?: _CallbackT<ITransaction>,\n    ): Promise<void | ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.alterTransaction,\n                transaction,\n                options,\n            );\n\n        if (transaction.signature)\n            return callback(\n                'You can not extend the expiration of a signed transaction.',\n            );\n\n        if ('data' in options && options.data) {\n            const {data} = options;\n            let sData =\n                options.dataFormat !== 'hex'\n                    ? this.tronWeb.toHex(data)\n                    : (data as string);\n            if (!utils.isString(sData))\n                throw new TypeError('Invalid data provided');\n            sData = sData.replace(/^0x/, '');\n            if (sData.length === 0) return callback('Invalid data provided');\n            transaction.raw_data.data = sData;\n            options.data = sData;\n        }\n\n        if (options.extension) {\n            options.extension = parseInt((options.extension * 1000).toString());\n            if (\n                isNaN(options.extension) ||\n                transaction.raw_data.expiration + options.extension <=\n                    Date.now() + 3000\n            )\n                return callback('Invalid extension provided');\n            transaction.raw_data.expiration += options.extension;\n        }\n\n        this.newTxID(transaction, callback);\n    }\n\n    async extendExpiration(\n        transaction: ITransaction,\n        extension: number,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    async extendExpiration(\n        transaction: ITransaction,\n        extension: number,\n        callback: _CallbackT<ITransaction>,\n    ): Promise<void>;\n    async extendExpiration(\n        transaction: ITransaction,\n        extension: number,\n        callback?: _CallbackT<ITransaction>,\n    ): Promise<void | ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.extendExpiration,\n                transaction,\n                extension,\n            );\n\n        this.alterTransaction(transaction, {extension}, callback);\n    }\n\n    async addUpdateData(\n        transaction: ITransaction,\n        data: string,\n        dataFormat?: string,\n        callback?: undefined,\n    ): Promise<ITransaction>;\n    async addUpdateData(\n        transaction: ITransaction,\n        data: string,\n        dataFormat: string | undefined,\n        callback: _CallbackT<ITransaction>,\n    ): Promise<void>;\n    async addUpdateData(\n        transaction: ITransaction,\n        data: string,\n        dataFormat = 'utf8',\n        callback?: _CallbackT<ITransaction>,\n    ): Promise<void | ITransaction> {\n        if (!callback)\n            return this.injectPromise(\n                this.addUpdateData,\n                transaction,\n                data,\n                dataFormat,\n            );\n\n        this.alterTransaction(transaction, {data, dataFormat}, callback);\n    }\n}\n","import BigNumber from 'bignumber.js';\nimport EventEmitter from 'eventemitter3';\nimport injectpromise from 'injectpromise';\nimport semver from 'semver';\n\nimport {version} from '../version.js';\nimport Contract from './lib/contract';\nimport type {ContractEventOptions, IAbi} from './lib/contract';\nimport Event from './lib/event';\nimport type {IEvent, IEventResponse} from './lib/event';\nimport Plugin from './lib/plugin';\nimport providers from './lib/providers';\nimport {HttpProvider} from './lib/providers';\nimport SideChain from './lib/sidechain';\nimport type {IChainOptions} from './lib/sidechain';\nimport TransactionBuilder from './lib/transactionBuilder';\nimport Trx from './lib/trx';\nimport type {BlockT} from './lib/trx';\nimport utils from './utils';\nimport {ADDRESS_PREFIX, TRON_BIP39_PATH_INDEX_0} from './utils/address';\nimport {keccak256} from './utils/ethersUtils';\nimport type _CallbackT from './utils/typing';\n\nconst DEFAULT_VERSION = '3.5.0';\n\nconst FEE_LIMIT = 150000000;\n\nexport type ITronWebOptions = {\n    headers?: Record<string, string>;\n    eventHeaders?: Record<string, string>;\n    privateKey?: string;\n    disablePlugins?: string[];\n} & (\n    | {fullHost: string}\n    | {\n          fullNode: HttpProvider | string;\n          solidityNode: HttpProvider | string;\n          eventServer: HttpProvider | string;\n      }\n);\n\nexport default class TronWeb extends EventEmitter {\n    static providers = providers;\n    static BigNumber = BigNumber;\n    static TransactionBuilder = TransactionBuilder;\n    static Trx = Trx;\n    static Contract = Contract;\n    static Plugin = Plugin;\n    static Event = Event;\n    static version = version;\n    static utils = utils;\n    version = version;\n\n    providers = providers;\n    utils = utils;\n    BigNumber = BigNumber;\n    injectPromise: injectpromise;\n\n    event: Event;\n    transactionBuilder: TransactionBuilder;\n    trx: Trx;\n    plugin: Plugin;\n    sidechain?: SideChain<TronWeb>;\n\n    fullNode!: HttpProvider;\n    solidityNode!: HttpProvider;\n    eventServer!: HttpProvider;\n\n    defaultBlock: BlockT;\n    defaultPrivateKey: string;\n    defaultAddress: {\n        base58: string;\n        hex: string;\n    };\n    fullnodeVersion = DEFAULT_VERSION;\n    feeLimit = FEE_LIMIT;\n\n    constructor(options: ITronWebOptions, sideOptions?: IChainOptions);\n    constructor(\n        // for retro-compatibility:\n        options: string | HttpProvider,\n        solidityNode: string | HttpProvider,\n        eventServer?: string | HttpProvider,\n        sideOptions?: IChainOptions,\n        privateKey?: string | null,\n    );\n    constructor(\n        // for retro-compatibility:\n        options: string | HttpProvider,\n        solidityNode: string | HttpProvider,\n        eventServer?: string | HttpProvider,\n        sideOptions?: string | null,\n    );\n    constructor(\n        options: ITronWebOptions | string | HttpProvider,\n        // for retro-compatibility:\n        solidityNode?: string | IChainOptions | HttpProvider,\n        eventServer?: string | HttpProvider,\n        sideOptions?: IChainOptions | string | null,\n        privateKey?: string,\n    ) {\n        super();\n\n        let fullNode;\n        let headers;\n        let eventHeaders;\n\n        if (\n            typeof options === 'object' &&\n            ('fullNode' in options || 'fullHost' in options) &&\n            ('fullNode' in options ? options.fullNode : options.fullHost)\n        ) {\n            fullNode =\n                'fullNode' in options ? options.fullNode : options.fullHost;\n            // shift\n            sideOptions = solidityNode as any as IChainOptions;\n            solidityNode =\n                'solidityNode' in options\n                    ? options.solidityNode\n                    : options.fullHost;\n            eventServer =\n                'eventServer' in options\n                    ? options.eventServer\n                    : options.fullHost;\n            headers = options.headers || false;\n            eventHeaders = options.eventHeaders || headers;\n            privateKey = options.privateKey;\n        } else {\n            fullNode = options;\n        }\n        if (utils.isString(fullNode)) fullNode = new HttpProvider(fullNode);\n        if (utils.isString(solidityNode))\n            solidityNode = new HttpProvider(solidityNode);\n        if (utils.isString(eventServer))\n            eventServer = new HttpProvider(eventServer);\n\n        this.event = new Event(this);\n        this.transactionBuilder = new TransactionBuilder(this);\n        this.trx = new Trx(this);\n        this.plugin = new Plugin(this, options as Record<string, unknown>);\n\n        this.setFullNode(fullNode);\n        this.setSolidityNode(solidityNode as HttpProvider);\n        this.setEventServer(eventServer!);\n\n        // This allows undefined, but allowing it in class body raises 100+ errors\n        this.defaultBlock = undefined as any;\n        this.defaultPrivateKey = undefined as any;\n        this.defaultAddress = {\n            hex: undefined as any,\n            base58: undefined as any,\n        };\n\n        // for sidechain\n        if (\n            sideOptions &&\n            typeof sideOptions === 'object' &&\n            ('fullNode' in sideOptions\n                ? sideOptions.fullNode\n                : sideOptions.fullHost)\n        )\n            this.sidechain = new SideChain(\n                sideOptions,\n                TronWeb,\n                this,\n                // WTF? Was options.privateKey, which makes even less sense\n                // @ts-ignore\n                privateKey,\n            );\n        else if (typeof sideOptions !== 'string' && sideOptions != null)\n            throw new TypeError('Wrong options combination provided');\n        else if (sideOptions != null) privateKey = privateKey || sideOptions;\n\n        if (privateKey) this.setPrivateKey(privateKey);\n        this.injectPromise = injectpromise(this);\n\n        if (headers) this.setFullNodeHeader(headers);\n\n        if (eventHeaders) this.setEventHeader(eventHeaders);\n    }\n\n    async getFullnodeVersion() {\n        try {\n            const nodeInfo = await this.trx.getNodeInfo();\n            this.fullnodeVersion = nodeInfo.configNodeInfo!.codeVersion!;\n            if (this.fullnodeVersion.split('.').length === 2)\n                this.fullnodeVersion += '.0';\n        } catch (err) {\n            this.fullnodeVersion = DEFAULT_VERSION;\n        }\n    }\n\n    setDefaultBlock(blockID?: BlockT | undefined) {\n        if ([undefined, 'latest', 'earliest', 0].includes(blockID)) {\n            // This allows undefined, but allowing it in class body raises 100+ errors\n            // @ts-ignore\n            this.defaultBlock = blockID;\n            return;\n        }\n\n        if (!utils.isInteger(blockID) || !blockID)\n            throw new Error('Invalid block ID provided');\n\n        this.defaultBlock = Math.abs(blockID);\n    }\n\n    setPrivateKey(privateKey: string) {\n        try {\n            const addr = this.address.fromPrivateKey(privateKey);\n            if (addr) this.setAddress(addr);\n            else throw new Error();\n        } catch {\n            throw new Error('Invalid private key provided');\n        }\n\n        this.defaultPrivateKey = privateKey;\n        this.emit('privateKeyChanged', privateKey);\n    }\n\n    setAddress(address: string) {\n        if (!this.isAddress(address))\n            throw new Error('Invalid address provided');\n\n        const hex = this.address.toHex(address);\n        const base58 = this.address.fromHex(address);\n\n        if (\n            this.defaultPrivateKey &&\n            this.address.fromPrivateKey(this.defaultPrivateKey) !== base58\n        )\n            // This allows undefined, but allowing it in class body raises 100+ errors\n            // @ts-ignore\n            this.defaultPrivateKey = undefined;\n\n        this.defaultAddress = {\n            hex,\n            base58,\n        };\n\n        this.emit('addressChanged', {hex, base58});\n    }\n\n    fullnodeSatisfies(version: string): boolean {\n        return semver.satisfies(this.fullnodeVersion, version);\n    }\n\n    isValidProvider(provider: unknown): boolean {\n        return Object.values(providers).some(\n            (knownProvider: any) => provider instanceof knownProvider,\n        );\n    }\n\n    setFullNode(fullNode: string | HttpProvider) {\n        if (utils.isString(fullNode)) fullNode = new HttpProvider(fullNode);\n\n        if (!this.isValidProvider(fullNode))\n            throw new Error('Invalid full node provided');\n\n        this.fullNode = fullNode;\n        this.fullNode.setStatusPage('wallet/getnowblock');\n\n        this.getFullnodeVersion();\n    }\n\n    setSolidityNode(solidityNode: string | HttpProvider) {\n        if (utils.isString(solidityNode))\n            solidityNode = new HttpProvider(solidityNode);\n\n        if (!this.isValidProvider(solidityNode))\n            throw new Error('Invalid solidity node provided');\n\n        this.solidityNode = solidityNode;\n        this.solidityNode.setStatusPage('walletsolidity/getnowblock');\n    }\n\n    setEventServer(\n        eventServer: string | HttpProvider | undefined | null,\n        healthcheck = 'healthcheck',\n    ): void {\n        this.event.setServer(eventServer, healthcheck);\n    }\n\n    setHeader(headers: Record<string, string> = {}) {\n        const fullNode = new HttpProvider(\n            this.fullNode.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n        const solidityNode = new HttpProvider(\n            this.solidityNode.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n        const eventServer = new HttpProvider(\n            this.eventServer.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n\n        this.setFullNode(fullNode);\n        this.setSolidityNode(solidityNode);\n        this.setEventServer(eventServer);\n    }\n\n    setFullNodeHeader(headers: Record<string, string> = {}) {\n        const fullNode = new HttpProvider(\n            this.fullNode.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n        const solidityNode = new HttpProvider(\n            this.solidityNode.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n\n        this.setFullNode(fullNode);\n        this.setSolidityNode(solidityNode);\n    }\n\n    setEventHeader(headers: Record<string, string> = {}) {\n        const eventServer = new HttpProvider(\n            this.eventServer.host,\n            30000,\n            undefined,\n            undefined,\n            headers,\n        );\n        this.setEventServer(eventServer);\n    }\n\n    currentProviders() {\n        return {\n            fullNode: this.fullNode,\n            solidityNode: this.solidityNode,\n            eventServer: this.eventServer,\n        };\n    }\n\n    currentProvider() {\n        return this.currentProviders();\n    }\n\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback?: undefined,\n    ): Promise<IEventResponse>;\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback?: undefined,\n    ): Promise<IEvent>;\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback: _CallbackT<IEventResponse>,\n    ): void;\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback: _CallbackT<IEvent>,\n    ): void;\n    getEventResult(\n        contractAddress: string,\n        options: ContractEventOptions = {},\n        callback?: _CallbackT<IEvent> | _CallbackT<IEventResponse>,\n    ): void | Promise<IEvent> | Promise<IEventResponse> {\n        // getEventResult(...params) {\n        // if (typeof params[1] !== 'object') {\n        //     params[1] = {\n        //         sinceTimestamp: params[1] || 0,\n        //         eventName: params[2] || false,\n        //         blockNumber: params[3] || false,\n        //         size: params[4] || 20,\n        //         page: params[5] || 1,\n        //     };\n        //     params.splice(2, 4);\n\n        //     // callback:\n        //     if (!utils.isFunction(params[2])) {\n        //         if (utils.isFunction(params[1].page)) {\n        //             params[2] = params[1].page;\n        //             params[1].page = 1;\n        //         } else if (utils.isFunction(params[1].size)) {\n        //             params[2] = params[1].size;\n        //             params[1].size = 20;\n        //             params[1].page = 1;\n        //         }\n        //     }\n        // }\n\n        return this.event.getEventsByContractAddress(\n            contractAddress,\n            options as any,\n            callback as any,\n        ) as any;\n    }\n\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback?: undefined,\n    ): Promise<IEventResponse>;\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback?: undefined,\n    ): Promise<IEvent>;\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions & {rawResponse: true},\n        callback: _CallbackT<IEventResponse>,\n    ): void;\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions & {rawResponse?: false},\n        callback: _CallbackT<IEvent>,\n    ): void;\n    getEventByTransactionID(\n        transactionID: string,\n        options: ContractEventOptions = {},\n        callback?: _CallbackT<IEvent> | _CallbackT<IEventResponse>,\n    ): void | Promise<IEvent> | Promise<IEventResponse> {\n        return this.event.getEventsByTransactionID(\n            transactionID,\n            options as any,\n            callback as any,\n        ) as any;\n    }\n\n    contract(abi: IAbi[] = [], address?: string): Contract {\n        return new Contract(this, abi, address);\n    }\n\n    static get address() {\n        return {\n            fromHex(address: string): string {\n                if (!utils.isHex(address)) return address;\n\n                return utils.crypto.getBase58CheckAddress(\n                    utils.code.hexStr2byteArray(\n                        address.replace(/^0x/, ADDRESS_PREFIX),\n                    ),\n                );\n            },\n            toHex(address: string): string {\n                if (utils.isHex(address))\n                    return address.toLowerCase().replace(/^0x/, ADDRESS_PREFIX);\n\n                return utils.code\n                    .byteArray2hexStr(utils.crypto.decodeBase58Address(address))\n                    .toLowerCase();\n            },\n            fromPrivateKey(privateKey: string, strict = false): string {\n                try {\n                    return utils.crypto.pkToAddress(privateKey, strict);\n                } catch {\n                    throw new Error('Invalid private key!');\n                }\n            },\n        };\n    }\n    get address() {\n        return TronWeb.address;\n    }\n\n    static sha3(string: string, prefix = true): string {\n        return (\n            (prefix ? '0x' : '') +\n            keccak256(Buffer.from(string, 'utf-8')).toString().substring(2)\n        );\n    }\n    sha3(string: string, prefix = true): string {\n        return TronWeb.sha3(string, prefix);\n    }\n\n    static toHex(val: unknown): string {\n        if (utils.isBoolean(val)) return TronWeb.fromDecimal(+val);\n\n        if (utils.isBigNumber(val)) return TronWeb.fromDecimal(val);\n\n        if (typeof val === 'object')\n            return TronWeb.fromUtf8(JSON.stringify(val));\n\n        if (utils.isString(val)) {\n            if (/^(-|)0x/.test(val)) return val;\n\n            // `val` is really a string, and below is legacy code abusing isFinite.\n            // @ts-ignore\n            if (!isFinite(val) || /^\\s*$/.test(val))\n                return TronWeb.fromUtf8(val);\n        }\n\n        const result = TronWeb.fromDecimal(val as any);\n        if (result === '0xNaN')\n            throw new Error(\n                'The passed value is not convertible to a hex string',\n            );\n        else return result;\n    }\n    toHex(val: unknown): string {\n        return TronWeb.toHex(val);\n    }\n\n    static toUtf8(hex: string): string {\n        if (utils.isHex(hex)) {\n            hex = hex.replace(/^0x/, '');\n            return Buffer.from(hex, 'hex').toString('utf8');\n        } else {\n            throw new Error('The passed value is not a valid hex string');\n        }\n    }\n    toUtf8(hex: string): string {\n        return TronWeb.toUtf8(hex);\n    }\n\n    static fromUtf8(string: string): string {\n        if (!utils.isString(string))\n            throw new Error('The passed value is not a valid utf-8 string');\n\n        return '0x' + Buffer.from(string, 'utf8').toString('hex');\n    }\n    fromUtf8(string: string): string {\n        return TronWeb.fromUtf8(string);\n    }\n\n    static toAscii(hex: string): string {\n        if (utils.isHex(hex)) {\n            let str = '';\n            // FIXME: it's very bad\n            let i = hex.substring(0, 2) === '0x' ? 2 : 0;\n\n            for (; i < hex.length; i += 2) {\n                const code = parseInt(hex.substr(i, 2), 16);\n                str += String.fromCharCode(code);\n            }\n            return str;\n        } else {\n            throw new Error('The passed value is not a valid hex string');\n        }\n    }\n    toAscii(hex: string): string {\n        return TronWeb.toAscii(hex);\n    }\n\n    static fromAscii(string: string, padding = 0) {\n        if (!utils.isString(string))\n            throw new Error('The passed value is not a valid utf-8 string');\n\n        return (\n            '0x' +\n            Buffer.from(string, 'ascii').toString('hex').padEnd(padding, '0')\n        );\n    }\n    fromAscii(string: string, padding = 0) {\n        return TronWeb.fromAscii(string, padding);\n    }\n\n    static toDecimal(value: string | number | BigNumber): number {\n        return TronWeb.toBigNumber(value).toNumber();\n    }\n    toDecimal(value: string | number | BigNumber): number {\n        return TronWeb.toDecimal(value);\n    }\n\n    static fromDecimal(value: string | number | BigNumber): string {\n        const number = TronWeb.toBigNumber(value);\n        const result = number.toString(16);\n\n        return number.isLessThan(0) ? '-0x' + result.substr(1) : '0x' + result;\n    }\n    fromDecimal(value: string | number | BigNumber): string {\n        return TronWeb.fromDecimal(value);\n    }\n\n    static fromSun(sun: BigNumber): BigNumber;\n    static fromSun(sun: string | number): string;\n    static fromSun(sun: BigNumber | string | number): BigNumber | string {\n        const trx = TronWeb.toBigNumber(sun).div(1_000_000);\n        return utils.isBigNumber(sun) ? trx : trx.toString(10);\n    }\n    fromSun(sun: BigNumber): BigNumber;\n    fromSun(sun: string | number): string;\n    fromSun(sun: BigNumber | string | number): BigNumber | string {\n        return TronWeb.fromSun(sun as any);\n    }\n\n    static toSun(trx: BigNumber): BigNumber;\n    static toSun(trx: string | number): string;\n    static toSun(trx: BigNumber | string | number): BigNumber | string {\n        const sun = TronWeb.toBigNumber(trx).times(1_000_000);\n        return utils.isBigNumber(trx) ? sun : sun.toString(10);\n    }\n    toSun(trx: BigNumber): BigNumber;\n    toSun(trx: string | number): string;\n    toSun(trx: BigNumber | string | number): BigNumber | string {\n        return TronWeb.toSun(trx as any);\n    }\n\n    static toBigNumber(amount: string | number | BigNumber = 0): BigNumber {\n        if (utils.isBigNumber(amount)) return amount;\n\n        if (utils.isString(amount) && /^(-|)0x/.test(amount))\n            return new BigNumber(amount.replace('0x', ''), 16);\n\n        return new BigNumber(amount.toString(10), 10);\n    }\n    toBigNumber(amount: string | number | BigNumber = 0): BigNumber {\n        return TronWeb.toBigNumber(amount);\n    }\n\n    static isAddress(address: unknown): address is string {\n        if (!utils.isString(address)) return false;\n\n        // Convert HEX to Base58\n        if (address.length === 42)\n            try {\n                return TronWeb.isAddress(\n                    utils.crypto.getBase58CheckAddress(\n                        // it throws an error if the address starts with 0x\n                        utils.code.hexStr2byteArray(address),\n                    ),\n                );\n            } catch (err) {\n                return false;\n            }\n\n        try {\n            return utils.crypto.isAddressValid(address);\n        } catch (err) {\n            return false;\n        }\n    }\n    isAddress(address: unknown): address is string {\n        return TronWeb.isAddress(address);\n    }\n\n    static async createAccount() {\n        return utils.accounts.generateAccount();\n    }\n    async createAccount() {\n        return TronWeb.createAccount();\n    }\n\n    static createRandom(options = {}) {\n        return utils.accounts.generateRandom(options);\n    }\n    createRandom(options = {}) {\n        return TronWeb.createRandom(options);\n    }\n\n    static fromMnemonic(\n        mnemonic: string,\n        path = TRON_BIP39_PATH_INDEX_0,\n        wordlist = 'en',\n    ) {\n        return utils.accounts.generateAccountWithMnemonic(\n            mnemonic,\n            path,\n            wordlist,\n        );\n    }\n    fromMnemonic(\n        mnemonic: string,\n        path = TRON_BIP39_PATH_INDEX_0,\n        wordlist = 'en',\n    ) {\n        return TronWeb.fromMnemonic(mnemonic, path, wordlist);\n    }\n\n    async isConnected(callback?: undefined): Promise<any>;\n    async isConnected(callback: _CallbackT<any>): Promise<void>;\n    async isConnected(callback?: _CallbackT<any>): Promise<void | any> {\n        if (!callback) return this.injectPromise(this.isConnected);\n\n        return callback(null, {\n            fullNode: await this.fullNode.isConnected(),\n            solidityNode: await this.solidityNode.isConnected(),\n            eventServer:\n                this.eventServer && (await this.eventServer.isConnected()),\n        });\n    }\n}\n"],"names":["protobufPackage","AccountType","Normal","AssetIssue","Contract","ReasonCode","REQUESTED","BAD_PROTOCOL","TOO_MANY_PEERS","DUPLICATE_PEER","INCOMPATIBLE_PROTOCOL","NULL_IDENTITY","PEER_QUITING","UNEXPECTED_IDENTITY","LOCAL_IDENTITY","PING_TIMEOUT","USER_REASON","RESET","SYNC_FAIL","FETCH_FAIL","BAD_TX","BAD_BLOCK","FORKED","UNLINKABLE","INCOMPATIBLE_VERSION","INCOMPATIBLE_CHAIN","TIME_OUT","CONNECT_FAIL","TOO_MANY_PEERS_WITH_SAME_IP","LIGHT_NODE_SYNC_FAIL","UNKNOWN","Proposal_State","PENDING","DISAPPROVED","APPROVED","CANCELED","MarketOrder_State","ACTIVE","INACTIVE","Permission_PermissionType","Owner","Witness","Active","Transaction_Contract_ContractType","AccountCreateContract","TransferContract","TransferAssetContract","VoteAssetContract","VoteWitnessContract","WitnessCreateContract","AssetIssueContract","WitnessUpdateContract","ParticipateAssetIssueContract","AccountUpdateContract","FreezeBalanceContract","UnfreezeBalanceContract","WithdrawBalanceContract","UnfreezeAssetContract","UpdateAssetContract","ProposalCreateContract","ProposalApproveContract","ProposalDeleteContract","SetAccountIdContract","CustomContract","CreateSmartContract","TriggerSmartContract","GetContract","UpdateSettingContract","ExchangeCreateContract","ExchangeInjectContract","ExchangeWithdrawContract","ExchangeTransactionContract","UpdateEnergyLimitContract","AccountPermissionUpdateContract","ClearABIContract","UpdateBrokerageContract","ShieldedTransferContract","MarketSellAssetContract","MarketCancelOrderContract","Transaction_Result_code","SUCESS","FAILED","Transaction_Result_contractResult","DEFAULT","SUCCESS","REVERT","BAD_JUMP_DESTINATION","OUT_OF_MEMORY","PRECOMPILED_CONTRACT","STACK_TOO_SMALL","STACK_TOO_LARGE","ILLEGAL_OPERATION","STACK_OVERFLOW","OUT_OF_ENERGY","OUT_OF_TIME","JVM_STACK_OVER_FLOW","TRANSFER_FAILED","INVALID_CODE","TransactionInfo_code","BlockInventory_Type","SYNC","ADVTISE","FETCH","Inventory_InventoryType","TRX","BLOCK","Items_ItemType","ERR","BLOCKHEADER","PBFTMessage_MsgType","VIEW_CHANGE","REQUEST","PREPREPARE","PREPARE","COMMIT","PBFTMessage_DataType","SRL","ResourceCode","BANDWIDTH","ENERGY","TRON_POWER","SmartContract_ABI_Entry_EntryType","UnknownEntryType","Constructor","Function","Event","Fallback","Receive","Error","SmartContract_ABI_Entry_StateMutabilityType","UnknownMutabilityType","Pure","View","Nonpayable","Payable","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","version","WithTronwebAndInjectpromise","tronWeb","this","injectPromise","injectpromise","ADDRESS_PREFIX","ADDRESS_PREFIX_REGEX","TRON_BIP39_PATH_INDEX_0","TRON_BIP39_PATH_PREFIX","keccak256","utils","sha256","toUtf8Bytes","toUtf8String","recoverAddress","SigningKey_","AbiCoder","Interface","FormatTypes","arrayify","splitSignature","joinSignature","concat","id","isValidMnemonic","SigningKey","privateKey","abiCoder","_addressToHex","TronWeb","address","toHex","replace","deepCopy","target","toString","newTarget","Array","isArray","decodeParams","names_","types_","output_","ignoreMethodHash_","ignoreMethodHash","output","types","names","length","substring","map","type","test","decode","reduce","arg","index","substr","toLowerCase","push","encodeParams","values","i","encode","extractSize","size","match","extractArrayDim","encodeParamsV2ByABI","funABI","args","buildFullTypeDefinition","typeDef","indexOf","components","innerTypes","innerType","join","convertAddresses","addrArr","forEach","addrs","mapTuple","dimension","encodeArgs","inputs","input","convertTypes","decodeParamsV2ByABI","data","decodeResult","buildFullTypeNameDefinition","name","outputs","result","outputTypes","convertTypeNames","Uint8Array","decodeResCopy","Base64","chr1","chr2","chr3","enc1","enc2","enc3","enc4","charCodeAt","isNaN","_keyStr","charAt","inputBytes","String","fromCharCode","_utf8_decode","_out2ByteArray","utftext","byteArray","string","c","c2","c3","byte2hexStr","byte","hexByteMap","bytesToString","arr","str","one","v","bytesLength","store","slice","st","parseInt","hextoString","hex","split","out","tmp","byteArray2hexStr","base64DecodeFromString","string64","decodeToByteArray","base64EncodeToString","bytes","encodeIgnoreUtf8","ALPHABET","ALPHABET_MAP","encode58","buffer","j","digits","carry","reverse","digit","decode58","bin2String","arrayEquals","array1","array2","strict","JSON","stringify","stringToBytes","len","hexChar2byte","isHexChar","hexStr2byteArray","k","strToDate","tempStrs","dateStrs","year","month","day","timeStrs","hour","minute","second","Date","isNumber","getStringType","logger","Logger","getTronAddress","text","padding","fill","NegativeOne","BigNumber","Zero","One","MaxUint256","hexTrue","hexZeroPad","toHexString","hexFalse","domainFieldTypes","chainId","verifyingContract","salt","domainFieldNames","checkString","throwArgumentError","domainChecks","error","hexlify","getBaseEncoder","signed","width","boundsUpper","mask","boundsLower","add","mul","lt","gt","toTwos","padOffset","hexConcat","hexPadRight","encodeType","fields","TypedDataEncoder","defineReadOnly","freeze","links","parents","subtypes","keys","uniqueNames","field","baseType","primaryTypes","filter","t","checkCircular","found","child","subtype","primaryType","sort","_types","encoder","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","unshift","encodeData","hashStruct","callback","_visit","accum","from","domain","domainFields","b","EIP712Domain","hashDomain","hash","domainValues","domainTypes","typesWithDomain","shallowCopy","message","visit","EC","el","getBase58CheckAddress","addressBytes","checkSum","decodeBase58Address","base58String","error_msg","checkSum1","signTransaction","priKeyBytes","transaction","signature","getECKeySig","txID","includes","ecRecover","signedData","recovered","arrayToBase64String","btoa","signBytes","contents","_signTypedData","signingKey","messageDigest","signDigest","s","Number","getRowBytesFromTransactionBase64","base64Data","genPriKey","priKeyHex","genKeyPair","getPrivate","computeAddress","pubBytes","getAddressFromPriKey","getPubKeyFromPriKey","decode58Check","addressStr","decodeCheck","decodeData","isAddressValid","base58Str","getBase58CheckAddressFromPriKeyBase64String","priKeyBase64String","getHexStrAddressFromPriKeyBase64String","getAddressFromPriKeyBase64String","pubkey","keyFromPrivate","getPublic","xHex","x","padStart","yHex","y","hashBytes","sign","recoveryParam","ECKeySign","msgBytes","msgHex","ethSha256","SHA256","passwordToAddress","password","pkToAddress","com_priKeyBytes","com_addressBytes","INVALID_TRON_PATH_ERROR_MSG","generateAccount","pubKeyBytes","publicKey","base58","generateRandom","options","path","account","ethersWallet","mnemonic","generateAccountWithMnemonic","wordlist","TRON_MESSAGE_PREFIX","hashMessage","signMessage","verifyMessage","isValidURL","url","validator","protocols","require_tld","isObject","array","isJson","parse","ex","isBoolean","bool","isBigNumber","number","constructor","isString","isFunction","isHex","isInteger","hasProperty","property","hasProperties","properties","mapEvent","event","block","block_number","timestamp","block_timestamp","contract","contract_address","event_name","transaction_id","resourceNode","resource_Node","_unconfirmed","unconfirmed","_fingerprint","fingerprint","parseEvent","abi","padLeft","amount","res","isNotNullOrUndefined","val","sleep","millis","Promise","resolve","setTimeout","code","accounts","crypto","_TypedDataEncoder","ethersUtils","MISSING_ADDRESS_MSG","decodeOutput","Method","functionSelector","stateMutability","iface","getEvent","format","getFunction","getFunctionSelector","sha3","defaultOptions","feeLimit","callValue","userFeePercentage","shouldPollResponse","rawParameter","_call","send","defaultPrivateKey","_send","watch","_watch","bind","deployed","final_options","defaultAddress","_isConstant","parameters","transactionBuilder","triggerConstantContract","err","constant_result","msg","msg2","chunk","toUtf8","fromPrivateKey","triggerSmartContract","trx","signedTransaction","sendRawTransaction","broadcast","maxRetries","pollingInterval","checkResult","getTransactionInfo","resMessage","rawResponse","decoded","contractResult","keepTxID","eventServer","listener","lastBlock","since","now","getEvents","params","eventName","blockNumber","filters","onlyUnconfirmed","onlyConfirmed","getEventsByContractAddress","events","latestEvent","newEvents","some","priorEvent","reject","bindListener","clearInterval","setInterval","then","start","stop","eventListener","eventCallback","bytecode","methods","methodInstances","props","isAddress","loadAbi","_getEvents","console","__proto__","func","method","methodCall","onMethod","methodName","inputData","decodeInput","createSmartContract","at","contractAddress","getContract","entrys","self","startCallback","_startEventListener","_stopEventListener","HttpProvider","host","timeout","user","headers","statusPage","instance","axios","baseURL","auth","username","request","serviceName","payload","healthcheck","providers","isValidProvider","isConnected","assign","sinceTimestamp","page","fromTimestamp","previousLastEventFingerprint","previousFingerprint","routeParams","warn","fromHex","qs","only_confirmed","only_unconfirmed","querystring","response","transactionID","getEventsByTransactionID","Plugin","pluginNoOverride","disablePlugins","PluginCls","pluginInterface","requires","libs","plugged","skipped","plugin","semver","fullClass","className","classInstanceName","component","compare","opts","gte","lte","Validator","param","normalized","no","optional","notPositive","notEqual","invalid","INVALID_TX_MESSAGE","SideChain","sideOptions","TronWebCls","mainchain","depositFee","depositTrc","trxHash","mappingFee","mappingTrc","nonce","retryFee","mainGatewayAddress","sideGatewayAddress","sideChainId","sidechain","fullHost","fullNode","solidityNode","setMainGatewayAddress","setSideGatewayAddress","setChainId","multiSign","chainIdByteArr","_byteArr","byteArr","byteArrHash","permissionId","raw_data","Permission_id","getSignWeight","signWeight","foundKey","permission","approved_list","useTronHeader","multisig","signatureHex","signString","parameter","owner_address","depositTrx","notValid","contractInstance","depositTRX","tokenId","tokenValue","depositTrc10","depositTRC10","num","fee","approveInstance","approve","startsWith","mappingTRC20","mappingTRC721","withdrawFee","withdrawTrx","withdrawTRX","withdrawTrc10","withdrawTRC10","numOrId","withdrawTrc","injectFund","hexAddress","google_protobuf_any_pb","Transaction","Permission","Key","FreezeBalanceV2Contract","UnfreezeBalanceV2Contract","WithdrawExpireUnfreezeContract","DelegateResourceContract","UnDelegateResourceContract","SmartContract","fromHexString","hexString","buildCommonTransaction","contractType","typeName","anyValue","Any","pack","serializeBinary","setType","setParameter","setPermissionId","raw","addContract","setRawData","contractJsonToProtobuf","to_address","transferContract","setToAddress","setOwnerAddress","setAmount","ContractType","TRANSFERCONTRACT","buildTransferContract","asset_name","setAssetName","TRANSFERASSETCONTRACT","buildTransferAssetContract","pbObj","PARTICIPATEASSETISSUECONTRACT","buildParticipateAssetIssueContract","function_selector","call_value","call_token_value","token_id","setContractAddress","setCallValue","setData","contractData","Buffer","setTokenId","setCallTokenValue","TRIGGERSMARTCONTRACT","buildTriggerSmartContract","freezeBalanceContract","frozen_balance","frozen_duration","resource","receiver_address","setFrozenBalance","setFrozenDuration","setResource","setReceiverAddress","FREEZEBALANCECONTRACT","buildFreezeBalanceContract","unfreezeBalanceContract","UNFREEZEBALANCECONTRACT","buildUnfreezeBalanceContract","withdrawbalanceContract","WITHDRAWBALANCECONTRACT","buildWithdrawBalanceContract","freezeBalanceV2Contract","FREEZEBALANCEV2CONTRACT","buildFreezeBalanceV2Contract","withdrawExpireUnfreeze","CANCELALLUNFREEZEV2CONTRACT","buildCancelFreezeBalanceV2Contract","unfreezeBalanceV2Contract","unfreeze_balance","setUnfreezeBalance","UNFREEZEBALANCEV2CONTRACT","buildUnfreezeBalanceV2Contract","delegateResourceContract","balance","lock","lock_period","setBalance","setLock","setLockPeriod","DELEGATERESOURCECONTRACT","buildDelegateResourceContract","unDelegateResourceContract","UNDELEGATERESOURCECONTRACT","buildUnDelegateResourceContract","WITHDRAWEXPIREUNFREEZECONTRACT","buildWithdrawExpireUnfreezeContract","createWitnessContract","setUrl","WITNESSCREATECONTRACT","buildCreateWitness","voteWitnessContract","votes","voteItem","vote","Vote","vote_address","vote_count","setVoteAddress","numberOfVotes","setVoteCount","addVotes","VOTEWITNESSCONTRACT","buildVoteWitnessAccount","new_contract","consume_user_resource_percent","origin_energy_limit","contracName","origin_address","smartContractBuilder","abiJson","abiBuilder","ABI","buildEntryParam","Entry","Param","indexed","setIndexed","setName","entryBuilders","entry","anonymous","constant","payable","entryBuilder","setAnonymous","setConstant","setInputsList","setOutputsList","EntryType","toUpperCase","setPayable","setStatemutability","StateMutabilityType","setEntrysList","setAbi","setConsumeUserResourcePercent","setOriginEnergyLimit","setOriginAddress","bytecodeParameter","setBytecode","setNewContract","CREATESMARTCONTRACT","buildCreateSmartContract","clearABIContract","CLEARABICONTRACT","buildClearABIContract","brokerage","updateBrokerageContract","setBrokerage","UPDATEBROKERAGECONTRACT","buildUpdateBrokerageContract","abbr","description","total_supply","trx_num","start_time","end_time","precision","free_asset_net_limit","public_free_asset_net_limit","public_free_asset_net_usage","public_latest_free_net_time","vote_score","frozen_supply","assetIssueContract","setAbbr","setTotalSupply","setNum","setEndTime","setStartTime","setTrxNum","setVoteScore","setPrecision","setPublicLatestFreeNetTime","setDescription","setPublicFreeAssetNetUsage","setFreeAssetNetLimit","setPublicFreeAssetNetLimit","frozenSupplyContract","FrozenSupply","setFrozenAmount","frozen_amount","setFrozenDays","frozen_days","addFrozenSupply","ASSETISSUECONTRACT","buildAssetIssueContract","accountCreateContract","account_address","setAccountAddress","ACCOUNTCREATECONTRACT","buildAccountCreateContract","accountUpdateContract","account_name","setAccountName","ACCOUNTUPDATECONTRACT","buildAccountUpdateContract","setAccountIdContract","account_id","setAccountId","SETACCOUNTIDCONTRACT","buildSetAccountIdContract","proposalCreateContract","getParametersMap","set","PROPOSALCREATECONTRACT","buildProposalCreateContract","proposalDeleteContract","proposal_id","setProposalId","PROPOSALDELETECONTRACT","buildProposalDeleteContract","proposalVoteContract","is_add_approval","setIsAddApproval","PROPOSALAPPROVECONTRACT","buildVoteProposalContract","exchangeCreateContract","first_token_id","first_token_balance","second_token_id","second_token_balance","setFirstTokenId","setFirstTokenBalance","setSecondTokenId","setSecondTokenBalance","EXCHANGECREATECONTRACT","buildExchangeCreateContract","exchangeInjectContract","exchange_id","quant","setExchangeId","setQuant","EXCHANGEINJECTCONTRACT","buildExchangeInjectContract","exchangeWithdrawContract","EXCHANGEWITHDRAWCONTRACT","buildExchangeWithdrawContract","exchangeTransactionContract","expected","setExpected","EXCHANGETRANSACTIONCONTRACT","buildExchangeTransactionContract","updateSettingContract","UPDATESETTINGCONTRACT","buildUpdateSettingContract","updateEnergyLimitContract","UPDATEENERGYLIMITCONTRACT","buildUpdateEnergyLimitContract","accountPermissionUpdateContract","owner","witness","actives","buildPermission","permission_name","threshold","parentId","operations","getType","setId","setPermissionName","setThreshold","setParentId","setOperations","setKeysList","keyBuilder","setAddress","setWeight","weight","setOwner","setWitness","setActivesList","active","ACCOUNTPERMISSIONUPDATECONTRACT","buildAccountPermissionUpdateContract","updateAssetContract","new_limit","new_public_limit","setNewLimit","setNewPublicLimit","UPDATEASSETCONTRACT","buildUpdateAssetContract","txCheck","transactionPb","rawData","contractJson","transactionObj","rawDataObj","getRawData","setRefBlockBytes","ref_block_bytes","setRefBlockHash","ref_block_hash","fee_limit","setFeeLimit","expiration","setExpiration","setTimestamp","txJsonToPb","rawDataBytes","rawDataHex","raw_data_hex","compareTransaction","TRX_MESSAGE_HEADER","ETH_MESSAGE_HEADER","INVALID_ADDRESS_MSG","INVALID_TOKEN_ID_MSG","TOKEN_DOES_NOT_EXIST_MSG","INVALID_TRANSACTION_MSG","INVALID_AMOUNT_MSG","NEED_PK_OR_ADDRESS_MSG","Trx","sendToken","sendTransaction","sendHexTransaction","getUnconfirmedTransaction","cache","contracts","token","getCurrentBlock","getConfirmedCurrentBlock","defaultBlock","getBlockByHash","getBlockByNumber","getBlock","blockHash","blockID","getBlockTransactionCount","transactions","getTransactionFromBlock","getTransaction","getConfirmedTransaction","_getTransactionInfoById","confirmed","limit","offset","getTransactionsRelated","direction","all","to","tx","getAccount","getAccountById","getAccountInfoById","getBalance","getUnconfirmedAccount","getUnconfirmedAccountById","getUnconfirmedBalance","freeNetUsed","freeNetLimit","NetUsed","NetLimit","getBandwidth","assetIssue","tokens","_parseToken","getTokensIssuedByAddress","tokenID","fromUtf8","getTokenFromID","listNodes","nodes","port","end","startNum","endNum","getBlockRange","listSuperRepresentatives","witnesses","listTokens","timeUntilNextVoteCycle","Math","floor","verifySignature","verifyMessageV2","verifyTypedData","signMessageV2","getApprovedList","signedHexTransaction","hexTransaction","sendTrx","duration","receiverAddress","freezeBalance","unfreezeBalance","accountName","updateAccount","proposalID","proposal","getProposal","listProposals","proposals","getChainParameters","chainParameter","resources","getAccountResources","exchangeID","exchange","getExchangeByID","listExchanges","exchanges","listExchangesPaginated","getNodeInfo","info","getTokenListByName","getTokenByID","_getReward","_getBrokerage","reward","prices","tronAddress","sig","messageBytes","base58Address","INVALID_RESOURCE_MESSAGE","resultManager","TransactionBuilder","purchaseToken","createToken","updateToken","issuerAddress","buyer","ResourceT","withdrawBlockRewards","applyForSR","voterAddress","votesArr","entries","srAddress","voteCount","originEnergyLimit","abi_arr","funcABIV2","parametersV2","constructorParams","find","it","constructorParams2","_triggerSmartContract","estimateEnergy","_estimateEnergyCall","param_str","shieldedParameter","pathInfo","visible","ownerAddress","clearABI","updateBrokerage","abbreviation","totalSupply","voteScore","saleStart","saleEnd","trxRatio","tokenRatio","freeBandwidth","freeBandwidthLimit","frozenAmount","frozenDuration","accountId","createProposal","deleteProposal","isApproval","voteProposal","tokenName","tokenBalance","trxBalance","createTRXExchange","firstTokenName","firstTokenBalance","secondTokenName","secondTokenBalance","createTokenExchange","tokenAmount","injectExchangeTokens","withdrawExchangeTokens","tokenAmountSold","tokenAmountExpected","tradeExchangeTokens","fromAscii","updateSetting","updateEnergyLimit","permissions","ownerPermissions","witnessPermissions","activesPermissions","updateAccountPermissions","checkPermissions","activesPermission","newTxID","newTransaction","inner","alterTransaction","sData","dataFormat","TypeError","extension","extendExpiration","addUpdateData","DEFAULT_VERSION","eventHeaders","setFullNode","setSolidityNode","setEventServer","setPrivateKey","setFullNodeHeader","setEventHeader","nodeInfo","fullnodeVersion","configNodeInfo","codeVersion","abs","addr","emit","provider","knownProvider","setStatusPage","getFullnodeVersion","setServer","currentProviders","prefix","toAscii","toDecimal","fromDecimal","sun","fromSun","toSun","toBigNumber","createAccount","createRandom","fromMnemonic","isFinite","padEnd","toNumber","isLessThan","div","times","EventEmitter"],"sourceRoot":""}